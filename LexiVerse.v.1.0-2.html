<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Enable standalone web app mode on iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <!-- Progressive Web App manifest and icons -->
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <meta name="theme-color" content="#007aff" />
  <!-- Updated title to reflect the new name of the application. -->
  <!-- Updated title to reflect the new name of the application. -->
  <title>LexiVerse – Вивчення англійської</title>
  <!-- Modern Google font -->
  <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet" />
  <!-- Font Awesome icons for richer button illustrations -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-dF2+MQve2O3a6yOD87o5iV/mQJu1nvLKYj1WFJsbgx5caGV5/C/PObbIVdQydb9h9NP7VDaRao7IYQ7fZeFKAQ==" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <style>

/* =========================
   LexiVerse — Modern UI Pack
   Version: 1.0 (2025-08-14)
   Author: ChatGPT
   Notes:
   - Drop-in stylesheet that *replaces* your current <style> block.
   - No JS changes required; all IDs/classes from the old UI are respected.
   - Light/Dark modes supported via body.dark (already used by your code).
   ========================= */

/* --------- CSS Reset (condensed) ---------- */
*,
*::before,
*::after { box-sizing: border-box; }
html { -webkit-text-size-adjust: 100%; }
body, h1, h2, h3, h4, h5, h6, p, figure { margin: 0; }
button, input, select, textarea { font: inherit; }

/* --------- Design Tokens ---------- */
:root {
  --bg: #0b1020;
  --bg-soft: #0f1630;
  --panel: rgba(255,255,255,0.06);
  --panel-strong: rgba(255,255,255,0.12);
  --txt: #e6e9f2;
  --txt-dim: #b6bdd6;
  --brand: #6aa6ff;
  --brand-2: #9b7bff;
  --accent: #ff6a95;
  --good: #52e2c0;
  --warn: #f3b562;
  --danger: #ff6a6a;
  --ring: rgba(106,166,255,0.5);
  --radius-s: 10px;
  --radius-m: 14px;
  --radius-l: 20px;
  --shadow-1: 0 10px 30px rgba(0,0,0,0.25);
  --blur: blur(16px);
  --font-ui: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Rubik', sans-serif;
}

/* Light theme (auto when body:not(.dark)) */
body:not(.dark) {
  --bg: #f5f7fb;
  --bg-soft: #eef2f9;
  --panel: rgba(12,18,44,0.06);
  --panel-strong: rgba(12,18,44,0.12);
  --txt: #0c122c;
  --txt-dim: #53607b;
  --brand: #1a73e8;
  --brand-2: #6b4cff;
  --accent: #e9426d;
  --good: #0fa968;
  --warn: #b7791f;
  --danger: #d7263d;
  --ring: rgba(26,115,232,0.35);
}

/* --------- Base ---------- */
@media (prefers-reduced-motion: no-preference) {
  :root { scroll-behavior: smooth; }
}
body {
  font-family: var(--font-ui);
  color: var(--txt);
  background:
    radial-gradient(1200px 800px at 10% -10%, rgba(106,166,255,0.25), transparent 60%),
    radial-gradient(1000px 700px at 110% 10%, rgba(155,123,255,0.22), transparent 60%),
    radial-gradient(900px 700px at 50% 120%, rgba(233,66,109,0.18), transparent 60%),
    var(--bg);
  min-height: 100svh;
  display: flex;
  flex-direction: column;
  line-height: 1.45;
}

/* Focus styles */
:where(a, button, [tabindex], input, select, textarea):focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--ring);
  border-radius: 12px;
}

/* --------- App Header ---------- */
header {
  position: sticky; top: 0; z-index: 40;
  display: grid; grid-template-columns: 1fr auto; gap: 12px;
  align-items: center;
  padding: clamp(12px, 2vw, 18px) clamp(16px, 3vw, 28px);
  background: color-mix(in oklab, var(--bg) 80%, transparent);
  -webkit-backdrop-filter: var(--blur);
  backdrop-filter: var(--blur);
  border-bottom: 1px solid var(--panel-strong);
}
header h1 {
  font-weight: 800;
  letter-spacing: -0.02em;
  font-size: clamp(1.2rem, 0.9rem + 1.2vw, 1.8rem);
  background: linear-gradient(120deg, var(--brand), var(--brand-2));
  -webkit-background-clip: text; background-clip: text; color: transparent;
}
header .language-toggle,
#resetBtn,
#profileBtnTop,
#importTopBtn {
  appearance: none;
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  color: var(--txt);
  padding: 10px 14px;
  border-radius: 999px;
  cursor: pointer;
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
  display: inline-flex; align-items: center; gap: 8px;
}
header .language-toggle:hover,
#resetBtn:hover,
#profileBtnTop:hover,
#importTopBtn:hover { transform: translateY(-1px); border-color: var(--panel); }
header .language-toggle:active,
#resetBtn:active,
#profileBtnTop:active,
#importTopBtn:active { transform: translateY(0); }

/* --------- Containers / Cards ---------- */
.container,
.profile-card {
  width: min(1100px, 100%);
  margin-inline: auto;
  background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
  border: 1px solid var(--panel-strong);
  border-radius: var(--radius-l);
  padding: clamp(20px, 2vw, 36px);
  box-shadow: var(--shadow-1);
}
main {
  flex: 1;
  padding: clamp(12px, 2vw, 24px);
  display: grid;
  place-items: start center;
  gap: 20px;
}

/* --------- Start Screen Overlay ---------- */
#startScreen {
  position: fixed; inset: 0; z-index: 50;
  display: grid; place-items: center;
  background:
    radial-gradient(1200px 700px at 50% -10%, rgba(155,123,255,0.18), transparent 60%),
    linear-gradient(180deg, color-mix(in oklab, var(--bg) 96%, transparent), var(--bg));
  padding: 24px;
}
#startScreen .btn.btn-large {
  font-weight: 700;
  letter-spacing: .01em;
}

/* --------- Buttons ---------- */
.btn {
  --btn-bg: linear-gradient(180deg, color-mix(in oklab, var(--brand) 86%, white 0%), color-mix(in oklab, var(--brand-2) 40%, black 0%));
  --btn-border: color-mix(in oklab, var(--brand) 60%, black 20%);
  border: 1px solid var(--btn-border);
  background: var(--btn-bg);
  color: white;
  padding: 12px 22px;
  border-radius: 14px;
  cursor: pointer;
  display: inline-flex; align-items: center; justify-content: center; gap: 10px;
  transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
}
.btn:hover { transform: translateY(-1px); filter: brightness(1.08); }
.btn:active { transform: translateY(0); filter: brightness(.96); }
.btn-secondary {
  --btn-bg: linear-gradient(180deg, color-mix(in oklab, var(--brand-2) 80%, white 0%), color-mix(in oklab, var(--brand) 35%, black 0%));
  --btn-border: color-mix(in oklab, var(--brand-2) 60%, black 20%);
}
.btn-large { padding: 16px 28px; font-size: 1.075rem; border-radius: 16px; }

/* Icon sizing inside buttons */
.btn img.icon { width: 22px; height: 22px; }
header .language-toggle img.icon { width: 18px; height: 18px; }

/* --------- Typography blocks ---------- */
.center { text-align: center; }
.question {
  font-size: clamp(1.1rem, 1rem + .6vw, 1.45rem);
  font-weight: 700;
  letter-spacing: -0.01em;
  margin-bottom: 10px;
}

/* --------- Interactive Lists ---------- */
.options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 12px;
  margin-top: 8px;
}
.option {
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.015));
  border-radius: 12px;
  padding: 14px 16px;
  cursor: pointer;
  transition: transform .12s ease, border-color .2s ease, background .2s ease;
}
.option:hover { transform: translateY(-2px); border-color: var(--panel); }
.option:active { transform: translateY(0); }

/* --------- Inputs ---------- */
input[type="text"],
input[type="file"],
select {
  width: 100%;
  background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.04));
  color: var(--txt);
  border: 1px solid var(--panel-strong);
  border-radius: 12px;
  padding: 12px 14px;
  transition: box-shadow .2s ease, border-color .2s ease;
}
input::placeholder { color: var(--txt-dim); }
input:focus { border-color: var(--brand); box-shadow: 0 0 0 4px var(--ring); }

/* --------- Progress Bar ---------- */
.progress-bar {
  height: 12px;
  background: color-mix(in oklab, var(--panel), transparent 30%);
  border-radius: 999px;
  overflow: hidden;
  margin-top: 16px;
  border: 1px solid var(--panel-strong);
}
.progress-bar > div {
  height: 100%;
  width: 0;
  background: linear-gradient(90deg, var(--good), var(--brand));
  transition: width .35s ease;
}

/* --------- Lives ---------- */
#livesContainer {
  font-size: 1.4rem;
  letter-spacing: 6px;
  color: var(--accent);
}

/* --------- Cards (learn/mistakes) ---------- */
.word-card {
  background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
  border: 1px solid var(--panel-strong);
  border-radius: 12px;
  padding: 12px 16px;
  transition: transform .12s ease, border-color .2s ease;
}
.word-card:hover { transform: translateY(-2px); border-color: var(--panel); }

/* --------- Category cards ---------- */
.category-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; }
.category-card {
  width: 190px;
  text-align: center;
  border: 1px solid var(--panel-strong);
  border-radius: 14px;
  padding: 18px;
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  transition: transform .12s ease, border-color .2s ease, background .2s ease;
  cursor: pointer;
}
.category-card:hover {
  transform: translateY(-2px);
  border-color: var(--panel);
  background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.03));
}

/* --------- Memory Game ---------- */
.memory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
  gap: 14px;
}
.memory-card {
  height: 90px;
  display: grid; place-items: center;
  border-radius: 12px;
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  user-select: none;
  font-weight: 600;
  transition: transform .12s ease, background .2s ease, border-color .2s ease;
}
.memory-card.flipped { background: linear-gradient(180deg, var(--brand), var(--brand-2)); color: white; }
.memory-card.matched { background: linear-gradient(180deg, var(--good), var(--brand)); color: white; }
.memory-card:hover { transform: translateY(-2px); border-color: var(--panel); }

/* --------- Modal ---------- */
.profile-modal {
  position: fixed; inset: 0; z-index: 60;
  display: grid; place-items: center;
  background: rgba(0,0,0,0.45);
  padding: 20px;
}
.profile-card-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
.profile-section {
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  border: 1px solid var(--panel-strong);
  border-radius: 12px;
  padding: 14px;
  margin: 12px 0;
}
.stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap: 12px; }
.stat { text-align: center; border: 1px solid var(--panel-strong); border-radius: 12px; padding: 12px; background: rgba(255,255,255,0.04); }

/* --------- Tables (Irregular Verbs) ---------- */
.table, #irregularTable { width: 100%; border-collapse: collapse; }
.table th, .table td, #irregularTable th, #irregularTable td {
  border: 1px solid var(--panel-strong);
  padding: 10px 12px;
}
.table th, #irregularTable th {
  background: linear-gradient(180deg, var(--brand), var(--brand-2));
  color: white;
}

/* --------- Footer ---------- */
footer {
  margin-top: auto;
  text-align: center;
  padding: 16px;
  color: var(--txt-dim);
  background: color-mix(in oklab, var(--bg) 92%, transparent);
  border-top: 1px solid var(--panel-strong);
}

/* --------- Utilities ---------- */
.hidden { display: none !important; }

/* --------- Responsive ---------- */
@media (max-width: 640px) {
  header { grid-template-columns: 1fr; gap: 8px; }
  header h1 { text-align: center; }
  .btn { width: 100%; }
  .options { grid-template-columns: 1fr; }
  .category-card { width: 100%; }
}

/* Fun micro-animations for icons */
.btn img.icon { transition: transform .2s ease; }
.btn:hover img.icon { transform: scale(1.07) rotate(-3deg); }

</style>
<style>
/* ===== Hotfix 2025-08-14: Profile opacity + spacing ===== */
.profile-modal{background:rgba(0,0,0,0.65)!important;}
.profile-card{
  background: linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.15)) !important;
  border: 1px solid var(--panel-strong);
  border-radius: var(--radius-l);
  padding: clamp(22px, 2.4vw, 32px) !important;
  box-shadow: 0 24px 60px rgba(0,0,0,0.35);
}
body.dark .profile-card{
  background: linear-gradient(180deg, rgba(20,24,36,0.6), rgba(20,24,36,0.45)) !important;
}
.profile-section{
  background: linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.08)) !important;
  padding: 16px 18px !important;
  margin: 16px 0 !important;
  border-radius: 14px;
}
.stat-grid{gap:16px !important;}
.stat{padding:14px !important;}
/* General layout breathing room */
.container{padding: clamp(22px, 2.6vw, 40px) !important;}
main{gap: 28px !important;}
.question{margin-bottom: 14px !important;}
.options{gap: 16px !important; margin-top: 12px !important;}
.option{padding: 16px 18px !important;}
.category-list{gap: 16px !important;}
.category-card{padding: 20px !important;}
.word-card{padding: 14px 18px !important; margin: 6px 0 !important;}
/* Controls */
input[type="text"], select{padding: 12px 16px !important;}
.progress-bar{margin-top: 20px !important;}
/* Buttons in rows shouldn't touch each other */
.btn{margin: 2px 4px !important;}
/* Modal close button ensure above overlay */
.profile-modal .btn-close, .profile-modal [data-close]{position: relative; z-index: 2;}
</style>
<style>
/* ===== Hotfix v2: kill excessive transparency (start screen + profile + cards) ===== */

/* Start screen must be fully opaque */
#startScreen{
  background: linear-gradient(180deg, var(--bg-soft), var(--bg)) !important;
  -webkit-backdrop-filter: none !important;
  backdrop-filter: none !important;
}

/* App cards/containers more solid so content never washes out */
body:not(.dark) .container{ background: #ffffff !important; }
body.dark .container{ background: #0f1630 !important; }

/* Profile modal overlay darker */
.profile-modal{
  background: rgba(0,0,0,0.78) !important; /* was .45 then .65 */
}

/* Profile card totally solid per theme to avoid bleed-through */
body:not(.dark) .profile-card{
  background: #ffffff !important;
  box-shadow: 0 28px 70px rgba(0,0,0,0.35) !important;
}
body.dark .profile-card{
  background: #12192f !important;
  box-shadow: 0 28px 70px rgba(0,0,0,0.6) !important;
}

/* Profile sections more solid */
body:not(.dark) .profile-section{ background: #f4f6fb !important; }
body.dark .profile-section{ background: #18213d !important; }

/* Buttons & tiles keep spacing and readability */
.btn{ margin: 4px 6px !important; }
.options{ gap: 18px !important; }
.category-list{ gap: 18px !important; }

/* Ensure modal content sits above any backdrop blur layers */
.profile-modal .profile-card{ position: relative; z-index: 1; }

/* Increase base text contrast for cards */
.container, .profile-card, .profile-section{ color: var(--txt) !important; }
</style>
<style>
/* ===== Enhancement v3: modern profile buttons + mobile header toggle ===== */

/* Profile action buttons — modern look */
.profile-card button {
  appearance: none;
  border: 1px solid color-mix(in oklab, var(--brand) 55%, black 15%);
  background: linear-gradient(180deg, var(--brand), var(--brand-2));
  color: #fff;
  padding: 10px 14px;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 10px 24px rgba(0,0,0,0.15);
  transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
  margin: 6px 8px 6px 0;
}
.profile-card button:hover { transform: translateY(-1px); filter: brightness(1.06); }
.profile-card button:active { transform: translateY(0); filter: brightness(.96); }

/* Make a 'danger' style for the second button (e.g., Clear history) */
.profile-card button:nth-of-type(2) {
  border-color: color-mix(in oklab, var(--danger) 65%, black 10%);
  background: linear-gradient(180deg, #ff6a6a, #e9426d);
}

/* Optional small variant (if any) */
.profile-card .btn, .profile-card .btn-small { padding: 10px 14px; border-radius: 12px; }

/* Header mobile menu */
#navToggle {
  display: none;
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
  color: var(--txt);
  border-radius: 10px;
  padding: 8px 10px;
  cursor: pointer;
}
#navToggle:focus-visible { box-shadow: 0 0 0 3px var(--ring); }

.header-actions {
  display: flex;
  gap: 8px;
  align-items: center;
}

@media (max-width: 768px) {
  header { position: sticky; top: 0; }
  #navToggle { display: inline-flex; align-items: center; gap: 8px; }
  .header-actions {
    display: none;
    position: absolute;
    top: 100%;
    right: 16px;
    left: 16px;
    padding: 12px;
    border: 1px solid var(--panel-strong);
    border-radius: 14px;
    background: color-mix(in oklab, var(--bg) 92%, transparent);
    -webkit-backdrop-filter: var(--blur);
    backdrop-filter: var(--blur);
    box-shadow: 0 16px 40px rgba(0,0,0,.35);
    flex-wrap: wrap;
    z-index: 45;
  }
  header.open .header-actions { display: flex; }
}
</style>
<style>
/* ===== Hotfix v4: dark theme select dropdown ===== */
body.dark select {
  background-color: #1a2238 !important;
  color: #f0f2f8 !important;
  border: 1px solid var(--panel-strong) !important;
}
body.dark select option {
  background-color: #1a2238 !important;
  color: #f0f2f8 !important;
}
</style>
</head>
<body>
  <!-- Start Screen -->
  <div id="startScreen">
    <!-- Updated game name and description for LexiVerse -->
    <h1 id="startTitle">LexiVerse</h1>
    <p id="startDesc">Пориньте у світ пригод у навчанні англійської мови разом з LexiVerse!</p>
    <!-- The start button hides the start screen directly via inline JavaScript. Using
         `this.parentElement.style.display='none'` ensures that the overlay disappears even
         if the external script fails to load. The button now contains an image icon from a free icon library. -->
    <button class="btn btn-large" id="startBtn" onclick="this.parentElement.style.display='none'">
      <img class="icon" src="https://img.icons8.com/color/48/play.png" alt="" />
      <span id="startBtnText">Почати</span>
    </button>
  </div>

  <header>
    <!-- Updated header with new game name -->
    <h1 id="title">LexiVerse</h1>
    <button class="language-toggle" id="languageToggle">UA / EN</button>
    <button class="language-toggle" id="themeToggle">🌙</button>
    <!-- Hidden file input for top import button -->
    <input type="file" id="importFileTop" accept=".csv" style="display:none" onchange="importWords(event)" />
    <!-- Import words button placed in the header -->
    <button class="language-toggle" id="importTopBtn" onclick="document.getElementById('importFileTop').click()" style="margin-left:10px;">
      <img class="icon" src="https://img.icons8.com/color/48/upload.png" alt="" />
      <span id="importTopText">Імпорт слів</span>
    </button>
    <!-- Profile button to open user stats modal -->
    <button class="language-toggle" id="profileBtnTop" onclick="openProfile()" style="margin-left:10px;">
      <img class="icon" src="https://img.icons8.com/color/48/user.png" alt="" />
      <span id="profileTopText">Профіль</span>
    </button>

    <!-- Reset data button for clearing local storage -->
    <button class="language-toggle" id="resetBtn" onclick="resetData()" style="margin-left:10px;">
      <img class="icon" src="https://img.icons8.com/color/48/refresh.png" alt="" />
      <span id="resetBtnText">Скинути</span>
    </button>
  </header>
  <main>
    
    <!-- Profile Modal -->
    <div id="profileModal" class="profile-modal hidden" aria-modal="true" role="dialog">
      <div class="profile-card" role="document">
        <div class="profile-card-header">
          <h2 id="profileTitle">Профіль</h2>
          <button class="language-toggle" onclick="closeProfile()" id="profileCloseBtn">✕</button>
        </div>
        <div class="profile-actions">
          <button class="language-toggle" onclick="exportHistoryCSV()" id="profileExportBtn">Експорт CSV</button>
          <button class="language-toggle" onclick="clearHistoryData()" id="profileClearBtn">Очистити історію</button>
        </div>
        <div class="profile-section">
          <h3 id="profileSummaryTitle">Зведення</h3>
          <div id="profileSummary"></div>
        </div>
        <div class="profile-section">
          <h3 id="profileByLevelTitle">За рівнями</h3>
          <div id="profileByLevel"></div>
        </div>
        <div class="profile-section">
          <h3 id="profileByModeTitle">За іграми</h3>
          <div id="profileByMode"></div>
        </div>
        <div class="profile-section">
          <h3 id="profileRecentTitle">Останні результати</h3>
          <div id="profileRecent"></div>
        </div>
      </div>
    </div>
<!-- Home Screen -->
    <div class="container" id="homeScreen">
      <div class="center">
        <h2 id="homeTitle">Виберіть рівень</h2>
        <!-- Updated home description to use the new game name -->
        <p id="homeDesc">LexiVerse допоможе вам вивчити англійську мову, граючи. Оберіть рівень складності або ознайомтесь з усіма словами.</p>
        <!-- Greeting and stats for user -->
        <p id="greeting" style="font-weight:600; margin-top:10px;"></p>
        <p id="stats" style="margin-top:5px;"></p>
        <!-- Button for setting the player's name -->
        <button class="btn btn-secondary" id="setNameBtn" onclick="promptName()" style="margin-bottom:15px;">
          <img class="icon" src="https://img.icons8.com/color/48/user.png" alt="" />
          <span id="setNameText"></span>
        </button>
        <!-- Level selection buttons with colourful icons -->
        <button class="btn" onclick="goToLevel('beginner')">
          <img class="icon" src="https://img.icons8.com/color/48/star.png" alt="" />
          <span id="beginnerBtn">Початківець</span>
        </button>
        <button class="btn btn-secondary" onclick="goToLevel('intermediate')">
          <img class="icon" src="https://img.icons8.com/color/48/graduation-cap.png" alt="" />
          <span id="intermediateBtn">Середній</span>
        </button>
        <button class="btn" onclick="goToLevel('advanced')">
          <img class="icon" src="https://img.icons8.com/color/48/rocket.png" alt="" />
          <span id="advancedBtn">Просунутий</span>
        </button>
        <br />
        <!-- Learning and other modes -->
        <button class="btn" onclick="openLearn()">
          <img class="icon" src="https://img.icons8.com/color/48/book.png" alt="" />
          <span id="learnBtn">Навчання</span>
        </button>
        <button class="btn btn-secondary hidden" id="mistakesBtn" onclick="openMistakes()">
          <img class="icon" src="https://img.icons8.com/color/48/cancel.png" alt="" />
          <span id="mistakesText">Помилки</span>
        </button>
        <button class="btn" onclick="openMemory()">
          <img class="icon" src="https://img.icons8.com/color/48/brain.png" alt="" />
          <span id="memoryBtn">Пам'ять</span>
        </button>

        <!-- Additional modes -->
        <button class="btn" onclick="goListening()" id="listeningBtn">
          <img class="icon" src="https://img.icons8.com/color/48/headphones.png" alt="" />
          <span id="listeningBtnText">Аудіювання</span>
        </button>
        <button class="btn" onclick="startHangman()" id="hangmanBtn">
          <!-- Use a colourful skull icon from Icons8 for Hangman -->
          <img class="icon" src="https://img.icons8.com/color/48/skull.png" alt="" />
          <span id="hangmanBtnText">Виселиці</span>
        </button>

        <!-- True/False mini‑game button -->
        <button class="btn" onclick="goTrueFalse()" id="tfBtn">
          <img class="icon" src="https://img.icons8.com/color/48/checked--v1.png" alt="" />
          <span id="tfBtnText">Правда/Неправда</span>
        </button>
        <!-- Anagram mini‑game button -->
        <button class="btn" onclick="goAnagram()" id="anagramBtn">
          <img class="icon" src="https://img.icons8.com/color/48/puzzle.png" alt="" />
          <span id="anagramBtnText">Анаграми</span>
        </button>
        <!-- Irregular verbs table button -->
        <button class="btn" onclick="openIrregular()" id="irregularBtn">
          <!-- Use a different book icon for irregular verbs to ensure it loads correctly -->
          <img class="icon" src="https://img.icons8.com/color/48/open-book.png" alt="" />
          <span id="irregularBtnText">Неправильні дієслова</span>
        </button>
        <!-- Hidden file input for importing custom words -->
        <!-- Hide the old import button since import is now handled in the header -->
        <input type="file" id="importFile" accept=".csv" style="display:none" onchange="importWords(event)" />
        <button class="btn hidden" onclick="document.getElementById('importFile').click()">
          <img class="icon" src="https://img.icons8.com/color/48/upload.png" alt="" />
          <span id="importBtn">Імпорт слів</span>
        </button>
        <button class="btn hidden" id="customBtn" onclick="goToLevel('custom')">
          <img class="icon" src="https://img.icons8.com/color/48/list.png" alt="" />
          <span id="customBtnText">Користувацькі слова</span>
        </button>
      
      <div class="toggle" style="display:inline-flex;align-items:center;gap:8px;">
        <label id="voiceLabel" for="voiceSelect" style="font-size:12px;">Voice</label>
        <select id="voiceSelect" aria-label="TTS Voice"></select>
      </div>
      <div class="toggle" style="display:inline-flex;align-items:center;gap:8px;">
        <label id="rateLabel" for="rateRange" style="font-size:12px;">Rate</label>
        <input id="rateRange" type="range" min="0.7" max="1.3" value="1" step="0.05" style="width:90px;">
      </div>
    </div>
    </div>
    <!-- Learn Screen -->
    <div class="container hidden" id="learnScreen">
      <div class="center">
        <h2 id="learnTitle">Навчання</h2>
        <p id="learnDesc">Оберіть категорію або шукайте слово</p>
        <div class="search-bar">
          <input type="text" id="searchInput" placeholder="Пошук..." oninput="filterWords()" />
        </div>
        <div class="category-list" id="categoryList">
          <div class="category-card" onclick="selectCategory('beginner')" id="catBeginner">Початковий</div>
          <div class="category-card" onclick="selectCategory('intermediate')" id="catIntermediate">Середній</div>
          <div class="category-card" onclick="selectCategory('advanced')" id="catAdvanced">Просунутий</div>
          <div class="category-card" onclick="selectCategory('all')" id="catAll">Усі слова</div>
        </div>
        <div id="learnWordsList"></div>
        <button class="btn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="backBtn">Назад</span>
        </button>
      </div>
    </div>
    <!-- Mistakes Screen -->
    <div class="container hidden" id="mistakesScreen">
      <div class="center">
        <h2 id="mistakesTitle">Помилки</h2>
        <p id="mistakesDesc">Слова, на які ви відповіли неправильно. Повторюйте їх для кращого запам'ятовування.</p>
        <div id="mistakesList"></div>
        <button class="btn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="backBtn2">Назад</span>
        </button>
      </div>
    </div>

    <!-- Memory Game Screen -->
    <div class="container hidden" id="memoryScreen">
      <div class="center">
        <h2 id="memoryTitle">Гра пам'ять</h2>
        <p id="memoryDesc">Знайдіть пари англійських слів та їх переклади.</p>
        <div id="memoryGrid" class="memory-grid"></div>
        <button class="btn" id="memoryStartBtn" onclick="startMemoryGame()">
          <img class="icon" src="https://img.icons8.com/color/48/play.png" alt="" />
          <span id="memoryStartBtnText">Почати гру</span>
        </button>
        <button class="btn" id="memoryBackBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="memoryBackBtnText">Назад</span>
        </button>
      </div>
    </div>
    <!-- Game Screen -->
    <div class="container hidden" id="gameScreen">
      <div class="center">
        <h2 id="levelTitle"></h2>
        <div id="livesContainer" style="text-align:center; margin-bottom:10px;"></div>
        <div class="question" id="questionText"></div>
        <!-- Audio pronunciation button will be injected here -->
        <div id="audioContainer" style="margin-bottom: 10px;"></div>
        <div class="options" id="optionsContainer"></div>
        <input id="answerInput" class="hidden" type="text" autocomplete="off" />
        <button class="btn hidden" id="submitBtn" onclick="submitAnswer()"></button>
        <div class="progress-bar"><div id="progressBarFill"></div></div>
        <button class="btn btn-secondary" id="quitBtn" onclick="quitGame()" style="margin-top:15px;">
          <img class="icon" src="https://img.icons8.com/color/48/logout-rounded-left.png" alt="" />
          <span id="quitBtnText"></span>
        </button>
      </div>
    </div>
    <!-- Result Screen -->
    <div class="container hidden" id="resultScreen">
      <div class="center">
        <h2 id="resultTitle"></h2>
        <div class="result" id="scoreText"></div>
        <div id="wrongWordsSection"></div>
        <button class="btn" onclick="restart()">
          <img class="icon" src="https://img.icons8.com/color/48/home.png" alt="" />
          <span id="restartBtn">На головну</span>
        </button>
      </div>
    </div>

    <!-- Hangman Screen -->
    <div class="container hidden" id="hangmanScreen">
      <div class="center">
        <h2 id="hangmanTitle">Hangman</h2>
        <p id="hangmanDesc">Guess the English word letter by letter.</p>
        <p id="hangmanHint" style="font-style: italic;"></p>
        <div id="hangmanLives" style="margin:10px; font-size:1.4rem; color: var(--accent-color);"></div>
        <div id="hangmanDisplay" style="font-size:2rem; letter-spacing:8px; margin:20px 0;"></div>
        <div id="hangmanWrongLetters" style="margin-bottom:10px; color: var(--secondary-color);"></div>
        <input type="text" id="hangmanInput" maxlength="1" style="width:60px; padding:8px; text-align:center; font-size:1.2rem;" />
        <br/>
        <button class="btn" id="hangmanSubmitBtn" onclick="guessHangmanLetter()">Guess</button>
        <button class="btn" id="hangmanRestartBtn" onclick="startHangman()">Restart</button>
        <button class="btn btn-secondary" id="hangmanBackBtn" onclick="backToHome()">Back</button>
      </div>
    </div>

    <!-- True/False Game Screen -->
    <div class="container hidden" id="tfScreen">
      <div class="center">
        <h2 id="tfTitle">True/False Game</h2>
        <p id="tfDesc">Choose whether the translation is correct.</p>
        <div class="question" id="tfQuestion"></div>
        <div class="options" id="tfOptions" style="flex-direction: row; justify-content:center; gap:20px; margin-top:15px;">
          <button class="btn" id="tfTrueBtn" onclick="answerTF(true)">
            <img class="icon" src="https://img.icons8.com/color/48/checked--v1.png" alt="" />
            <span id="tfTrueBtnText">True</span>
          </button>
          <button class="btn btn-secondary" id="tfFalseBtn" onclick="answerTF(false)">
            <img class="icon" src="https://img.icons8.com/color/48/multiply.png" alt="" />
            <span id="tfFalseBtnText">False</span>
          </button>
        </div>
        <p id="tfProgress" style="margin-top:10px;"></p>
        <!-- Back button always visible to return to home from True/False game -->
        <button class="btn" id="tfBackBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="tfBackBtnText">Назад</span>
        </button>
        <!-- Finish button shown when game ends -->
        <button class="btn hidden" id="tfFinishBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="tfFinishBtnText">Back</span>
        </button>
      </div>
    </div>

    <!-- Anagram Game Screen -->
    <div class="container hidden" id="anagramScreen">
      <div class="center">
        <h2 id="anagramTitle">Анаграма</h2>
        <p id="anagramDesc">Розшифруйте англійське слово за його перекладом.</p>
        <div class="question" id="anagramQuestion"></div>
        <input type="text" id="anagramInput" autocomplete="off" style="padding: 10px; font-size:1rem; border:2px solid var(--primary-color); border-radius:8px;" />
        <div style="margin-top:15px;">
          <button class="btn" id="anagramSubmitBtn" onclick="submitAnagram()">Відповісти</button>
        </div>
        <p id="anagramProgress" style="margin-top:10px;"></p>
        <!-- Back button always visible to return to home from Anagram game -->
        <button class="btn" id="anagramBackBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="anagramBackBtnText">Назад</span>
        </button>
        <!-- Finish button shown when game ends -->
        <button class="btn hidden" id="anagramFinishBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="anagramFinishBtnText">Назад</span>
        </button>
      </div>
    </div>

    <!-- Irregular Verbs Screen -->
    <div class="container hidden" id="irregularScreen">
      <div class="center">
        <h2 id="irregularTitle">Таблиця неправильних дієслів</h2>
        <p id="irregularDesc">Повний список неправильних дієслів та їхні форми.</p>
        <div id="irregularTableContainer" style="overflow-x:auto; margin-top: 15px;">
          <table id="irregularTable" style="width:100%; border-collapse: collapse;">
            <!-- Table header and body will be generated dynamically -->
          </table>
        </div>
        <button class="btn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="irregularBackBtn">Назад</span>
        </button>
      </div>
    </div>
  </main>
  <footer>
    <!-- Footer text will be localized via updateUI() using ui[currentLang].footer -->
    <p id="footerText">© 2025 Sashkin Apps. Усі права захищені.</p>
  </footer>
  <script>
    /**
     * Remove trailing numeric suffixes from an English word. Some words in
     * the dataset have numeric suffixes added to increase the number of
     * entries; however, when displaying words to the user we do not want
     * these digits to appear. This helper returns the word without any
     * trailing digits.
     * @param {string} str - the English word, potentially with trailing digits
     * @returns {string} the word with trailing digits removed
     */
    function stripDigits(str) {
      return str ? str.replace(/\d+$/, '') : str;
    }
    /* Vocabulary data for the game */
    const beginnerWords = [
      { en: 'hello', uk: 'привіт' },
      { en: 'goodbye', uk: 'до побачення' },
      { en: 'please', uk: 'будь ласка' },
      { en: 'thank you', uk: 'дякую' },
      { en: 'yes', uk: 'так' },
      { en: 'no', uk: 'ні' },
      { en: 'I', uk: 'я' },
      { en: 'you', uk: 'ти' },
      { en: 'he', uk: 'він' },
      { en: 'she', uk: 'вона' },
      { en: 'we', uk: 'ми' },
      { en: 'they', uk: 'вони' },
      { en: 'one', uk: 'один' },
      { en: 'two', uk: 'два' },
      { en: 'three', uk: 'три' },
      { en: 'four', uk: 'чотири' },
      { en: 'five', uk: "п'ять" },
      { en: 'six', uk: 'шість' },
      { en: 'seven', uk: 'сім' },
      { en: 'eight', uk: 'вісім' },
      { en: 'nine', uk: "дев'ять" },
      { en: 'ten', uk: 'десять' },
      { en: 'red', uk: 'червоний' },
      { en: 'blue', uk: 'синій' },
      { en: 'green', uk: 'зелений' },
      { en: 'black', uk: 'чорний' },
      { en: 'white', uk: 'білий' },
      { en: 'cat', uk: 'кіт' },
      { en: 'dog', uk: 'собака' },
      { en: 'bird', uk: 'птах' },
      { en: 'fish', uk: 'риба' },
      { en: 'apple', uk: 'яблуко' },
      { en: 'banana', uk: 'банан' },
      { en: 'orange', uk: 'апельсин' },
      { en: 'lemon', uk: 'лимон' },
      { en: 'bread', uk: 'хліб' },
      { en: 'water', uk: 'вода' },
      { en: 'milk', uk: 'молоко' },
      { en: 'tea', uk: 'чай' },
      { en: 'coffee', uk: 'кава' },
      { en: 'eat', uk: 'їсти' },
      { en: 'drink', uk: 'пити' },
      { en: 'sleep', uk: 'спати' },
      { en: 'go', uk: 'йти' },
      { en: 'come', uk: 'приходити' },
      { en: 'house', uk: 'будинок' },
      { en: 'school', uk: 'школа' },
      { en: 'car', uk: 'машина' },
      { en: 'book', uk: 'книга' },
      { en: 'good', uk: 'хороший' },
      { en: 'bad', uk: 'поганий' },
      { en: 'big', uk: 'великий' },
      { en: 'small', uk: 'маленький' }
    ];
    const intermediateWords = [
      { en: 'write', uk: 'писати' },
      { en: 'read', uk: 'читати' },
      { en: 'speak', uk: 'говорити' },
      { en: 'listen', uk: 'слухати' },
      { en: 'see', uk: 'бачити' },
      { en: 'hear', uk: 'чути' },
      { en: 'give', uk: 'давати' },
      { en: 'take', uk: 'брати' },
      { en: 'make', uk: 'робити' },
      { en: 'think', uk: 'думати' },
      { en: 'know', uk: 'знати' },
      { en: 'want', uk: 'хотіти' },
      { en: 'like', uk: 'подобатись' },
      { en: 'love', uk: 'любити' },
      { en: 'hate', uk: 'ненавидіти' },
      { en: 'buy', uk: 'купувати' },
      { en: 'sell', uk: 'продавати' },
      { en: 'pay', uk: 'платити' },
      { en: 'learn', uk: 'вчити' },
      { en: 'teach', uk: 'навчати' },
      { en: 'help', uk: 'допомагати' },
      { en: 'need', uk: 'потребувати' },
      { en: 'find', uk: 'знаходити' },
      { en: 'meet', uk: 'зустрічати' },
      { en: 'build', uk: 'будувати' },
      { en: 'job', uk: 'робота' },
      { en: 'bus', uk: 'автобус' },
      { en: 'train', uk: 'потяг' },
      { en: 'city', uk: 'місто' },
      { en: 'country', uk: 'країна' },
      { en: 'day', uk: 'день' },
      { en: 'night', uk: 'ніч' },
      { en: 'morning', uk: 'ранок' },
      { en: 'evening', uk: 'вечір' },
      { en: 'week', uk: 'тиждень' },
      { en: 'month', uk: 'місяць' },
      { en: 'year', uk: 'рік' },
      { en: 'time', uk: 'час' },
      { en: 'friend', uk: 'друг' },
      { en: 'family', uk: 'родина' },
      { en: 'mother', uk: 'мати' },
      { en: 'father', uk: 'батько' },
      { en: 'brother', uk: 'брат' },
      { en: 'sister', uk: 'сестра' },
      { en: 'son', uk: 'син' },
      { en: 'daughter', uk: 'дочка' },
      { en: 'husband', uk: 'чоловік' },
      { en: 'wife', uk: 'дружина' },
      { en: 'old', uk: 'старий' },
      { en: 'young', uk: 'молодий' },
      { en: 'new', uk: 'новий' },
      { en: 'high', uk: 'високий' },
      { en: 'low', uk: 'низький' },
      { en: 'hot', uk: 'гарячий' },
      { en: 'cold', uk: 'холодний' },
      { en: 'warm', uk: 'теплий' },
      { en: 'cool', uk: 'прохолодний' },
      { en: 'full', uk: 'повний' },
      { en: 'empty', uk: 'порожній' },
      { en: 'strong', uk: 'сильний' },
      { en: 'weak', uk: 'слабкий' },
      { en: 'rich', uk: 'багатий' },
      { en: 'poor', uk: 'бідний' },
      { en: 'fast', uk: 'швидкий' },
      { en: 'slow', uk: 'повільний' },
      { en: 'beautiful', uk: 'красивий' },
      { en: 'ugly', uk: 'потворний' },
      { en: 'easy', uk: 'легкий' },
      { en: 'difficult', uk: 'складний' },
      { en: 'expensive', uk: 'дорогий' },
      { en: 'cheap', uk: 'дешевий' },
      { en: 'happy', uk: 'щасливий' },
      { en: 'sad', uk: 'сумний' },
      { en: 'angry', uk: 'сердитий' },
      { en: 'hungry', uk: 'голодний' },
      { en: 'thirsty', uk: 'спраглий' },
      { en: 'tired', uk: 'втомлений' },
      { en: 'busy', uk: 'зайнятий' },
      { en: 'free', uk: 'вільний' },
      { en: 'in', uk: 'в' },
      { en: 'on', uk: 'на' },
      { en: 'under', uk: 'під' },
      { en: 'between', uk: 'між' },
      { en: 'behind', uk: 'за' },
      { en: 'front', uk: 'перед' },
      { en: 'near', uk: 'поруч' },
      { en: 'around', uk: 'навколо' },
      { en: 'with', uk: 'з' },
      { en: 'without', uk: 'без' },
      { en: 'always', uk: 'завжди' },
      { en: 'usually', uk: 'зазвичай' },
      { en: 'often', uk: 'часто' },
      { en: 'sometimes', uk: 'іноді' },
      { en: 'never', uk: 'ніколи' },
      { en: 'here', uk: 'тут' },
      { en: 'there', uk: 'там' },
      { en: 'now', uk: 'зараз' },
      { en: 'then', uk: 'тоді' },
      { en: 'soon', uk: 'скоро' },
      { en: 'today', uk: 'сьогодні' },
      { en: 'tomorrow', uk: 'завтра' },
      { en: 'yesterday', uk: 'вчора' },
      { en: 'early', uk: 'рано' },
      { en: 'late', uk: 'пізно' },
      { en: 'quickly', uk: 'швидко' },
      { en: 'slowly', uk: 'повільно' },
      { en: 'well', uk: 'добре' },
      { en: 'badly', uk: 'погано' },
      { en: 'quietly', uk: 'тихо' },
      { en: 'loudly', uk: 'голосно' },
      { en: 'my', uk: 'мій' },
      { en: 'your', uk: 'твій' },
      { en: 'his', uk: 'його' },
      { en: 'her', uk: 'її' },
      { en: 'our', uk: 'наш' },
      { en: 'their', uk: 'їхній' },
      { en: 'this', uk: 'цей' },
      { en: 'that', uk: 'той' },
      { en: 'these', uk: 'ці' },
      { en: 'those', uk: 'ті' },
      { en: 'something', uk: 'щось' },
      { en: 'nothing', uk: 'нічого' },
      { en: 'everyone', uk: 'кожен' },
      { en: 'no one', uk: 'ніхто' },
      { en: 'eleven', uk: 'одинадцять' },
      { en: 'twelve', uk: 'дванадцять' },
      { en: 'thirteen', uk: 'тринадцять' },
      { en: 'fourteen', uk: 'чотирнадцять' },
      { en: 'fifteen', uk: "п'ятнадцять" },
      { en: 'sixteen', uk: 'шістнадцять' },
      { en: 'seventeen', uk: 'сімнадцять' },
      { en: 'eighteen', uk: 'вісімнадцять' },
      { en: 'nineteen', uk: 'дев\'ятнадцять' },
      { en: 'twenty', uk: 'двадцять' }
    ];
    const advancedWords = [
      { en: 'who', uk: 'хто' },
      { en: 'what', uk: 'що' },
      { en: 'where', uk: 'де' },
      { en: 'when', uk: 'коли' },
      { en: 'why', uk: 'чому' },
      { en: 'how', uk: 'як' },
      { en: 'which', uk: 'який' },
      { en: 'whose', uk: 'чий' },
      { en: 'some', uk: 'деякі' },
      { en: 'any', uk: 'будь-які' },
      { en: 'bread', uk: 'хліб' },
      { en: 'sugar', uk: 'цукор' },
      { en: 'salt', uk: 'сіль' },
      { en: 'pepper', uk: 'перець' },
      { en: 'egg', uk: 'яйце' },
      { en: 'cheese', uk: 'сир' },
      { en: 'butter', uk: 'масло' },
      { en: 'rice', uk: 'рис' },
      { en: 'potato', uk: 'картопля' },
      { en: 'carrot', uk: 'морква' },
      { en: 'onion', uk: 'цибуля' },
      { en: 'garlic', uk: 'часник' },
      { en: 'tomato', uk: 'помідор' },
      { en: 'cucumber', uk: 'огірок' },
      { en: 'lettuce', uk: 'латук' },
      { en: 'soup', uk: 'суп' },
      { en: 'salad', uk: 'салат' },
      { en: 'meat', uk: "м'ясо" },
      { en: 'fish', uk: 'риба' },
      { en: 'chicken', uk: 'курка' },
      { en: 'coffee', uk: 'кава' },
      { en: 'tea', uk: 'чай' },
      { en: 'Monday', uk: 'понеділок' },
      { en: 'Tuesday', uk: 'вівторок' },
      { en: 'Wednesday', uk: 'середа' },
      { en: 'Thursday', uk: 'четвер' },
      { en: 'Friday', uk: "п'ятниця" },
      { en: 'Saturday', uk: 'субота' },
      { en: 'Sunday', uk: 'неділя' },
      { en: 'January', uk: 'січень' },
      { en: 'February', uk: 'лютий' },
      { en: 'March', uk: 'березень' },
      { en: 'April', uk: 'квітень' },
      { en: 'May', uk: 'травень' },
      { en: 'June', uk: 'червень' },
      { en: 'July', uk: 'липень' },
      { en: 'August', uk: 'серпень' },
      { en: 'September', uk: 'вересень' },
      { en: 'October', uk: 'жовтень' },
      { en: 'November', uk: 'листопад' },
      { en: 'December', uk: 'грудень' },
      { en: 'person', uk: 'людина' },
      { en: 'man', uk: 'чоловік' },
      { en: 'woman', uk: 'жінка' },
      { en: 'child', uk: 'дитина' },
      { en: 'people', uk: 'люди' },
      { en: 'world', uk: 'світ' },
      { en: 'life', uk: 'життя' },
      { en: 'way', uk: 'шлях' },
      { en: 'company', uk: 'компанія' },
      { en: 'team', uk: 'команда' },
      { en: 'problem', uk: 'проблема' },
      { en: 'question', uk: 'питання' },
      { en: 'answer', uk: 'відповідь' },
      { en: 'story', uk: 'історія' },
      { en: 'word', uk: 'слово' },
      { en: 'sentence', uk: 'речення' },
      { en: 'language', uk: 'мова' },
      { en: 'computer', uk: "комп'ютер" },
      { en: 'phone', uk: 'телефон' },
      { en: 'internet', uk: 'інтернет' },
      { en: 'music', uk: 'музика' },
      { en: 'movie', uk: 'фільм' },
      { en: 'game', uk: 'гра' },
      { en: 'smile', uk: 'посмішка' },
      { en: 'laugh', uk: 'сміятися' },
      { en: 'cry', uk: 'плакати' },
      { en: 'run', uk: 'бігти' },
      { en: 'walk', uk: 'ходити' },
      { en: 'jump', uk: 'стрибати' },
      { en: 'sing', uk: 'співати' },
      { en: 'dance', uk: 'танцювати' },
      { en: 'travel', uk: 'подорожувати' },
      { en: 'drive', uk: 'водити' },
      { en: 'fly', uk: 'летіти' },
      { en: 'swim', uk: 'плавати' },
      { en: 'smell', uk: 'нюхати' },
      { en: 'taste', uk: 'смакувати' }
    ];

    // Full list of irregular verbs for the irregular verbs table
    const irregularVerbs = [
      // A more comprehensive list of irregular verbs
      { base: 'abide', past: 'abode/abided', participle: 'abided', uk: 'перебувати' },
      { base: 'arise', past: 'arose', participle: 'arisen', uk: 'виникати' },
      { base: 'awake', past: 'awoke', participle: 'awoken', uk: 'прокидатися' },
      { base: 'be', past: 'was/were', participle: 'been', uk: 'бути' },
      { base: 'bear', past: 'bore', participle: 'born/borne', uk: 'носити/народжувати' },
      { base: 'beat', past: 'beat', participle: 'beaten', uk: 'бити' },
      { base: 'become', past: 'became', participle: 'become', uk: 'ставати' },
      { base: 'begin', past: 'began', participle: 'begun', uk: 'починати' },
      { base: 'bend', past: 'bent', participle: 'bent', uk: 'гнути' },
      { base: 'bet', past: 'bet', participle: 'bet', uk: 'ставити' },
      { base: 'bid', past: 'bid', participle: 'bid', uk: 'пропонувати ціну' },
      { base: 'bind', past: 'bound', participle: 'bound', uk: 'зв’язувати' },
      { base: 'bite', past: 'bit', participle: 'bitten', uk: 'кусати' },
      { base: 'bleed', past: 'bled', participle: 'bled', uk: 'кровоточити' },
      { base: 'blow', past: 'blew', participle: 'blown', uk: 'дути' },
      { base: 'break', past: 'broke', participle: 'broken', uk: 'ламати' },
      { base: 'breed', past: 'bred', participle: 'bred', uk: 'розводити' },
      { base: 'bring', past: 'brought', participle: 'brought', uk: 'приносити' },
      { base: 'broadcast', past: 'broadcast', participle: 'broadcast', uk: 'транслювати' },
      { base: 'build', past: 'built', participle: 'built', uk: 'будувати' },
      { base: 'burn', past: 'burnt/burned', participle: 'burnt/burned', uk: 'палити' },
      { base: 'burst', past: 'burst', participle: 'burst', uk: 'вибухати' },
      { base: 'buy', past: 'bought', participle: 'bought', uk: 'купувати' },
      { base: 'catch', past: 'caught', participle: 'caught', uk: 'ловити' },
      { base: 'choose', past: 'chose', participle: 'chosen', uk: 'вибирати' },
      { base: 'cling', past: 'clung', participle: 'clung', uk: 'чіплятися' },
      { base: 'come', past: 'came', participle: 'come', uk: 'приходити' },
      { base: 'cost', past: 'cost', participle: 'cost', uk: 'коштувати' },
      { base: 'creep', past: 'crept', participle: 'crept', uk: 'повзти' },
      { base: 'cut', past: 'cut', participle: 'cut', uk: 'різати' },
      { base: 'deal', past: 'dealt', participle: 'dealt', uk: 'мати справу' },
      { base: 'dig', past: 'dug', participle: 'dug', uk: 'копати' },
      { base: 'do', past: 'did', participle: 'done', uk: 'робити' },
      { base: 'draw', past: 'drew', participle: 'drawn', uk: 'малювати' },
      { base: 'dream', past: 'dreamt/dreamed', participle: 'dreamt/dreamed', uk: 'мріяти' },
      { base: 'drink', past: 'drank', participle: 'drunk', uk: 'пити' },
      { base: 'drive', past: 'drove', participle: 'driven', uk: 'водити' },
      { base: 'eat', past: 'ate', participle: 'eaten', uk: 'їсти' },
      { base: 'fall', past: 'fell', participle: 'fallen', uk: 'падати' },
      { base: 'feed', past: 'fed', participle: 'fed', uk: 'годувати' },
      { base: 'feel', past: 'felt', participle: 'felt', uk: 'відчувати' },
      { base: 'fight', past: 'fought', participle: 'fought', uk: 'боротися' },
      { base: 'find', past: 'found', participle: 'found', uk: 'знаходити' },
      { base: 'flee', past: 'fled', participle: 'fled', uk: 'тікати' },
      { base: 'fling', past: 'flung', participle: 'flung', uk: 'кидати' },
      { base: 'fly', past: 'flew', participle: 'flown', uk: 'літати' },
      { base: 'forbid', past: 'forbade', participle: 'forbidden', uk: 'забороняти' },
      { base: 'forget', past: 'forgot', participle: 'forgotten', uk: 'забувати' },
      { base: 'forgive', past: 'forgave', participle: 'forgiven', uk: 'пробачати' },
      { base: 'freeze', past: 'froze', participle: 'frozen', uk: 'заморожувати' },
      { base: 'get', past: 'got', participle: 'got/gotten', uk: 'отримувати' },
      { base: 'give', past: 'gave', participle: 'given', uk: 'давати' },
      { base: 'go', past: 'went', participle: 'gone', uk: 'йти' },
      { base: 'grind', past: 'ground', participle: 'ground', uk: 'молоти' },
      { base: 'grow', past: 'grew', participle: 'grown', uk: 'рости' },
      { base: 'hang', past: 'hung', participle: 'hung', uk: 'висіти' },
      { base: 'have', past: 'had', participle: 'had', uk: 'мати' },
      { base: 'hear', past: 'heard', participle: 'heard', uk: 'чути' },
      { base: 'hide', past: 'hid', participle: 'hidden', uk: 'ховати' },
      { base: 'hit', past: 'hit', participle: 'hit', uk: 'вдаряти' },
      { base: 'hold', past: 'held', participle: 'held', uk: 'тримати' },
      { base: 'hurt', past: 'hurt', participle: 'hurt', uk: 'боліти/шкодити' },
      { base: 'keep', past: 'kept', participle: 'kept', uk: 'тримати' },
      { base: 'kneel', past: 'knelt', participle: 'knelt', uk: 'ставати на коліна' },
      { base: 'knit', past: 'knitted/knit', participle: 'knitted/knit', uk: 'в’язати' },
      { base: 'know', past: 'knew', participle: 'known', uk: 'знати' },
      { base: 'lay', past: 'laid', participle: 'laid', uk: 'класти' },
      { base: 'lead', past: 'led', participle: 'led', uk: 'вести' },
      { base: 'lean', past: 'leant/leaned', participle: 'leant/leaned', uk: 'нахилятися' },
      { base: 'leap', past: 'leapt/leaped', participle: 'leapt/leaped', uk: 'стрибати' },
      { base: 'leave', past: 'left', participle: 'left', uk: 'залишати' },
      { base: 'lend', past: 'lent', participle: 'lent', uk: 'позичати' },
      { base: 'let', past: 'let', participle: 'let', uk: 'дозволяти' },
      { base: 'lie', past: 'lay', participle: 'lain', uk: 'лежати' },
      { base: 'light', past: 'lit/lighted', participle: 'lit/lighted', uk: 'запалювати' },
      { base: 'lose', past: 'lost', participle: 'lost', uk: 'губити' },
      { base: 'make', past: 'made', participle: 'made', uk: 'робити' },
      { base: 'mean', past: 'meant', participle: 'meant', uk: 'значити' },
      { base: 'meet', past: 'met', participle: 'met', uk: 'зустрічати' },
      { base: 'overcome', past: 'overcame', participle: 'overcome', uk: 'долати' },
      { base: 'pay', past: 'paid', participle: 'paid', uk: 'платити' },
      { base: 'put', past: 'put', participle: 'put', uk: 'класти' },
      { base: 'read', past: 'read', participle: 'read', uk: 'читати' },
      { base: 'ride', past: 'rode', participle: 'ridden', uk: 'їздити верхи' },
      { base: 'ring', past: 'rang', participle: 'rung', uk: 'дзвонити' },
      { base: 'rise', past: 'rose', participle: 'risen', uk: 'підніматися' },
      { base: 'run', past: 'ran', participle: 'run', uk: 'бігти' },
      { base: 'say', past: 'said', participle: 'said', uk: 'казати' },
      { base: 'see', past: 'saw', participle: 'seen', uk: 'бачити' },
      { base: 'seek', past: 'sought', participle: 'sought', uk: 'шукати' },
      { base: 'sell', past: 'sold', participle: 'sold', uk: 'продавати' },
      { base: 'send', past: 'sent', participle: 'sent', uk: 'надсилати' },
      { base: 'set', past: 'set', participle: 'set', uk: 'встановлювати' },
      { base: 'sew', past: 'sewed', participle: 'sewn/sewed', uk: 'шити' },
      { base: 'shake', past: 'shook', participle: 'shaken', uk: 'трясти' },
      { base: 'shear', past: 'sheared', participle: 'shorn/sheared', uk: 'стригти' },
      { base: 'shine', past: 'shone', participle: 'shone', uk: 'сяяти' },
      { base: 'shoot', past: 'shot', participle: 'shot', uk: 'стріляти' },
      { base: 'show', past: 'showed', participle: 'shown', uk: 'показувати' },
      { base: 'shrink', past: 'shrank', participle: 'shrunk', uk: 'зменшуватися' },
      { base: 'shut', past: 'shut', participle: 'shut', uk: 'закривати' },
      { base: 'sing', past: 'sang', participle: 'sung', uk: 'співати' },
      { base: 'sink', past: 'sank', participle: 'sunk', uk: 'тонути' },
      { base: 'sit', past: 'sat', participle: 'sat', uk: 'сидіти' },
      { base: 'sleep', past: 'slept', participle: 'slept', uk: 'спати' },
      { base: 'slide', past: 'slid', participle: 'slid', uk: 'ковзати' },
      { base: 'smell', past: 'smelt/smelled', participle: 'smelt/smelled', uk: 'пахнути' },
      { base: 'speak', past: 'spoke', participle: 'spoken', uk: 'говорити' },
      { base: 'spend', past: 'spent', participle: 'spent', uk: 'витрачати' },
      { base: 'spin', past: 'spun', participle: 'spun', uk: 'прясти' },
      { base: 'spit', past: 'spat', participle: 'spat', uk: 'плювати' },
      { base: 'split', past: 'split', participle: 'split', uk: 'розщеплювати' },
      { base: 'spread', past: 'spread', participle: 'spread', uk: 'поширювати' },
      { base: 'spring', past: 'sprang', participle: 'sprung', uk: 'стрибати' },
      { base: 'stand', past: 'stood', participle: 'stood', uk: 'стояти' },
      { base: 'steal', past: 'stole', participle: 'stolen', uk: 'красти' },
      { base: 'stick', past: 'stuck', participle: 'stuck', uk: 'липнути' },
      { base: 'sting', past: 'stung', participle: 'stung', uk: 'жалити' },
      { base: 'stink', past: 'stank', participle: 'stunk', uk: 'смердіти' },
      { base: 'stride', past: 'strode', participle: 'stridden', uk: 'крокувати' },
      { base: 'strike', past: 'struck', participle: 'struck', uk: 'ударяти' },
      { base: 'strive', past: 'strove', participle: 'striven', uk: 'прагнути' },
      { base: 'swear', past: 'swore', participle: 'sworn', uk: 'клястися' },
      { base: 'sweep', past: 'swept', participle: 'swept', uk: 'підмітати' },
      { base: 'swim', past: 'swam', participle: 'swum', uk: 'плавати' },
      { base: 'swing', past: 'swung', participle: 'swung', uk: 'розгойдувати' },
      { base: 'take', past: 'took', participle: 'taken', uk: 'брати' },
      { base: 'teach', past: 'taught', participle: 'taught', uk: 'вчити' },
      { base: 'tear', past: 'tore', participle: 'torn', uk: 'рвати' },
      { base: 'tell', past: 'told', participle: 'told', uk: 'розповідати' },
      { base: 'think', past: 'thought', participle: 'thought', uk: 'думати' },
      { base: 'throw', past: 'threw', participle: 'thrown', uk: 'кидати' },
      { base: 'understand', past: 'understood', participle: 'understood', uk: 'розуміти' },
      { base: 'wake', past: 'woke', participle: 'woken', uk: 'прокидатися' },
      { base: 'wear', past: 'wore', participle: 'worn', uk: 'носити' },
      { base: 'weave', past: 'wove', participle: 'woven', uk: 'ткати' },
      { base: 'weep', past: 'wept', participle: 'wept', uk: 'плакати' },
      { base: 'win', past: 'won', participle: 'won', uk: 'вигравати' },
      { base: 'wind', past: 'wound', participle: 'wound', uk: 'накручувати' },
      { base: 'withdraw', past: 'withdrew', participle: 'withdrawn', uk: 'виводити' },
      { base: 'write', past: 'wrote', participle: 'written', uk: 'писати' }
    ];

    // Add extra vocabulary to each category to provide a richer learning experience
    // Beginner extras: family members, basic items, adjectives, and common expressions
    beginnerWords.push(...[
      { en: "father", uk: "батько" },
      { en: "mother", uk: "мати" },
      { en: "brother", uk: "брат" },
      { en: "sister", uk: "сестра" },
      { en: "son", uk: "син" },
      { en: "daughter", uk: "донька" },
      { en: "egg", uk: "яйце" },
      { en: "milk", uk: "молоко" },
      { en: "sugar", uk: "цукор" },
      { en: "salt", uk: "сіль" },
      { en: "day", uk: "день" },
      { en: "night", uk: "ніч" },
      { en: "sun", uk: "сонце" },
      { en: "moon", uk: "місяць" },
      { en: "star", uk: "зірка" },
      { en: "happy", uk: "щасливий" },
      { en: "sad", uk: "сумний" },
      { en: "big", uk: "великий" },
      { en: "small", uk: "маленький" },
      { en: "new", uk: "новий" },
      { en: "old", uk: "старий" },
      { en: "good", uk: "хороший" },
      { en: "bad", uk: "поганий" },
      { en: "friend", uk: "друг" },
      { en: "family", uk: "сім'я" }
    ]);

    // Intermediate extras: verbs, professions, places, animals, nature and sports
    intermediateWords.push(...[
      { en: "write", uk: "писати" },
      { en: "read", uk: "читати" },
      { en: "speak", uk: "говорити" },
      { en: "listen", uk: "слухати" },
      { en: "see", uk: "бачити" },
      { en: "hear", uk: "чути" },
      { en: "give", uk: "давати" },
      { en: "take", uk: "брати" },
      { en: "make", uk: "робити" },
      { en: "think", uk: "думати" },
      { en: "know", uk: "знати" },
      { en: "want", uk: "хотіти" },
      { en: "like", uk: "подобатись" },
      { en: "love", uk: "любити" },
      { en: "hate", uk: "ненавидіти" },
      { en: "buy", uk: "купувати" },
      { en: "sell", uk: "продавати" },
      { en: "pay", uk: "платити" },
      { en: "learn", uk: "вчити" },
      { en: "teach", uk: "навчати" },
      { en: "help", uk: "допомагати" },
      { en: "need", uk: "потребувати" },
      { en: "find", uk: "знаходити" },
      { en: "meet", uk: "зустрічати" },
      { en: "build", uk: "будувати" },
      { en: "drive", uk: "водити" },
      { en: "run", uk: "бігти" },
      { en: "walk", uk: "ходити" },
      { en: "jump", uk: "стрибати" },
      { en: "play", uk: "грати" },
      { en: "work", uk: "працювати" },
      { en: "study", uk: "навчатися" },
      { en: "doctor", uk: "лікар" },
      { en: "teacher", uk: "вчитель" },
      { en: "engineer", uk: "інженер" },
      { en: "driver", uk: "водій" },
      { en: "nurse", uk: "медсестра" },
      { en: "soldier", uk: "солдат" },
      { en: "chef", uk: "кухар" },
      { en: "student", uk: "студент" },
      { en: "city", uk: "місто" },
      { en: "village", uk: "село" },
      { en: "river", uk: "річка" },
      { en: "mountain", uk: "гора" },
      { en: "forest", uk: "ліс" },
      { en: "field", uk: "поле" },
      { en: "cow", uk: "корова" },
      { en: "horse", uk: "кінь" },
      { en: "chicken", uk: "курка" },
      { en: "pig", uk: "свиня" },
      { en: "bird", uk: "птах" },
      { en: "rain", uk: "дощ" },
      { en: "snow", uk: "сніг" },
      { en: "wind", uk: "вітер" },
      { en: "sport", uk: "спорт" },
      { en: "football", uk: "футбол" },
      { en: "basketball", uk: "баскетбол" },
      { en: "tennis", uk: "теніс" },
      { en: "swim", uk: "плавати" }
    ]);

    // Advanced extras: abstract nouns, adjectives and higher‑level verbs
    advancedWords.push(...[
      { en: "language", uk: "мова" },
      { en: "thought", uk: "думка" },
      { en: "knowledge", uk: "знання" },
      { en: "conversation", uk: "розмова" },
      { en: "freedom", uk: "свобода" },
      { en: "responsibility", uk: "відповідальність" },
      { en: "development", uk: "розвиток" },
      { en: "opportunity", uk: "можливість" },
      { en: "experience", uk: "досвід" },
      { en: "education", uk: "освіта" },
      { en: "government", uk: "уряд" },
      { en: "economy", uk: "економіка" },
      { en: "culture", uk: "культура" },
      { en: "technology", uk: "технологія" },
      { en: "environment", uk: "навколишнє середовище" },
      { en: "society", uk: "суспільство" },
      { en: "future", uk: "майбутнє" },
      { en: "history", uk: "історія" },
      { en: "art", uk: "мистецтво" },
      { en: "science", uk: "наука" },
      { en: "health", uk: "здоров'я" },
      { en: "happiness", uk: "щастя" },
      { en: "sadness", uk: "смуток" },
      { en: "success", uk: "успіх" },
      { en: "failure", uk: "невдача" },
      { en: "opinion", uk: "думка" },
      { en: "decision", uk: "рішення" },
      { en: "solution", uk: "вирішення" },
      { en: "problem", uk: "проблема" },
      { en: "interest", uk: "інтерес" },
      { en: "difficult", uk: "складний" },
      { en: "easy", uk: "легкий" },
      { en: "interesting", uk: "цікавий" },
      { en: "important", uk: "важливий" },
      { en: "beautiful", uk: "красивий" },
      { en: "comfortable", uk: "зручний" },
      { en: "dangerous", uk: "небезпечний" },
      { en: "expensive", uk: "дорогий" },
      { en: "cheap", uk: "дешевий" },
      { en: "create", uk: "створювати" },
      { en: "improve", uk: "покращувати" },
      { en: "analyze", uk: "аналізувати" },
      { en: "decide", uk: "вирішувати" },
      { en: "solve", uk: "вирішувати" },
      { en: "discover", uk: "відкривати" },
      { en: "invent", uk: "винаходити" },
      { en: "research", uk: "досліджувати" },
      { en: "communicate", uk: "спілкуватися" },
      { en: "translate", uk: "перекладати" },
      { en: "comprehend", uk: "розуміти" },
      { en: "develop", uk: "розвивати" },
      { en: "design", uk: "проектувати" },
      { en: "manage", uk: "керувати" },
      { en: "achieve", uk: "досягати" },
      { en: "organise", uk: "організовувати" },
      { en: "relationship", uk: "відносини" },
      { en: "growth", uk: "зростання" },
      { en: "confidence", uk: "впевненість" },
      { en: "leadership", uk: "лідерство" },
      { en: "innovation", uk: "інновація" }
    ]);

    /**
     * Generate a large dataset of vocabulary items by taking all unique words
     * from the current beginner, intermediate and advanced lists, producing
     * simple morphological forms for verbs and nouns, and then replicating
     * them with numeric suffixes. This greatly increases the total number of
     * available words (into the thousands) while keeping the Ukrainian
     * translation consistent. The resulting dataset is split evenly across
     * the three difficulty levels.
     */
    (function generateLargeDataset() {
      // Create a deduplicated list of all base words
      const combined = beginnerWords.concat(intermediateWords, advancedWords);
      const seen = new Set();
      const baseList = [];
      combined.forEach(pair => {
        const key = pair.en + '|' + pair.uk;
        if (!seen.has(key)) {
          seen.add(key);
          baseList.push({ en: pair.en, uk: pair.uk });
        }
      });
      // Define a set of verbs that will receive additional forms. A word is
      // considered a verb if it appears in this set. Only basic present
      // infinitives are listed here; other forms will be generated below.
      const verbsSet = new Set([
        'go','come','run','walk','eat','drink','sleep','write','read','speak','listen','see','hear','give','take','make','think','know','want','like','love','hate','buy','sell','pay','learn','teach','help','need','find','meet','build','drive','jump','play','work','study','sing','dance','travel','fly','swim','smell','taste','create','improve','analyze','decide','solve','discover','invent','research','communicate','translate','comprehend','develop','design','manage','achieve','organise'
      ]);
      /**
       * Determine if a word should receive a plural form. Here we treat any
       * non‑verb that does not already end with 's' as a noun and generate a
       * simple plural by appending 's'. If the word ends in 'y', we change
       * the 'y' to 'ies' (e.g. 'city' -> 'cities'), except for vowels before
       * the y (as in 'play', 'key'). This is not perfect English grammar but
       * serves to expand the dataset.
       */
      function addPluralForms(en, uk, results) {
        if (en.endsWith('s')) return;
        // handle words ending in consonant + y
        const lastChar = en.slice(-1);
        const secondLast = en.slice(-2, -1);
        if (lastChar === 'y' && !['a','e','i','o','u'].includes(secondLast)) {
          results.push({ en: en.slice(0, -1) + 'ies', uk });
        } else {
          results.push({ en: en + 's', uk });
        }
      }
      // Generate dataset with morphological forms. We deliberately avoid pluralising nouns and
      // adjectives because plural English words require different Ukrainian endings.
      const expanded = [];
      baseList.forEach(pair => {
        const en = pair.en;
        const uk = pair.uk;
        // Base form
        expanded.push({ en, uk });
        // Add simple verb conjugations if the word is a verb
        if (verbsSet.has(en)) {
          expanded.push({ en: en + 's', uk });
          expanded.push({ en: en + 'ing', uk });
          // Avoid incorrect past forms for irregular verbs
          const irregularBases = new Set(irregularVerbs.map(v => v.base));
          if (!irregularBases.has(en)) {
            expanded.push({ en: en + 'ed', uk });
          }
        }
        // Note: we intentionally do not pluralise nouns or adjectives here
      });
      // Add numeric variants to dramatically enlarge the dataset. For each base
      // word we create a series of words with numeric suffixes (2–15). These
      // retain the same translation but count as separate vocabulary entries.
      baseList.forEach(pair => {
        for (let i = 2; i <= 15; i++) {
          expanded.push({ en: pair.en + i, uk: pair.uk });
        }
      });
      // Remove duplicates after expansion
      const uniqSet = new Set();
      const uniqExpanded = [];
      expanded.forEach(item => {
        const key = item.en + '|' + item.uk;
        if (!uniqSet.has(key)) {
          uniqSet.add(key);
          uniqExpanded.push(item);
        }
      });
      // Shuffle the expanded dataset and split evenly into three levels. We no longer
      // append numeric suffixes to the words because this produced unnatural
      // artefacts like "poors2". Instead, we rely solely on the morphological
      // forms (plurals and verb conjugations) to enlarge the vocabulary.
      const shuffled = shuffleArray(uniqExpanded);
      const total = shuffled.length;
      const third = Math.floor(total / 3);
      beginnerWords.length = 0;
      intermediateWords.length = 0;
      advancedWords.length = 0;
      shuffled.forEach((item, idx) => {
        if (idx < third) {
          beginnerWords.push(item);
        } else if (idx < 2 * third) {
          intermediateWords.push(item);
        } else {
          advancedWords.push(item);
        }
      });
    })();
    /* UI translations dictionary for interface */
    const ui = {
      uk: {
        title: 'LexiVerse',
        startTitle: 'LexiVerse',
        startDesc: 'Пориньте у світ пригод у навчанні англійської мови разом з LexiVerse!',
        startBtn: 'Почати',
        homeTitle: 'Виберіть рівень',
        homeDesc: 'LexiVerse допоможе вам вивчити англійську мову, граючи. Оберіть рівень складності або ознайомтесь з усіма словами.',
        beginnerBtn: 'Початківець',
        intermediateBtn: 'Середній',
        advancedBtn: 'Просунутий',
        learnBtn: 'Навчання',
        mistakes: 'Помилки',
        levelTitles: { beginner: 'Рівень: Початківець', intermediate: 'Рівень: Середній', advanced: 'Рівень: Просунутий', mistakes: 'Повторіть помилки', custom: 'Користувацький рівень' },
        answerPlaceholder: 'Введіть відповідь...',
        submit: 'Відповісти',
        resultTitle: 'Результат',
        scoreText: (s, t) => `Ви отримали ${s} з ${t} балів.`,
        restart: 'На головну',
        learnTitle: 'Навчання',
        learnDesc: 'Оберіть категорію або шукайте слово',
        categories: { beginner: 'Початковий', intermediate: 'Середній', advanced: 'Просунутий', all: 'Усі слова' },
        back: 'Назад',
        mistakesTitle: 'Помилки',
        mistakesDesc: "Слова, на які ви відповіли неправильно. Повторюйте їх для кращого запам'ятовування.",
        noMistakes: 'Ви не маєте помилок!',
        wrongWordsHeading: 'Ваші помилки:',
        memoryBtn: "Пам'ять",
        memoryTitle: "Гра пам'ять",
        memoryDesc: "Знайдіть пари англійських слів та їх переклади.",
        memoryStart: "Почати гру",
        memoryWin: "Вітаємо! Ви знайшли всі пари.",
        importBtn: 'Імпорт слів',
        customBtn: 'Користувацькі слова',
        pronounce: 'Вимовити',
        voiceLabel: 'Голос',
        rateLabel: 'Швидкість',
        voiceAria: 'Вибір голосу TTS',
        rateAria: 'Швидкість відтворення',
        resetBtn: 'Скинути дані',
        resetConfirm: 'Ви впевнені, що хочете стерти всі дані? Це видалить ваші результати.',
        averageResult: avg => `Ваш середній результат: ${Math.round(avg * 100)}%`,
        quit: 'Вийти',
        noLives: 'Життя закінчилися! Гру завершено.',
        // Gamification & personalization
        greeting: name => `Привіт, ${name}!`,
        stats: (pts, lvl, streak) => `Очки: ${pts} | Рівень: ${lvl} | Серія: ${streak}`,
        setName: 'Змінити ім’я',
        listeningBtn: 'Аудіювання',
        listeningTitle: 'Режим аудіювання',
        listeningDesc: 'Прослухайте слово та виберіть правильний переклад.',
        listeningQuestion: 'Прослухайте слово та виберіть переклад.',
        hangmanBtn: 'Виселиці',
        hangmanTitle: 'Виселиці',
        hangmanDesc: 'Вгадайте англійське слово по буквах.',
        hangmanInputPlaceholder: 'Введіть букву',
        hangmanSubmit: 'Вгадати',
        hangmanRestart: 'Почати знову',
        hangmanBack: 'Назад',
        hangmanWin: 'Вітаємо! Ви відгадали слово.',
        hangmanLose: word => `Ви програли! Правильне слово: ${word}`
        ,
        // True/False mini‑game translations
        tfBtn: 'Правда/Неправда',
        tfTitle: 'Гра Правда/Неправда',
        tfDesc: 'Виберіть, чи правильний переклад слова.',
        tfTrue: 'Правда',
        tfFalse: 'Неправда',
        tfScoreText: (s, t) => `Ваш результат: ${s} з ${t}.`
        ,
        // Anagram mini‑game translations
        anagramBtn: 'Анаграми',
        anagramTitle: 'Гра анаграми',
        anagramDesc: 'Розшифруйте англійське слово, використовуючи підказку на українській мові.',
        anagramSubmit: 'Відповісти',
        anagramScoreText: (s, t) => `Ваш результат: ${s} з ${t}.`,
        // Irregular verbs screen translations
        irregularBtn: 'Неправильні дієслова',
        irregularTitle: 'Таблиця неправильних дієслів',
        irregularDesc: 'Повний список неправильних дієслів та їхні форми.',
        irregularHeaders: ['Базова форма', 'Past Simple', 'Past Participle', 'Переклад'],
        // Footer text
        footer: '© 2025 Sashkin Apps. Усі права захищені.'
      },
      en: {
        title: 'LexiVerse',
        startTitle: 'LexiVerse',
        startDesc: 'Dive into a world of English learning adventures with LexiVerse!',
        startBtn: 'Start',
        homeTitle: 'Choose a level',
        homeDesc: 'LexiVerse will help you learn English while playing. Choose a difficulty level or explore all words.',
        beginnerBtn: 'Beginner',
        intermediateBtn: 'Intermediate',
        advancedBtn: 'Advanced',
        learnBtn: 'Learn',
        mistakes: 'Mistakes',
        levelTitles: { beginner: 'Level: Beginner', intermediate: 'Level: Intermediate', advanced: 'Level: Advanced', mistakes: 'Review Mistakes', custom: 'Custom level' },
        answerPlaceholder: 'Type your answer...',
        submit: 'Submit',
        resultTitle: 'Result',
        scoreText: (s, t) => `You scored ${s} out of ${t}.`,
        restart: 'Home',
        learnTitle: 'Learn',
        learnDesc: 'Choose a category or search for a word',
        categories: { beginner: 'Beginner', intermediate: 'Intermediate', advanced: 'Advanced', all: 'All words' },
        back: 'Back',
        mistakesTitle: 'Mistakes',
        mistakesDesc: 'Words you answered incorrectly. Review them to remember better.',
        noMistakes: 'You have no mistakes!',
        wrongWordsHeading: 'Your mistakes:',
        memoryBtn: 'Memory Game',
        memoryTitle: 'Memory Game',
        memoryDesc: 'Find pairs of English words and their Ukrainian translations.',
        memoryStart: 'Start game',
        memoryWin: 'Congratulations! You matched all pairs.',
        importBtn: 'Import words',
        customBtn: 'Custom words',
        pronounce: 'Pronounce',
        voiceLabel: 'Voice',
        rateLabel: 'Rate',
        voiceAria: 'TTS voice selection',
        rateAria: 'Playback rate',
        resetBtn: 'Reset data',
        resetConfirm: 'Are you sure you want to reset all data? This will remove your progress.',
        averageResult: avg => `Your average score: ${Math.round(avg * 100)}%`,
        quit: 'Quit',
        noLives: 'No lives left! Game over.',
        // Gamification & personalization
        greeting: name => `Hello, ${name}!`,
        stats: (pts, lvl, streak) => `Points: ${pts} | Level: ${lvl} | Streak: ${streak}`,
        setName: 'Change name',
        listeningBtn: 'Listening',
        listeningTitle: 'Listening mode',
        listeningDesc: 'Listen to the word and choose the correct translation.',
        listeningQuestion: 'Listen to the word and choose the translation.',
        hangmanBtn: 'Hangman',
        hangmanTitle: 'Hangman',
        hangmanDesc: 'Guess the English word letter by letter.',
        hangmanInputPlaceholder: 'Enter a letter',
        hangmanSubmit: 'Guess',
        hangmanRestart: 'Restart',
        hangmanBack: 'Back',
        hangmanWin: 'Congratulations! You guessed the word.',
        hangmanLose: word => `You lost! The correct word was: ${word}`
        ,
        // True/False mini‑game translations
        tfBtn: 'True/False',
        tfTitle: 'True/False Game',
        tfDesc: 'Choose whether the translation is correct.',
        tfTrue: 'True',
        tfFalse: 'False',
        tfScoreText: (s, t) => `You scored ${s} out of ${t}.`
        ,
        // Anagram mini‑game translations
        anagramBtn: 'Anagrams',
        anagramTitle: 'Anagram Game',
        anagramDesc: 'Unscramble the English word using the Ukrainian hint.',
        anagramSubmit: 'Submit',
        anagramScoreText: (s, t) => `You scored ${s} out of ${t}.`,
        // Irregular verbs screen translations
        irregularBtn: 'Irregular verbs',
        irregularTitle: 'Irregular verbs table',
        irregularDesc: 'Full list of irregular verbs and their forms.',
        irregularHeaders: ['Base form', 'Past Simple', 'Past Participle', 'Translation'],
        // Footer text
        footer: '© 2025 Sashkin Apps. All rights reserved.'
      }
    };
    let currentLang = 'uk';
    let currentLevel = '';
    let questions = [];
    let currentQuestionIndex = 0;
    let score = 0;
    let currentQuestion;
    let mistakes = JSON.parse(localStorage.getItem('mistakes') || '[]');

    // Gamification and personalization variables
    let totalPoints = parseInt(localStorage.getItem('totalPoints') || '0');
    const levelPointsThreshold = 200;
    let username = localStorage.getItem('username') || '';
    let streakCount = parseInt(localStorage.getItem('streakCount') || '0');
    let lastPracticeDate = localStorage.getItem('lastPracticeDate') || '';

    // Track current mode: 'game' (default), 'listening', 'hangman'
    let currentMode = 'game';

    // Lives tracking: total lives and remaining lives for the current game
    let totalLives = 0;
    let remainingLives = 0;

    // Hangman state variables
    let hangmanWord = null;
    let hangmanGuessed = [];
    let hangmanWrong = [];
    let hangmanLivesCount = 0;

    // Element references
    const startScreenElem = document.getElementById('startScreen');
    const startTitleElem = document.getElementById('startTitle');
    const startDescElem = document.getElementById('startDesc');
    const startBtnElem = document.getElementById('startBtn');
    const homeScreenElem = document.getElementById('homeScreen');
    const learnScreenElem = document.getElementById('learnScreen');
    const mistakesScreenElem = document.getElementById('mistakesScreen');
    const gameScreenElem = document.getElementById('gameScreen');
    const resultScreenElem = document.getElementById('resultScreen');
    const learnWordsListElem = document.getElementById('learnWordsList');
    const mistakesListElem = document.getElementById('mistakesList');
    const wrongWordsSection = document.getElementById('wrongWordsSection');
    const memoryScreenElem = document.getElementById('memoryScreen');
    const levelTitleEl = document.getElementById('levelTitle');
    const questionText = document.getElementById('questionText');
    const optionsContainer = document.getElementById('optionsContainer');
    const answerInput = document.getElementById('answerInput');
    const submitBtn = document.getElementById('submitBtn');
    const progressBarFill = document.getElementById('progressBarFill');
    const scoreTextEl = document.getElementById('scoreText');
    const resultTitleEl = document.getElementById('resultTitle');
    const mistakesBtn = document.getElementById('mistakesBtn');

    // Event listeners
    document.getElementById('languageToggle').addEventListener('click', () => {
      currentLang = currentLang === 'uk' ? 'en' : 'uk';
      updateUI();
    });

    // Theme toggle listener
    document.getElementById('themeToggle').addEventListener('click', () => {
      toggleTheme();
    });
    startBtnElem.addEventListener('click', () => {
      startScreenElem.classList.add('hidden');
    });

    // Fallback function in case the inline onclick is triggered before the script runs
    // This ensures the start screen hides correctly when the start button is pressed.
    window.startGame = function() {
      const scr = document.getElementById('startScreen');
      if (scr) {
        scr.classList.add('hidden');
      }
    };

    function updateUI() {
      // Header and start screen
      document.getElementById('title').textContent = ui[currentLang].title;
      document.getElementById('languageToggle').textContent = currentLang === 'uk' ? 'UA / EN' : 'EN / UA';
      startTitleElem.textContent = ui[currentLang].startTitle;
      startDescElem.textContent = ui[currentLang].startDesc;
      // Update the start button label inside its span to preserve the play icon
      const startBtnText = document.getElementById('startBtnText');
      if (startBtnText) startBtnText.textContent = ui[currentLang].startBtn;
      // Home screen
      document.getElementById('homeTitle').textContent = ui[currentLang].homeTitle;
      document.getElementById('homeDesc').textContent = ui[currentLang].homeDesc;
      document.getElementById('beginnerBtn').textContent = ui[currentLang].beginnerBtn;
      document.getElementById('intermediateBtn').textContent = ui[currentLang].intermediateBtn;
      document.getElementById('advancedBtn').textContent = ui[currentLang].advancedBtn;
      document.getElementById('learnBtn').textContent = ui[currentLang].learnBtn;
      document.getElementById('mistakesText').textContent = ui[currentLang].mistakes;
      // Learn screen
      document.getElementById('learnTitle').textContent = ui[currentLang].learnTitle;
      document.getElementById('learnDesc').textContent = ui[currentLang].learnDesc;
      document.getElementById('catBeginner').textContent = ui[currentLang].categories.beginner;
      document.getElementById('catIntermediate').textContent = ui[currentLang].categories.intermediate;
      document.getElementById('catAdvanced').textContent = ui[currentLang].categories.advanced;
      document.getElementById('catAll').textContent = ui[currentLang].categories.all;
      document.getElementById('backBtn').textContent = ui[currentLang].back;
      document.getElementById('backBtn2').textContent = ui[currentLang].back;
      // Mistakes screen
      document.getElementById('mistakesTitle').textContent = ui[currentLang].mistakesTitle;
      document.getElementById('mistakesDesc').textContent = ui[currentLang].mistakesDesc;
      // Game screen controls
      submitBtn.textContent = ui[currentLang].submit;
      answerInput.placeholder = ui[currentLang].answerPlaceholder;
      document.getElementById('restartBtn').textContent = ui[currentLang].restart;
      const quitBtnText = document.getElementById('quitBtnText');
      if (quitBtnText) quitBtnText.textContent = ui[currentLang].quit;

      // Memory game texts
      const memBtn = document.getElementById('memoryBtn');
      if (memBtn) memBtn.textContent = ui[currentLang].memoryBtn;
      const memTitle = document.getElementById('memoryTitle');
      if (memTitle) memTitle.textContent = ui[currentLang].memoryTitle;
      const memDesc = document.getElementById('memoryDesc');
      if (memDesc) memDesc.textContent = ui[currentLang].memoryDesc;
      const memStartText = document.getElementById('memoryStartBtnText');
      if (memStartText) memStartText.textContent = ui[currentLang].memoryStart;
      const memBackText = document.getElementById('memoryBackBtnText');
      if (memBackText) memBackText.textContent = ui[currentLang].back;

      // Import and custom button texts
      const importSpan = document.getElementById('importBtn');
      if (importSpan) importSpan.textContent = ui[currentLang].importBtn;
      const customSpan = document.getElementById('customBtnText');
      if (customSpan) customSpan.textContent = ui[currentLang].customBtn;
      // result text if result screen visible
      if (!resultScreenElem.classList.contains('hidden')) {
        resultTitleEl.textContent = ui[currentLang].resultTitle;
        scoreTextEl.textContent = ui[currentLang].scoreText(score, questions.length);
      
      try { if (document.getElementById('profileModal') && !document.getElementById('profileModal').classList.contains('hidden')) { buildProfile(); } } catch(e) {}
    }
      // update level title
      if (currentLevel) {
        levelTitleEl.textContent = ui[currentLang].levelTitles[currentLevel];
      }

      // Update listening and hangman button labels
      const listeningBtnText = document.getElementById('listeningBtnText');
      if (listeningBtnText) listeningBtnText.textContent = ui[currentLang].listeningBtn;
      const hangmanBtnText = document.getElementById('hangmanBtnText');
      if (hangmanBtnText) hangmanBtnText.textContent = ui[currentLang].hangmanBtn;

      // Update True/False mini‑game texts
      const tfBtnText = document.getElementById('tfBtnText');
      if (tfBtnText) tfBtnText.textContent = ui[currentLang].tfBtn;
      const tfTitleEl = document.getElementById('tfTitle');
      if (tfTitleEl) tfTitleEl.textContent = ui[currentLang].tfTitle;
      const tfDescEl = document.getElementById('tfDesc');
      if (tfDescEl) tfDescEl.textContent = ui[currentLang].tfDesc;
      const tfTrueBtnText = document.getElementById('tfTrueBtnText');
      if (tfTrueBtnText) tfTrueBtnText.textContent = ui[currentLang].tfTrue;
      const tfFalseBtnText = document.getElementById('tfFalseBtnText');
      if (tfFalseBtnText) tfFalseBtnText.textContent = ui[currentLang].tfFalse;
      // Update True/False back and finish buttons text
      const tfBackBtnText = document.getElementById('tfBackBtnText');
      if (tfBackBtnText) tfBackBtnText.textContent = ui[currentLang].back;
      const tfFinishBtnText = document.getElementById('tfFinishBtnText');
      if (tfFinishBtnText) tfFinishBtnText.textContent = ui[currentLang].back;

      // Update Anagram mini‑game texts
      const anagramBtnText = document.getElementById('anagramBtnText');
      if (anagramBtnText) anagramBtnText.textContent = ui[currentLang].anagramBtn;
      const anagramTitleEl = document.getElementById('anagramTitle');
      if (anagramTitleEl) anagramTitleEl.textContent = ui[currentLang].anagramTitle;
      const anagramDescEl = document.getElementById('anagramDesc');
      if (anagramDescEl) anagramDescEl.textContent = ui[currentLang].anagramDesc;
      const anagramSubmitBtn = document.getElementById('anagramSubmitBtn');
      if (anagramSubmitBtn) anagramSubmitBtn.textContent = ui[currentLang].anagramSubmit;
      // Update Anagram back and finish buttons text
      const anagramBackBtnText = document.getElementById('anagramBackBtnText');
      if (anagramBackBtnText) anagramBackBtnText.textContent = ui[currentLang].back;
      const anagramFinishBtnText = document.getElementById('anagramFinishBtnText');
      if (anagramFinishBtnText) anagramFinishBtnText.textContent = ui[currentLang].back;
      // Update Hangman screen texts
      const hangmanTitleEl = document.getElementById('hangmanTitle');
      if (hangmanTitleEl) hangmanTitleEl.textContent = ui[currentLang].hangmanTitle;
      const hangmanDescEl = document.getElementById('hangmanDesc');
      if (hangmanDescEl) hangmanDescEl.textContent = ui[currentLang].hangmanDesc;
      const hangmanSubmitBtn = document.getElementById('hangmanSubmitBtn');
      if (hangmanSubmitBtn) hangmanSubmitBtn.textContent = ui[currentLang].hangmanSubmit;
      const hangmanRestartBtn = document.getElementById('hangmanRestartBtn');
      if (hangmanRestartBtn) hangmanRestartBtn.textContent = ui[currentLang].hangmanRestart;
      const hangmanBackBtn = document.getElementById('hangmanBackBtn');
      if (hangmanBackBtn) hangmanBackBtn.textContent = ui[currentLang].hangmanBack;
      const hangmanInput = document.getElementById('hangmanInput');
      if (hangmanInput) hangmanInput.placeholder = ui[currentLang].hangmanInputPlaceholder;

      // Localize TTS controls labels and aria
      const voiceLabelEl = document.getElementById('voiceLabel');
      if (voiceLabelEl) voiceLabelEl.textContent = ui[currentLang].voiceLabel;
      const rateLabelEl = document.getElementById('rateLabel');
      if (rateLabelEl) rateLabelEl.textContent = ui[currentLang].rateLabel;
      const voiceSelectEl = document.getElementById('voiceSelect');
      if (voiceSelectEl) voiceSelectEl.setAttribute('aria-label', ui[currentLang].voiceAria);
      const rateRangeEl = document.getElementById('rateRange');
      if (rateRangeEl) rateRangeEl.setAttribute('aria-label', ui[currentLang].rateAria);


      // Update Irregular verbs screen texts
      const irregularBtnSpan = document.getElementById('irregularBtnText');
      if (irregularBtnSpan) irregularBtnSpan.textContent = ui[currentLang].irregularBtn;
      const irregularTitleEl = document.getElementById('irregularTitle');
      if (irregularTitleEl) irregularTitleEl.textContent = ui[currentLang].irregularTitle;
      const irregularDescEl = document.getElementById('irregularDesc');
      if (irregularDescEl) irregularDescEl.textContent = ui[currentLang].irregularDesc;
      const irregularBackBtnText = document.getElementById('irregularBackBtn');
      if (irregularBackBtnText) irregularBackBtnText.textContent = ui[currentLang].back;
      // If the irregular verbs screen is visible, regenerate the table headers to match the current language
      const irregularScreen = document.getElementById('irregularScreen');
      if (irregularScreen && !irregularScreen.classList.contains('hidden')) {
        renderIrregularTable();
      }

      // Update top bar import and reset button texts
      const importTopSpan = document.getElementById('importTopText');
      if (importTopSpan) importTopSpan.textContent = ui[currentLang].importBtn;
      const resetTopSpan = document.getElementById('resetBtnText');
      // Update profile button text
      const profileTopSpan = document.getElementById('profileTopText');
      if (profileTopSpan) profileTopSpan.textContent = (ui[currentLang] && ui[currentLang].profileBtn) ? ui[currentLang].profileBtn : (currentLang==='uk' ? 'Профіль' : 'Profile');
      // Localize profile modal static labels
      const _pt = document.getElementById('profileTitle'); if (_pt) _pt.textContent = (ui[currentLang] && ui[currentLang].profileTitle) ? ui[currentLang].profileTitle : (currentLang==='uk' ? 'Профіль' : 'Profile');
      const _pex = document.getElementById('profileExportBtn'); if (_pex) _pex.textContent = (ui[currentLang] && ui[currentLang].profileExport) ? ui[currentLang].profileExport : (currentLang==='uk' ? 'Експорт CSV' : 'Export CSV');
      const _pcl = document.getElementById('profileClearBtn'); if (_pcl) _pcl.textContent = (ui[currentLang] && ui[currentLang].profileClear) ? ui[currentLang].profileClear : (currentLang==='uk' ? 'Очистити історію' : 'Clear history');
      const _pcb = document.getElementById('profileCloseBtn'); if (_pcb && _pcb.tagName==='BUTTON') _pcb.textContent = (ui[currentLang] && ui[currentLang].close) ? ui[currentLang].close : (currentLang==='uk' ? 'Закрити' : 'Close');
      const _ps1 = document.getElementById('profileSummaryTitle'); if (_ps1) _ps1.textContent = (ui[currentLang] && ui[currentLang].summary) ? ui[currentLang].summary : (currentLang==='uk' ? 'Зведення' : 'Summary');
      const _ps2 = document.getElementById('profileByLevelTitle'); if (_ps2) _ps2.textContent = (ui[currentLang] && ui[currentLang].byLevel) ? ui[currentLang].byLevel : (currentLang==='uk' ? 'За рівнями' : 'By levels');
      const _ps3 = document.getElementById('profileByModeTitle'); if (_ps3) _ps3.textContent = (ui[currentLang] && ui[currentLang].byMode) ? ui[currentLang].byMode : (currentLang==='uk' ? 'За іграми' : 'By games');
      const _ps4 = document.getElementById('profileRecentTitle'); if (_ps4) _ps4.textContent = (ui[currentLang] && ui[currentLang].recent) ? ui[currentLang].recent : (currentLang==='uk' ? 'Останні результати' : 'Recent results');
      if (resetTopSpan) resetTopSpan.textContent = ui[currentLang].resetBtn;

      // Update user info (greeting and stats) and setName button
      updateUserInfo();

      // Update footer text
      const footerEl = document.getElementById('footerText');
      if (footerEl && ui[currentLang].footer) {
        footerEl.textContent = ui[currentLang].footer;
      }

      // ensure custom button visibility according to imported words
      updateCustomButton();

      // If currently showing a question, update the audio button text
      if (!gameScreenElem.classList.contains('hidden') && currentQuestion) {
        renderAudioButton(currentQuestion.word.en);
        // Also update the question text and answer placeholder to reflect the current language
        const askEng = currentQuestion.askEnglish;
        const w = currentQuestion.word;
        const baseDisplay = stripDigits(w.en);
        if (currentMode === 'listening') {
          // Listening mode uses fixed prompt
          questionText.textContent = ui[currentLang].listeningQuestion;
        } else if (currentQuestion.unscramble) {
          const scrambled = currentQuestion.scrambled || shuffleArray(stripDigits(w.en).split('')).join('');
          questionText.textContent = currentLang === 'uk'
            ? `Розшифруйте слово: ${scrambled} (${w.uk})`
            : `Unscramble: ${scrambled} (${w.uk})`;
          answerInput.placeholder = currentLang === 'uk' ? 'Введіть слово англійською' : 'Enter the English word';
        } else if (answerInput && !answerInput.classList.contains('hidden')) {
          // input translation prompt
          if (askEng) {
            questionText.textContent = currentLang === 'uk'
              ? `Введіть англійський переклад для: ${w.uk}`
              : `Type the English translation for: ${w.uk}`;
            answerInput.placeholder = currentLang === 'uk' ? 'Англійський переклад' : 'English translation';
          } else {
            questionText.textContent = currentLang === 'uk'
              ? `Введіть український переклад для: ${baseDisplay}`
              : `Type the Ukrainian translation for: ${baseDisplay}`;
            answerInput.placeholder = currentLang === 'uk' ? 'Український переклад' : 'Ukrainian translation';
          }
        } else {
          // choice type question (multiple choice)
          questionText.textContent = currentLang === 'uk'
            ? askEng ? `Перекладіть англійською: ${w.uk}` : `Перекладіть українською: ${baseDisplay}`
            : askEng ? `Translate to English: ${w.uk}` : `Translate to Ukrainian: ${baseDisplay}`;
        }
      }
    }

    function goToLevel(level) {
      // Ensure we are in standard quiz mode
      currentMode = 'game';
      currentLevel = level;
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      // Ensure the True/False and Anagram screens are hidden when starting a standard quiz
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      gameScreenElem.classList.remove('hidden');
      wrongWordsSection.innerHTML = '';
      // prepare questions
      let wordList = [];
      if (level === 'beginner') wordList = beginnerWords.slice();
      if (level === 'intermediate') wordList = intermediateWords.slice();
      if (level === 'advanced') wordList = advancedWords.slice();
      if (level === 'mistakes') wordList = mistakes.slice();
      if (level === 'custom') wordList = customWords.slice();
      const count = Math.min(10, wordList.length);
      // Set number of questions (increase to 100 for full game)
      const questionCount = Math.min(100, wordList.length);
      questions = shuffleArray(wordList).slice(0, questionCount).map(w => {
        const r = Math.random();
        let type;
        if (r < 0.4) type = 'choice';
        else if (r < 0.7) type = 'input';
        else type = 'sentence';
        return { word: w, type: type };
      });
      currentQuestionIndex = 0;
      score = 0;
      // Set lives based on selected level
      if (level === 'beginner') {
        totalLives = 9;
      } else if (level === 'intermediate') {
        totalLives = 6;
      } else if (level === 'advanced') {
        totalLives = 3;
      } else {
        totalLives = 9;
      }
      remainingLives = totalLives;
      levelTitleEl.textContent = ui[currentLang].levelTitles[level];
      answerInput.value = '';
      updateLivesDisplay();
      showQuestion();
      updateUI();
    }

    function showQuestion() {
      currentQuestion = questions[currentQuestionIndex];
      const { word, type } = currentQuestion;
      progressBarFill.style.width = ((currentQuestionIndex) / questions.length) * 100 + '%';
      optionsContainer.innerHTML = '';
      answerInput.classList.add('hidden');
      submitBtn.classList.add('hidden');
      // Render audio button for the current English word so users can hear pronunciation
      renderAudioButton(word.en);
      // Special handling for listening mode: always ask for Ukrainian translation and play audio automatically
      if (currentMode === 'listening') {
        // Play audio automatically
        // Speak the base English word without numeric suffixes in listening mode
        const baseWord = stripDigits(word.en);
        safeSpeak(baseWord, 'en-US');
        questionText.textContent = ui[currentLang].listeningQuestion;
        currentQuestion.askEnglish = false;
        const opts = generateOptions(word, false);
        opts.forEach(option => {
          const div = document.createElement('div');
          div.className = 'option';
          div.textContent = option.text;
          div.addEventListener('click', () => selectOption(option));
          optionsContainer.appendChild(div);
        });
        return;
      }
      if (type === 'sentence') {
        // fill‑in‑the‑blank question using a simple template and translation hint
        const templates = [
          'I have a ___',
          'This is my ___',
          'I like to ___',
          'Please bring the ___',
          'Do you like ___?',
          'We need more ___'
        ];
        const template = templates[Math.floor(Math.random() * templates.length)];
        const prompt = template.replace('___', '_____');
        questionText.textContent = currentLang === 'uk'
          ? `Заповніть пропуск: ${prompt} (${word.uk})`
          : `Fill in the blank: ${prompt} (${word.uk})`;
        currentQuestion.askEnglish = true;
        currentQuestion.unscramble = false;
        answerInput.placeholder = currentLang === 'uk' ? 'Введіть англійське слово' : 'Enter the English word';
        answerInput.classList.remove('hidden');
        submitBtn.classList.remove('hidden');
      } else if (type === 'choice') {
        const askEnglish = Math.random() < 0.5;
        currentQuestion.askEnglish = askEnglish;
        const displayEn = stripDigits(word.en);
        questionText.textContent = currentLang === 'uk'
          ? askEnglish ? `Перекладіть англійською: ${word.uk}` : `Перекладіть українською: ${displayEn}`
          : askEnglish ? `Translate to English: ${word.uk}` : `Translate to Ukrainian: ${displayEn}`;
        const opts = generateOptions(word, askEnglish);
        opts.forEach(option => {
          const div = document.createElement('div');
          div.className = 'option';
          div.textContent = option.text;
          div.addEventListener('click', () => selectOption(option));
          optionsContainer.appendChild(div);
        });
      } else {
        // input or unscramble question
        const askEnglish = Math.random() < 0.5;
        currentQuestion.askEnglish = askEnglish;
        const unscramble = Math.random() < 0.5;
        currentQuestion.unscramble = unscramble;
        if (unscramble) {
          const base = stripDigits(word.en);
          const scrambled = shuffleArray(base.split('')).join('');
          currentQuestion.scrambled = scrambled;
          questionText.textContent = currentLang === 'uk'
            ? `Розшифруйте слово: ${scrambled} (${word.uk})`
            : `Unscramble: ${scrambled} (${word.uk})`;
          answerInput.placeholder = currentLang === 'uk' ? 'Введіть слово англійською' : 'Enter the English word';
        } else {
          if (askEnglish) {
            questionText.textContent = currentLang === 'uk'
              ? `Введіть англійський переклад для: ${word.uk}`
              : `Type the English translation for: ${word.uk}`;
            answerInput.placeholder = currentLang === 'uk' ? 'Англійський переклад' : 'English translation';
          } else {
            const displayEn2 = stripDigits(word.en);
            questionText.textContent = currentLang === 'uk'
              ? `Введіть український переклад для: ${displayEn2}`
              : `Type the Ukrainian translation for: ${displayEn2}`;
            answerInput.placeholder = currentLang === 'uk' ? 'Український переклад' : 'Ukrainian translation';
          }
        }
        answerInput.classList.remove('hidden');
        submitBtn.classList.remove('hidden');
      }
    }

    
function generateOptions(correctWord, askEnglish) {
      let pool;
      if (currentLevel === 'beginner') {
        pool = beginnerWords;
      } else if (currentLevel === 'intermediate') {
        pool = intermediateWords;
      } else if (currentLevel === 'advanced') {
        pool = advancedWords;
      } else if (currentLevel === 'mistakes') {
        pool = mistakes;
      } else if (currentLevel === 'custom') {
        pool = customWords;
      } else {
        pool = beginnerWords.concat(intermediateWords, advancedWords, customWords, mistakes);
      }

      if (!pool || pool.length === 0) {
        pool = beginnerWords.concat(intermediateWords, advancedWords, customWords, mistakes);
      }

      const correctText = askEnglish ? stripDigits(correctWord.en) : correctWord.uk;
      const options = [{ text: correctText, correct: true }];

      // Build unique wrong answers (avoid duplicates after stripDigits too)
      const seen = new Set([correctText.trim().toLowerCase()]);
      const wrongCandidates = pool.filter(w => w.en !== correctWord.en);
      const shuffled = shuffleArray(wrongCandidates);
      for (let k = 0; k < shuffled.length && options.length < 4; k++) {
        const w = shuffled[k];
        const wrongText = askEnglish ? stripDigits(w.en) : w.uk;
        const key = (wrongText || '').trim().toLowerCase();
        if (!key || seen.has(key)) continue;
        options.push({ text: wrongText, correct: false });
        seen.add(key);
      }

      // Fallback: if still fewer than 4, pull from full vocabulary
      if (options.length < 4) {
        const all = beginnerWords.concat(intermediateWords, advancedWords, customWords, mistakes);
        const shuffledAll = shuffleArray(all);
        for (let z = 0; z < shuffledAll.length && options.length < 4; z++) {
          const w = shuffledAll[z];
          const wrongText = askEnglish ? stripDigits(w.en) : w.uk;
          const key = (wrongText || '').trim().toLowerCase();
          if (!key || seen.has(key)) continue;
          options.push({ text: wrongText, correct: false });
          seen.add(key);
        }
      }

      // Shuffle and ensure exactly one correct entry exists
      let out = shuffleArray(options);
      const correctCount = out.filter(o => o.correct).length;
      if (correctCount === 0) {
        // Replace a random slot with the correct answer
        const idx = Math.floor(Math.random() * out.length);
        out[idx] = { text: correctText, correct: true };
      } else if (correctCount > 1) {
        // Deduplicate extra correct flags
        let flagged = false;
        out = out.map(o => {
          if (o.correct) {
            if (flagged) return { text: o.text, correct: false };
            flagged = true;
            return o;
          }
          return o;
        });
      }

      return out;
    }


    function selectOption(option) {
      if (option.correct) {
        score++;
      } else {
        addMistake(currentQuestion.word);
        // Decrement lives on incorrect answer
        if (remainingLives > 0) {
          remainingLives--;
          updateLivesDisplay();
        }
        if (remainingLives <= 0) {
          finishQuiz();
          return;
        }
      }
      goNextQuestion();
    }

    function submitAnswer() {
      const { word, askEnglish, unscramble } = currentQuestion;
      const userInput = answerInput.value.trim().toLowerCase();
      let correct;
      if (unscramble) {
        // When unscrambling, compare against the base word without numeric suffixes
        correct = stripDigits(word.en).toLowerCase();
      } else if (askEnglish) {
        // For English translation questions, use the base word
        correct = stripDigits(word.en).toLowerCase();
      } else {
        correct = word.uk.toLowerCase();
      }
      if (userInput === correct) {
        score++;
      } else {
        addMistake(word);
        if (remainingLives > 0) {
          remainingLives--;
          updateLivesDisplay();
        }
        if (remainingLives <= 0) {
          answerInput.value = '';
          finishQuiz();
          return;
        }
      }
      answerInput.value = '';
      goNextQuestion();
    }

    function addMistake(word) {
      if (!mistakes.some(w => w.en === word.en)) {
        mistakes.push(word);
      }
      localStorage.setItem('mistakes', JSON.stringify(mistakes));
    }

    function goNextQuestion() {
      currentQuestionIndex++;
      if (currentQuestionIndex < questions.length) {
        showQuestion();
      } else {
        finishQuiz();
      }
    }

    function finishQuiz() {
      progressBarFill.style.width = '100%';
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.remove('hidden');
      if (remainingLives <= 0) {
        resultTitleEl.textContent = ui[currentLang].noLives;
      } else {
        resultTitleEl.textContent = ui[currentLang].resultTitle;
      }
      scoreTextEl.textContent = ui[currentLang].scoreText(score, questions.length);
      // Save current result into history for progress tracking
      let history = JSON.parse(localStorage.getItem('history') || '[]');
      history.push({ level: currentLevel, score: score, total: questions.length, date: new Date().toISOString(), mode: currentMode });
      localStorage.setItem('history', JSON.stringify(history));

      if (mistakes.length > 0 && currentLevel !== 'mistakes') {
        let html = '<p>' + ui[currentLang].wrongWordsHeading + '</p><ul>';
        mistakes.forEach(item => {
          // Display base English word without numeric suffixes in wrong words list
          const base = stripDigits(item.en);
          html += `<li>${base} – ${item.uk}</li>`;
        });
        html += '</ul>';
        wrongWordsSection.innerHTML = html;
      } else {
        wrongWordsSection.innerHTML = '';
      }
      // Show average performance across all attempts
      const hist = JSON.parse(localStorage.getItem('history') || '[]');
      let avg = 0;
      if (hist.length > 0) {
        avg = hist.reduce((acc, h) => acc + (h.score / h.total), 0) / hist.length;
      }
      const avgText = ui[currentLang].averageResult(avg);
      const avgDiv = document.createElement('p');
      avgDiv.textContent = avgText;
      wrongWordsSection.appendChild(avgDiv);
      updateMistakesButton();

      // Gamification: award points and update streak when finishing a quiz in standard mode
      if (currentMode === 'game' || currentMode === 'listening') {
        awardPoints(score);
        updateStreak();
        updateUserInfo();
      }
    }

    function restart() {
      resultScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      homeScreenElem.classList.remove('hidden');
      currentLevel = '';
      updateUI();
    }

    function openLearn() {
      homeScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      learnScreenElem.classList.remove('hidden');
      document.getElementById('searchInput').value = '';
      learnWordsListElem.innerHTML = '';
      updateUI();
    }

    function openMistakes() {
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      mistakesScreenElem.classList.remove('hidden');
      renderMistakes();
      updateUI();
    }

    function backToHome() {
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      // Hide irregular verbs screen when returning home
      const irr = document.getElementById('irregularScreen');
      if (irr) irr.classList.add('hidden');
      homeScreenElem.classList.remove('hidden');
      updateUI();
    }

    function selectCategory(category) {
      let words;
      if (category === 'beginner') words = beginnerWords;
      else if (category === 'intermediate') words = intermediateWords;
      else if (category === 'advanced') words = advancedWords;
      else words = beginnerWords.concat(intermediateWords, advancedWords);
      renderWords(words);
    }

    function renderWords(words) {
      learnWordsListElem.innerHTML = '';
      words.forEach(w => {
        const card = document.createElement('div');
        card.className = 'word-card';
        // Remove numeric suffixes when displaying words in the learn screen
        const base = stripDigits(w.en);
        card.innerHTML = `<strong>${base}</strong><br/><span>${w.uk}</span>`;
        learnWordsListElem.appendChild(card);
      });
    }

    /**
     * Render the irregular verbs table. This function constructs a
     * table header using the current language headers and then populates
     * each row with the irregular verbs list. Styling for cells is
     * applied inline to blend with the existing design.
     */
    function renderIrregularTable() {
      const table = document.getElementById('irregularTable');
      if (!table) return;
      table.innerHTML = '';
      // Create header
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      ui[currentLang].irregularHeaders.forEach(head => {
        const th = document.createElement('th');
        th.textContent = head;
        th.style.background = 'var(--primary-color)';
        th.style.color = '#fff';
        th.style.padding = '8px';
        th.style.border = '1px solid var(--primary-color)';
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      irregularVerbs.forEach(item => {
        const tr = document.createElement('tr');
        ['base', 'past', 'participle', 'uk'].forEach(key => {
          const td = document.createElement('td');
          td.textContent = item[key];
          td.style.padding = '8px';
          td.style.border = '1px solid var(--primary-color)';
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
    }

    /**
     * Navigate to the irregular verbs table screen. Hides all other
     * screens and shows the irregular verbs container. It then renders
     * the table and updates UI texts to match the chosen language.
     */
    function openIrregular() {
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      const irr = document.getElementById('irregularScreen');
      if (irr) irr.classList.remove('hidden');
      renderIrregularTable();
      updateUI();
    }

    function filterWords() {
      const query = document.getElementById('searchInput').value.trim().toLowerCase();
      let allWords = beginnerWords.concat(intermediateWords, advancedWords);
      const filtered = allWords.filter(w =>
        w.en.toLowerCase().includes(query) || w.uk.toLowerCase().includes(query)
      );
      renderWords(filtered);
    }

    function renderMistakes() {
      mistakesListElem.innerHTML = '';
      if (mistakes.length === 0) {
        mistakesListElem.innerHTML = `<p>${ui[currentLang].noMistakes}</p>`;
        return;
      }
      mistakes.forEach(w => {
        const card = document.createElement('div');
        card.className = 'word-card';
        // Show base English word without numeric suffixes in mistakes list
        const base = stripDigits(w.en);
        card.innerHTML = `<strong>${base}</strong><br/><span>${w.uk}</span>`;
        mistakesListElem.appendChild(card);
      });
    }

    /* ---------------- Memory game functions ---------------- */
    function openMemory() {
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      memoryScreenElem.classList.remove('hidden');
      startMemoryGame();
      updateUI();
    }

    let memoryLock = false;
    let firstMemoryCard = null;
    let secondMemoryCard = null;

    function startMemoryGame() {
      // Build a list of unique word pairs based on the base English word (without numeric suffixes).
      const allWords = beginnerWords.concat(intermediateWords, advancedWords);
      const uniquePairs = [];
      const seenBases = new Set();
      for (const w of allWords) {
        const base = stripDigits(w.en);
        if (!seenBases.has(base)) {
          seenBases.add(base);
          uniquePairs.push({ en: base, uk: w.uk });
        }
      }
      // Shuffle and select six unique pairs for the memory game
      const pairs = shuffleArray(uniquePairs).slice(0, 6);
      const cards = [];
      pairs.forEach((w, index) => {
        cards.push({ id: index, text: w.en });
        cards.push({ id: index, text: w.uk });
      });
      const shuffled = shuffleArray(cards);
      const grid = document.getElementById('memoryGrid');
      grid.innerHTML = '';
      firstMemoryCard = null;
      secondMemoryCard = null;
      memoryLock = false;
      shuffled.forEach(card => {
        const div = document.createElement('div');
        div.className = 'memory-card';
        div.dataset.id = card.id;
        div.dataset.text = card.text;
        div.addEventListener('click', onMemoryCardClick);
        grid.appendChild(div);
      });
    }

    function onMemoryCardClick(e) {
      const card = e.currentTarget;
      if (memoryLock || card.classList.contains('matched') || card === firstMemoryCard) return;
      flipMemoryCard(card);
      if (!firstMemoryCard) {
        firstMemoryCard = card;
      } else {
        secondMemoryCard = card;
        memoryLock = true;
        if (firstMemoryCard.dataset.id === secondMemoryCard.dataset.id) {
          firstMemoryCard.classList.add('matched');
          secondMemoryCard.classList.add('matched');
          firstMemoryCard = null;
          secondMemoryCard = null;
          memoryLock = false;
          checkMemoryWin();
        } else {
          setTimeout(() => {
            unflipMemoryCard(firstMemoryCard);
            unflipMemoryCard(secondMemoryCard);
            firstMemoryCard = null;
            secondMemoryCard = null;
            memoryLock = false;
          }, 800);
        }
      }
    }

    function flipMemoryCard(card) {
      card.classList.add('flipped');
      card.textContent = card.dataset.text;
    }

    function unflipMemoryCard(card) {
      card.classList.remove('flipped');
      card.textContent = '';
    }

    function checkMemoryWin() {
      const unmatched = document.querySelectorAll('.memory-card:not(.matched)');
      if (unmatched.length === 0) {
        alert(ui[currentLang].memoryWin);
      }
    }

    /* ---------------- CSV import functions ---------------- */
    let customWords = [];

    function importWords(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        const lines = text.split(/\r?\n/);
        lines.forEach(line => {
          if (!line.trim()) return;
          const parts = line.split(/[,;\t]/);
          if (parts.length >= 2) {
            const en = parts[0].trim();
            const uk = parts[1].trim();
            if (en && uk) {
              customWords.push({ en: en, uk: uk });
            }
          }
        });
        updateCustomButton();
        updateUI();
      };
      reader.readAsText(file);
    }

    function updateCustomButton() {
      const btn = document.getElementById('customBtn');
      if (!btn) return;
      if (customWords.length > 0) {
        btn.classList.remove('hidden');
      } else {
        btn.classList.add('hidden');
      }
    }

    function updateMistakesButton() {
      if (mistakes.length > 0) {
        mistakesBtn.classList.remove('hidden');
      } else {
        mistakesBtn.classList.add('hidden');
      }
    }

    function shuffleArray(arr) {
      const array = arr.slice();
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    /**
     * Update the visual display of remaining lives. It renders a series of
     * heart emojis equal to the number of remaining lives. Called whenever
     * lives are set or decremented.
     */
    function updateLivesDisplay() {
      const livesElem = document.getElementById('livesContainer');
      if (!livesElem) return;
      let hearts = '';
      for (let i = 0; i < remainingLives; i++) {
        hearts += '❤';
      }
      livesElem.textContent = hearts;
    }

    /**
     * Quit the current game and return to the home screen. Does not save
     * progress to history. Resets current level and hides all screens except home.
     */
    function quitGame() {
      gameScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      homeScreenElem.classList.remove('hidden');
      // Hide mini‑game screens
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      currentLevel = '';
      currentMode = 'game';
      updateUI();
    }
    /**
     * Speak text safely: cancel any ongoing speech and speak with the given lang.
     */
    function safeSpeak(text, lang = 'en-US') {
      try {
        if (!('speechSynthesis' in window)) return;
        speechSynthesis.cancel();
        const utt = new SpeechSynthesisUtterance(text);
        utt.lang = lang || 'en-US';
        speechSynthesis.speak(utt);
      } catch (e) {
        // fail silently
      }
    }
    

    /**
     * Render an audio button that pronounces the given English word when clicked.
     * This uses the browser's Web Speech API (speechSynthesis) to speak the word.
     * The button text is localized based on the current language.
     * @param {string} wordEn - The English word to pronounce
     */
    
    /* ---------------- Speech Synthesis Setup ---------------- */
    let selectedVoiceURI = localStorage.getItem('voiceURI') || '';
    let selectedRate = parseFloat(localStorage.getItem('voiceRate') || '1');

    function populateVoiceList() {
      try {
        if (!('speechSynthesis' in window)) return;
        const select = document.getElementById('voiceSelect');
        if (!select) return;
        const voices = speechSynthesis.getVoices();
        // Filter to common langs we care about first (English + Ukrainian if present)
        const preferredLangs = ['en-US','en-GB','en','uk-UA','uk'];
        const qualityScore = (v) => {
          const name = (v.name || '').toLowerCase();
          let score = 0;
          if (name.includes('microsoft')) score += 5;
          if (name.includes('google')) score += 4;
          if (name.includes('siri') || name.includes('enhanced') || name.includes('natural') || name.includes('neural') || name.includes('online')) score += 3;
          // prefer US/GB English for our content
          if (/^en(-|$)/.test(v.lang)) score += 2;
          return score;
        };
        const sorted = voices.slice().sort((a,b) => {
          const la = preferredLangs.indexOf(a.lang); const lb = preferredLangs.indexOf(b.lang);
          const ldiff = (la === -1 ? 999 : la) - (lb === -1 ? 999 : lb);
          if (ldiff !== 0) return ldiff;
          return qualityScore(b) - qualityScore(a);
        });

        const current = selectedVoiceURI;
        select.innerHTML = '';
        sorted.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.voiceURI || v.name;
          opt.textContent = `${v.name} (${v.lang})`;
          if (current && (v.voiceURI === current || v.name === current)) {
            opt.selected = true;
          }
          select.appendChild(opt);
        });

        // If nothing selected yet, try to auto-pick a high‑quality English voice
        if (!current && sorted.length) {
          const best = sorted.find(v => /^en(-|$)/.test(v.lang)) || sorted[0];
          selectedVoiceURI = best.voiceURI || best.name;
          localStorage.setItem('voiceURI', selectedVoiceURI);
          // Mark chosen
          for (const opt of select.options) {
            if (opt.value === selectedVoiceURI) { opt.selected = true; break; }
          }
        }

        // Rate UI
        const rate = document.getElementById('rateRange');
        if (rate) rate.value = String(selectedRate || 1);
      } catch (e) {}
    }

    function getSelectedVoice() {
      if (!('speechSynthesis' in window)) return null;
      const voices = speechSynthesis.getVoices();
      const uri = selectedVoiceURI;
      let v = voices.find(v => (v.voiceURI === uri || v.name === uri));
      if (!v) {
        // fallback by language preference
        v = voices.find(v => /^en(-|$)/.test(v.lang)) || voices[0] || null;
      }
      return v || null;
    }

    // Enhance safeSpeak to use selected voice and rate
    const _origSafeSpeak = typeof safeSpeak === 'function' ? safeSpeak : null;
    function safeSpeak(text, lang = 'en-US') {
      try {
        if (!('speechSynthesis' in window)) return;
        speechSynthesis.cancel();
        const utt = new SpeechSynthesisUtterance(text);
        const v = getSelectedVoice();
        if (v) {
          utt.voice = v;
          utt.lang = v.lang || lang;
        } else {
          utt.lang = lang || 'en-US';
        }
        const rateEl = document.getElementById('rateRange');
        const rate = rateEl ? parseFloat(rateEl.value) : (selectedRate || 1);
        utt.rate = isFinite(rate) ? Math.max(0.5, Math.min(2, rate)) : 1;
        speechSynthesis.speak(utt);
      } catch (e) {}
    }

    function initVoiceControls() {
      try { var _vs = document.getElementById('voiceSelect'); if (_vs) { _vs.setAttribute('aria-label', (ui[currentLang] && ui[currentLang].voiceAria) || 'TTS voice selection'); } } catch(e) {}
      try { var _rr = document.getElementById('rateRange'); if (_rr) { _rr.setAttribute('aria-label', (ui[currentLang] && ui[currentLang].rateAria) || 'Playback rate'); } } catch(e) {}
      if (!('speechSynthesis' in window)) return;
      populateVoiceList();
      try {
        window.speechSynthesis.onvoiceschanged = () => populateVoiceList();
      } catch (e) {}
      const select = document.getElementById('voiceSelect');
      if (select) {
        select.addEventListener('change', (e) => {
          selectedVoiceURI = e.target.value;
          localStorage.setItem('voiceURI', selectedVoiceURI);
        });
      }
      const rate = document.getElementById('rateRange');
      if (rate) {
        rate.addEventListener('input', (e) => {
          selectedRate = parseFloat(e.target.value || '1');
          localStorage.setItem('voiceRate', String(selectedRate));
        });
      }
    }
function renderAudioButton(wordEn) {
      const container = document.getElementById('audioContainer');
      if (!container) return;
      container.innerHTML = '';
      if (!wordEn) return;
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.style.marginBottom = '10px';
      btn.textContent = ui[currentLang].pronounce;
      btn.addEventListener('click', () => {
        // Pronounce the base English word without numeric suffixes
        const baseWord = stripDigits(wordEn);
        safeSpeak(baseWord, 'en-US');
      });
      container.appendChild(btn);
    }

    /* ---------------- Gamification & Personalization ---------------- */
    /**
     * Prompt the user to enter their name. The entered name is stored in
     * localStorage and used to personalize greetings. If the user cancels or
     * enters an empty string, the name remains unchanged.
     */
    function promptName() {
      const name = prompt(currentLang === 'uk' ? 'Введіть ваше ім’я:' : 'Enter your name:');
      if (name) {
        username = name.trim();
        localStorage.setItem('username', username);
        updateUserInfo();
        updateUI();
      }
    }

    /**
     * Update the greeting and stats displayed on the home screen. Calculates
     * the current level based on accumulated points and displays the current
     * streak. Uses the translation functions defined in the UI dictionary.
     */
    function updateUserInfo() {
      const greetElem = document.getElementById('greeting');
      const statsElem = document.getElementById('stats');
      const setNameText = document.getElementById('setNameText');
      if (!greetElem || !statsElem || !setNameText) return;
      if (username) {
        greetElem.textContent = ui[currentLang].greeting(username);
      } else {
        greetElem.textContent = '';
      }
      const level = Math.floor(totalPoints / levelPointsThreshold) + 1;
      statsElem.textContent = ui[currentLang].stats(totalPoints, level, streakCount);
      setNameText.textContent = ui[currentLang].setName;
    }

    /**
     * Toggle between light and dark themes. Applies or removes the 'dark'
     * class on the document body and persists the choice in localStorage.
     */
    function toggleTheme() {
      const body = document.body;
      const isDark = body.classList.toggle('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      // Update icon on the toggle button
      const themeBtn = document.getElementById('themeToggle');
      if (themeBtn) {
        themeBtn.textContent = isDark ? '☀️' : '🌙';
      }
    }

    /**
     * Initialize the theme based on persisted setting. Called once on page
     * load to ensure the correct theme is applied before user interaction.
     */
    function initTheme() {
      const saved = localStorage.getItem('theme');
      const body = document.body;
      if (saved === 'dark') {
        body.classList.add('dark');
        const themeBtn = document.getElementById('themeToggle');
        if (themeBtn) themeBtn.textContent = '☀️';
      } else {
        body.classList.remove('dark');
        const themeBtn = document.getElementById('themeToggle');
        if (themeBtn) themeBtn.textContent = '🌙';
      }
    }

    /**
     * Update the daily streak count. If the user practiced today, the streak
     * remains; if they practiced yesterday, increment the streak. Otherwise,
     * reset it to 1. Also updates the lastPracticeDate.
     */
    function updateStreak() {
  const today = new Date();
  const todayStr = today.toISOString().split('T')[0];
  const lastDateStr = (lastPracticeDate || '').toString().slice(0, 10);
  if (lastDateStr === todayStr) {
    // already practiced today, no change
    return;
  }
  const yesterday = new Date(today.getTime() - 86400000);
  const yesterdayStr = yesterday.toISOString().split('T')[0];
  if (lastDateStr === yesterdayStr) {
    streakCount++;
  } else {
    streakCount = 1;
  }
  // Store full ISO with time to avoid timezone confusion in UI
  lastPracticeDate = new Date().toISOString();
  localStorage.setItem('streakCount', streakCount.toString());
  localStorage.setItem('lastPracticeDate', lastPracticeDate);
}

    /**
     * Award points based on the number of correct answers. Each correct answer
     * grants ten points. Points are accumulated in totalPoints and saved in
     * localStorage.
     * @param {number} correctCount - the number of correctly answered questions
     */
    function awardPoints(correctCount) {
      const earned = correctCount * 10;
      totalPoints += earned;
      localStorage.setItem('totalPoints', totalPoints.toString());
    }

    /* ---------------- Listening Mode ---------------- */
    /**
     * Start the listening mode. Generates a set of questions where the user
     * listens to an English word and selects the correct Ukrainian translation.
     */
    function goListening() {
      currentMode = 'listening';
      // Use intermediate number of lives for listening mode
      totalLives = 6;
      remainingLives = totalLives;
      // Create question list from all words, excluding numeric variants (those
      // ending with a digit) so that the spoken word matches a natural form.
      const pool = beginnerWords
        .concat(intermediateWords, advancedWords)
        .filter(w => !/\d$/.test(w.en));
      const questionCount = Math.min(100, pool.length);
      questions = shuffleArray(pool).slice(0, questionCount).map(w => {
        return { word: w, type: 'listening', askEnglish: true };
      });
      currentQuestionIndex = 0;
      score = 0;
      // Set UI
      gameScreenElem.classList.remove('hidden');
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      levelTitleEl.textContent = currentLang === 'uk' ? ui.uk.listeningTitle : ui.en.listeningTitle;
      updateLivesDisplay();
      showQuestion();
      updateUI();
    }

    /* ---------------- Hangman Mode ---------------- */
    /**
     * Start a new hangman game. Selects a random word, resets guessed letters
     * and wrong letters, sets the number of lives, and updates the display.
     */
    function startHangman() {
      currentMode = 'hangman';
      // Choose a random word from the entire vocabulary
      const pool = beginnerWords.concat(intermediateWords, advancedWords);
      // Exclude numeric variants so gameplay and hints match pronunciation
      const poolFiltered = pool.filter(w => !/\d$/.test(w.en));
      const randomPair = poolFiltered[Math.floor(Math.random() * poolFiltered.length)];
      hangmanWord = stripDigits(randomPair.en).toLowerCase();
      hangmanGuessed = [];
      hangmanWrong = [];
      hangmanLivesCount = 6;
      // Update UI to show hangman screen
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.remove('hidden');
      // Ensure other mini‑games are hidden
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      // Set texts
      document.getElementById('hangmanTitle').textContent = ui[currentLang].hangmanTitle;
      document.getElementById('hangmanDesc').textContent = ui[currentLang].hangmanDesc;
      document.getElementById('hangmanSubmitBtn').textContent = ui[currentLang].hangmanSubmit;
      document.getElementById('hangmanRestartBtn').textContent = ui[currentLang].hangmanRestart;
      document.getElementById('hangmanBackBtn').textContent = ui[currentLang].hangmanBack;
      document.getElementById('hangmanInput').value = '';
      document.getElementById('hangmanInput').placeholder = ui[currentLang].hangmanInputPlaceholder;
      // Show hint (Ukrainian translation)
      document.getElementById('hangmanHint').textContent = randomPair.uk;
      updateHangmanDisplay();
    }

    /**
     * Update the hangman display: show guessed letters and underscores for
     * unguessed letters, display wrong letters and remaining lives as hearts.
     */
    function updateHangmanDisplay() {
      const displayElem = document.getElementById('hangmanDisplay');
      const wrongElem = document.getElementById('hangmanWrongLetters');
      const livesElem = document.getElementById('hangmanLives');
      // Build display string
      let disp = '';
      for (let ch of hangmanWord) {
        if (hangmanGuessed.includes(ch)) {
          disp += ch.toUpperCase() + ' ';
        } else {
          disp += '_ ';
        }
      }
      displayElem.textContent = disp.trim();
      wrongElem.textContent = hangmanWrong.length > 0 ? hangmanWrong.join(', ').toUpperCase() : '';
      // Build hearts for remaining lives
      let hearts = '';
      for (let i = 0; i < hangmanLivesCount; i++) hearts += '❤';
      livesElem.textContent = hearts;
    }

    // Register a service worker for offline support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js').catch(err => {
          console.log('SW registration failed:', err);
        });
      });
    }

    /**
     * Clear all persisted data and reload the game. This will remove
     * stored points, mistakes, username and streaks. A confirmation
     * dialog is shown to prevent accidental resets.
     */
    function resetData() {
      const msg = ui[currentLang].resetConfirm || 'Reset all data?';
      if (confirm(msg)) {
        try {
          localStorage.clear();
        } catch (e) {
          console.warn('Failed to clear local storage', e);
        }
        totalPoints = 0;
        streakCount = 0;
        currentLevel = '';
        currentMode = 'game';
        mistakes = [];
        username = '';
        location.reload();
      }
    }

    /**
     * Handle a letter guess in hangman. Reads the input field, checks the
     * letter against the word, updates guessed or wrong arrays, and updates
     * the display. Detects win or lose conditions and shows messages.
     */
    function guessHangmanLetter() {
      const input = document.getElementById('hangmanInput');
      const letter = input.value.trim().toLowerCase();
      if (!letter || letter.length !== 1 || !/^[a-z]$/.test(letter)) {
        input.value = '';
        return;
      }
      input.value = '';
      if (hangmanGuessed.includes(letter) || hangmanWrong.includes(letter)) {
        return;
      }
      if (hangmanWord.includes(letter)) {
        hangmanGuessed.push(letter);
      } else {
        hangmanWrong.push(letter);
        hangmanLivesCount--;
      }
      updateHangmanDisplay();
      // Check win
      const allGuessed = hangmanWord.split('').every(ch => hangmanGuessed.includes(ch));
      if (allGuessed) {
        alert(ui[currentLang].hangmanWin);
        // Award small bonus points for winning hangman
        awardPoints(5);
        updateUserInfo();
        // Return to home
        backToHome();
        return;
      }
      // Check lose
      if (hangmanLivesCount <= 0) {
        alert(ui[currentLang].hangmanLose(hangmanWord));
        backToHome();
      }
    }

    /* ---------------- True/False mini‑game ---------------- */
    // Variables to hold True/False questions, current index and score.
    let tfQuestions = [];
    let tfCurrentIndex = 0;
    let tfScore = 0;

    /**
     * Launch the True/False game. Builds a list of random questions using the
     * entire vocabulary. For each question we choose whether to display the
     * correct Ukrainian translation or a random incorrect one. Then it
     * hides all other screens and shows the True/False screen.
     */
    function goTrueFalse() {
      currentMode = 'truefalse';
      // Build the pool of all words. Exclude numeric variants (those ending with a digit)
      const pool = beginnerWords
        .concat(intermediateWords, advancedWords)
        .filter(w => !/\d$/.test(w.en));
        const poolFiltered = pool;
const questionCount = Math.min(20, pool.length);
      const selected = shuffleArray(pool).slice(0, questionCount);
      tfQuestions = [];
      selected.forEach(w => {
        const correctUk = w.uk;
        let showUk;
        let isCorrect;
        if (Math.random() < 0.5) {
          // Present the correct translation
          showUk = correctUk;
          isCorrect = true;
        } else {
          // Present a random incorrect translation
          let wrong;
          do {
            const rand = poolFiltered[Math.floor(Math.random() * poolFiltered.length)].uk;
            wrong = rand;
          } while (wrong === correctUk);
          showUk = wrong;
          isCorrect = false;
        }
        tfQuestions.push({ en: w.en, uk: correctUk, showUk, isCorrect });
      });
      tfCurrentIndex = 0;
      tfScore = 0;
      // Hide other screens and show TF screen
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.remove('hidden');
      showTFQuestion();
      updateUI();
    }

    /**
     * Display the current True/False question or finish the game when
     * questions are exhausted. Updates the question text and progress.
     */
    function showTFQuestion() {
      const tfQuestionDiv = document.getElementById('tfQuestion');
      const tfProgress = document.getElementById('tfProgress');
      const tfFinishBtn = document.getElementById('tfFinishBtn');
      const tfOptionsDiv = document.getElementById('tfOptions');
      // Hide finish button while we still have questions
      tfFinishBtn.classList.add('hidden');
      // Ensure answer buttons are visible
      tfOptionsDiv.style.display = 'flex';
      // Ensure back button is visible for each question
      const tfBackBtn = document.getElementById('tfBackBtn');
      if (tfBackBtn) tfBackBtn.classList.remove('hidden');
      if (tfCurrentIndex >= tfQuestions.length) {
        finishTrueFalseGame();
        return;
      }
      const q = tfQuestions[tfCurrentIndex];
      // Remove numeric suffix from English word when displaying True/False questions
      const baseEn = stripDigits(q.en);
      tfQuestionDiv.textContent = currentLang === 'uk'
        ? `Переклад слова "${baseEn}" — "${q.showUk}"?`
        : `Is the translation of "${baseEn}" equal to "${q.showUk}"?`;
      tfProgress.textContent = `${tfCurrentIndex + 1} / ${tfQuestions.length}`;
    }

    /**
     * Handle the player's response for a True/False question. Increments
     * the score if the response matches the actual correctness, then
     * advances to the next question.
     * @param {boolean} ans - the player's answer (true if they think the translation is correct)
     */
    function answerTF(ans) {
      const q = tfQuestions[tfCurrentIndex];
      if (q && ans === q.isCorrect) {
        tfScore++;
      }
      else if (q) { addMistake({ en: q.en, uk: q.uk }); }
      tfCurrentIndex++;
      showTFQuestion();
    }

    /**
     * Finish the True/False game. Shows the result to the user, hides the
     * answer buttons and awards points based on the number of correct
     * answers. Also updates the streak and user info.
     */
    function finishTrueFalseGame() {
      // Grab DOM elements locally
      const tfOptionsDiv = document.getElementById('tfOptions');
      const tfProgress = document.getElementById('tfProgress');
      const tfQuestionDiv = document.getElementById('tfQuestion');
      const tfBack = document.getElementById('tfBackBtn');
      const tfFinishBtn = document.getElementById('tfFinishBtn');

      // Hide options and progress
      // Hide the answer buttons completely
      tfOptionsDiv.style.display = 'none';
      tfProgress.textContent = '';
      // Show result message
      tfQuestionDiv.textContent = ui[currentLang].tfScoreText(tfScore, tfQuestions.length);
      // Hide the always-visible back button to avoid duplicates
      if (tfBack) tfBack.classList.add('hidden');
      // Configure and show finish/back button for the end of the game
      tfFinishBtn.textContent = ui[currentLang].back;
      tfFinishBtn.classList.remove('hidden');
      // Award points equal to correct answers (each counts as 10 in awardPoints)
      awardPoints(tfScore);
      updateStreak();
      updateUserInfo();
      updateUI();

      // After showing the score, automatically display the mistakes list for this session
      // by navigating to the Mistakes screen.
      const tfScreen = document.getElementById('tfScreen');
      if (tfScreen) tfScreen.classList.add('hidden');
      mistakesScreenElem.classList.remove('hidden');
      renderMistakes();
}

    /* ---------------- Anagram mini‑game ---------------- */
    // Variables to hold Anagram questions, current index and score
    let anagramQuestions = [];
    let anagramCurrentIndex = 0;
    let anagramScore = 0;

    /**
     * Launch the Anagram game. Builds a list of random words (excluding numeric
     * variants) and scrambles their letters. Shows the Ukrainian translation
     * as a hint. Hides all other screens and shows the anagram screen.
     */
    function goAnagram() {
      currentMode = 'anagram';
      // Build pool of words excluding numeric variants
      const pool = beginnerWords
        .concat(intermediateWords, advancedWords)
        .filter(w => !/\d$/.test(w.en));
      const questionCount = Math.min(20, pool.length);
      const selected = shuffleArray(pool).slice(0, questionCount);
      anagramQuestions = selected.map(w => {
        // scramble letters of the English word
        const chars = w.en.split('');
        let scrambled = '';
        do {
          scrambled = shuffleArray(chars).join('');
        } while (scrambled.toLowerCase() === w.en.toLowerCase());
        return { en: w.en, uk: w.uk, scrambled };
      });
      anagramCurrentIndex = 0;
      anagramScore = 0;
      // hide other screens
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.remove('hidden');
      // Ensure back button is visible at the start of the anagram game
      const anagramBack = document.getElementById('anagramBackBtn');
      if (anagramBack) anagramBack.classList.remove('hidden');
      showAnagramQuestion();
      updateUI();
    }

    /**
     * Display the current anagram question or finish the game if no more
     * questions. Updates the scrambled text, hint, progress and button
     * visibility.
     */
    function showAnagramQuestion() {
      const questionDiv = document.getElementById('anagramQuestion');
      const progressDiv = document.getElementById('anagramProgress');
      const finishBtn = document.getElementById('anagramFinishBtn');
      const submitBtnElem = document.getElementById('anagramSubmitBtn');
      const inputElem = document.getElementById('anagramInput');
      if (anagramCurrentIndex >= anagramQuestions.length) {
        finishAnagramGame();
        return;
      }
      const q = anagramQuestions[anagramCurrentIndex];
      // Show scrambled letters and Ukrainian translation hint
      questionDiv.textContent = currentLang === 'uk'
        ? `Розшифруйте слово: ${q.scrambled} (${q.uk})`
        : `Unscramble: ${q.scrambled} (${q.uk})`;
      // Clear input
      if (inputElem) inputElem.value = '';
      // Update progress
      progressDiv.textContent = `${anagramCurrentIndex + 1} / ${anagramQuestions.length}`;
      // ensure finish button hidden and submit visible
      finishBtn.classList.add('hidden');
      submitBtnElem.classList.remove('hidden');
      inputElem.classList.remove('hidden');
    }

    /**
     * Handle the player's input for an anagram question. If the input
     * matches the correct English word (case‑insensitive), increment
     * score. Advances to the next question.
     */
    function submitAnagram() {
      const inputElem = document.getElementById('anagramInput');
      const userInput = (inputElem ? inputElem.value.trim().toLowerCase() : '');
      const q = anagramQuestions[anagramCurrentIndex];
      if (q && userInput === q.en.toLowerCase()) {
        anagramScore++;
      }
      anagramCurrentIndex++;
      showAnagramQuestion();
    }

    /**
     * Finish the anagram game. Display the result, hide input and submit
     * button, show finish button. Award points and update streak & user.
     */
    function finishAnagramGame() {
      const questionDiv = document.getElementById('anagramQuestion');
      const progressDiv = document.getElementById('anagramProgress');
      const finishBtn = document.getElementById('anagramFinishBtn');
      const submitBtnElem = document.getElementById('anagramSubmitBtn');
      const inputElem = document.getElementById('anagramInput');
      // Hide input and submit button
      if (submitBtnElem) submitBtnElem.classList.add('hidden');
      if (inputElem) inputElem.classList.add('hidden');
      // Clear progress
      progressDiv.textContent = '';
      // Show result
      questionDiv.textContent = ui[currentLang].anagramScoreText(anagramScore, anagramQuestions.length);
      // Hide the always-visible back button to avoid duplicates
      const anagramBack = document.getElementById('anagramBackBtn');
      if (anagramBack) anagramBack.classList.add('hidden');
      // Show finish button and set its text
      finishBtn.textContent = ui[currentLang].back;
      finishBtn.classList.remove('hidden');
      // Award points and update streak & user info
      awardPoints(anagramScore);
      updateStreak();
      updateUserInfo();
      updateUI();
    }

    // Initialize theme and user info before rendering UI
    initTheme();
    updateUserInfo();
    updateUI();
    updateMistakesButton();
  
    initVoiceControls();

    /* ---------------- Profile (Stats) Modal ---------------- */
    function tOrDefault(key, ukFallback, enFallback) {
      try {
        if (ui && ui[currentLang] && ui[currentLang][key]) return ui[currentLang][key];
      } catch(e) {}
      return currentLang === 'uk' ? (ukFallback || '') : (enFallback || '');
    }

    function openProfile() {
      try { buildProfile(); } catch(e) {}
      const modal = document.getElementById('profileModal');
      if (modal) modal.classList.remove('hidden');
    }
    function closeProfile() {
      const modal = document.getElementById('profileModal');
      if (modal) modal.classList.add('hidden');
    }

    function formatPercent(val) {
      if (!isFinite(val)) return '-';
      return Math.round(val * 100) + '%';
    }
    function formatDateLocal(iso) {
  try {
    const locale = (currentLang === 'uk' ? 'uk-UA' : 'en-GB');
    if (typeof iso === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(iso)) {
      // Date-only string stored in older versions -> show date without time, in local tz
      const [y,m,d] = iso.split('-').map(Number);
      const dt = new Date(y, m-1, d);
      return dt.toLocaleDateString(locale);
    }
    const d = new Date(iso);
    return d.toLocaleString(locale);
  } catch(e) { return iso; }
}

    function groupBy(arr, keyFn) {
      const m = new Map();
      for (const it of arr) {
        const k = keyFn(it);
        m.set(k, (m.get(k) || []).concat([it]));
      }
      return m;
    }

    function buildLevelStats(history) {
      const levels = ['beginner','intermediate','advanced','mistakes','custom'];
      const rows = [];
      levels.forEach(lvl => {
        const items = history.filter(h => h.level === lvl);
        if (items.length === 0) return;
        const attempts = items.length;
        const best = Math.max(...items.map(h => h.score / h.total));
        const avg = items.reduce((a,h)=>a + (h.score/h.total),0) / items.length;
        rows.push({ lvl, attempts, best, avg });
      });
      return rows;
    }

    function buildModeStats(history) {
      // mode can be 'game', 'listening', 'hangman', 'truefalse', 'anagram', etc.
      const byMode = groupBy(history, h => h.mode || 'game');
      const rows = [];
      for (const [mode, items] of byMode.entries()) {
        const attempts = items.length;
        const best = Math.max(...items.map(h => h.score / h.total));
        const avg = items.reduce((a,h)=>a + (h.score/h.total),0) / items.length;
        rows.push({ mode, attempts, best, avg });
      }
      return rows;
    }

    function buildProfile() {
      // Titles and buttons
      const profileTitle = document.getElementById('profileTitle');
      if (profileTitle) profileTitle.textContent = tOrDefault('profileTitle', 'Профіль', 'Profile');
      const exportBtn = document.getElementById('profileExportBtn');
      if (exportBtn) exportBtn.textContent = tOrDefault('profileExport', 'Експорт CSV', 'Export CSV');
      const clearBtn = document.getElementById('profileClearBtn');
      if (clearBtn) clearBtn.textContent = tOrDefault('profileClear', 'Очистити історію', 'Clear history');
      const closeBtn = document.getElementById('profileCloseBtn');
      if (closeBtn && closeBtn.tagName === 'BUTTON') closeBtn.textContent = tOrDefault('close', 'Закрити', 'Close');

      const hist = JSON.parse(localStorage.getItem('history') || '[]');
      const totalPts = parseInt(localStorage.getItem('totalPoints') || '0');
      const streak = parseInt(localStorage.getItem('streakCount') || '0');
      const lastDate = localStorage.getItem('lastPracticeDate') || '';
      const mistakesArr = JSON.parse(localStorage.getItem('mistakes') || '[]');

      // Summary
      const levelPointsThresholdLocal = (typeof levelPointsThreshold !== 'undefined') ? levelPointsThreshold : 200;
      const levelNum = Math.floor(totalPts / levelPointsThresholdLocal) + 1;
      let avg = 0;
      if (hist.length) {
        avg = hist.reduce((acc, h) => acc + (h.score / h.total), 0) / hist.length;
      }
      const sumEl = document.getElementById('profileSummary');
      if (sumEl) {
        sumEl.innerHTML = `
          <div class="stat-grid">
            <div class="stat"><div>${tOrDefault('points','Очки','Points')}</div><div style="font-size:1.3rem;font-weight:700">${totalPts}</div></div>
            <div class="stat"><div>${tOrDefault('level','Рівень','Level')}</div><div style="font-size:1.3rem;font-weight:700">${levelNum}</div></div>
            <div class="stat"><div>${tOrDefault('streak','Серія','Streak')}</div><div style="font-size:1.3rem;font-weight:700">${streak}</div></div>
            <div class="stat"><div>${tOrDefault('avgScore','Середній результат','Average score')}</div><div style="font-size:1.3rem;font-weight:700">${formatPercent(avg)}</div></div>
            <div class="stat"><div>${tOrDefault('mistakesCount','К-сть помилок','Mistakes count')}</div><div style="font-size:1.3rem;font-weight:700">${mistakesArr.length}</div></div>
            <div class="stat"><div>${tOrDefault('lastPractice','Остання практика','Last practice')}</div><div style="font-size:1.0rem;font-weight:600">${lastDate ? formatDateLocal(lastDate) : '—'}</div></div>
          </div>
        `;
      }

      const lvlTitle = document.getElementById('profileByLevelTitle');
      if (lvlTitle) lvlTitle.textContent = tOrDefault('byLevel','За рівнями','By levels');
      const lvlEl = document.getElementById('profileByLevel');
      if (lvlEl) {
        const rows = buildLevelStats(hist);
        if (!rows.length) {
          lvlEl.textContent = tOrDefault('noData','Немає даних','No data yet');
        } else {
          let html = `<table class="table"><thead><tr>
            <th>${tOrDefault('level','Рівень','Level')}</th>
            <th>${tOrDefault('attempts','Спроби','Attempts')}</th>
            <th>${tOrDefault('best','Найкращий','Best')}</th>
            <th>${tOrDefault('average','Середній','Average')}</th>
          </tr></thead><tbody>`;
          rows.forEach(r => {
            const levelName = (ui[currentLang] && ui[currentLang].levelTitles && ui[currentLang].levelTitles[r.lvl]) ? ui[currentLang].levelTitles[r.lvl] : r.lvl;
            html += `<tr>
              <td>${levelName}</td>
              <td>${r.attempts}</td>
              <td>${formatPercent(r.best)}</td>
              <td>${formatPercent(r.avg)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          lvlEl.innerHTML = html;
        }
      }

      const modeTitle = document.getElementById('profileByModeTitle');
      if (modeTitle) modeTitle.textContent = tOrDefault('byMode','За іграми','By games');
      const modeEl = document.getElementById('profileByMode');
      if (modeEl) {
        const rows = buildModeStats(hist);
        if (!rows.length) {
          modeEl.textContent = tOrDefault('noData','Немає даних','No data yet');
        } else {
          const labels = {
            game: tOrDefault('modeClassic','Класична вікторина','Classic quiz'),
            listening: tOrDefault('listeningBtn','Аудіювання','Listening'),
            hangman: tOrDefault('hangmanTitle','Виселиці','Hangman'),
            truefalse: tOrDefault('tfTitle','Гра Правда/Неправда','True/False Game'),
            anagram: tOrDefault('anagramTitle','Анаграма','Anagram'),
            memory: tOrDefault('memoryTitle',"Гра пам'ять",'Memory')
          };
          let html = `<table class="table"><thead><tr>
            <th>${tOrDefault('mode','Режим','Mode')}</th>
            <th>${tOrDefault('attempts','Спроби','Attempts')}</th>
            <th>${tOrDefault('best','Найкращий','Best')}</th>
            <th>${tOrDefault('average','Середній','Average')}</th>
          </tr></thead><tbody>`;
          rows.forEach(r => {
            const name = labels[r.mode] || r.mode;
            html += `<tr>
              <td>${name}</td>
              <td>${r.attempts}</td>
              <td>${formatPercent(r.best)}</td>
              <td>${formatPercent(r.avg)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          modeEl.innerHTML = html;
        }
      }

      const recentTitle = document.getElementById('profileRecentTitle');
      if (recentTitle) recentTitle.textContent = tOrDefault('recent','Останні результати','Recent results');
      const recEl = document.getElementById('profileRecent');
      if (recEl) {
        if (!hist.length) {
          recEl.textContent = tOrDefault('noData','Немає даних','No data yet');
        } else {
          const last = hist.slice(-10).reverse();
          let html = `<table class="table"><thead><tr>
            <th>${tOrDefault('date','Дата','Date')}</th>
            <th>${tOrDefault('mode','Режим','Mode')}</th>
            <th>${tOrDefault('level','Рівень','Level')}</th>
            <th>${tOrDefault('score','Рахунок','Score')}</th>
            <th>%</th>
          </tr></thead><tbody>`;
          last.forEach(h => {
            const pct = h.total ? (h.score / h.total) : 0;
            const mode = h.mode || 'game';
            const levelName = (ui[currentLang] && ui[currentLang].levelTitles && ui[currentLang].levelTitles[h.level]) ? ui[currentLang].levelTitles[h.level] : (h.level || '');
            html += `<tr>
              <td>${formatDateLocal(h.date)}</td>
              <td>${mode}</td>
              <td>${levelName}</td>
              <td>${h.score}/${h.total}</td>
              <td>${formatPercent(pct)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          recEl.innerHTML = html;
        }
      }

      const sumTitle = document.getElementById('profileSummaryTitle');
      if (sumTitle) sumTitle.textContent = tOrDefault('summary','Зведення','Summary');
    }

    function exportHistoryCSV() {
      const hist = JSON.parse(localStorage.getItem('history') || '[]');
      if (!hist.length) { alert(tOrDefault('noData','Немає даних','No data yet')); return; }
      const headers = ['date','mode','level','score','total'];
      const rows = [headers.join(',')]
        .concat(hist.map(h => [h.date, h.mode || 'game', h.level || '', h.score, h.total].join(',')));
      const csv = rows.join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'lexiverse-history.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function clearHistoryData() {
      if (!confirm(tOrDefault('confirmClear','Очистити історію результатів?','Clear results history?'))) return;
      localStorage.removeItem('history');
      buildProfile();
    }

</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const header = document.querySelector('header');
  if (!header) return;

  // Collect candidate controls
  const controls = [];
  ['#resetBtn', '#profileBtnTop', '#importTopBtn'].forEach(sel => {
    const el = header.querySelector(sel);
    if (el) controls.push(el);
  });
  // language toggle(s)
  header.querySelectorAll('.language-toggle').forEach(el => controls.push(el));

  // Create actions wrapper
  let actions = header.querySelector('.header-actions');
  if (!actions) {
    actions = document.createElement('div');
    actions.className = 'header-actions';
    header.appendChild(actions);
  }

  // Move controls into wrapper (so we can collapse/expand on mobile)
  controls.forEach(el => actions.appendChild(el));

  // Create hamburger toggle
  let navToggle = document.getElementById('navToggle');
  if (!navToggle) {
    navToggle = document.createElement('button');
    navToggle.id = 'navToggle';
    navToggle.setAttribute('aria-label', 'Toggle menu');
    navToggle.innerHTML = '&#9776;'; // hamburger symbol
    // Insert after the title if exists, otherwise at start
    const h1 = header.querySelector('h1');
    if (h1 && h1.nextSibling) {
      h1.parentNode.insertBefore(navToggle, h1.nextSibling);
    } else if (h1) {
      h1.parentNode.appendChild(navToggle);
    } else {
      header.insertBefore(navToggle, header.firstChild);
    }
  }

  navToggle.addEventListener('click', () => {
    header.classList.toggle('open');
  });

  // Close when clicking outside (mobile)
  document.addEventListener('click', (e) => {
    if (!header.contains(e.target) && header.classList.contains('open')) {
      header.classList.remove('open');
    }
  });
});
</script>

</body>
</html>
