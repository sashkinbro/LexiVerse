<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Enable standalone web app mode on iOS -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="default" />
  <!-- Progressive Web App manifest and icons -->
  <link rel="manifest" href="manifest.json" />
  <link rel="apple-touch-icon" href="icon-192.png" />
  <meta name="theme-color" content="#007aff" />
  <!-- Updated title to reflect the new name of the application. -->
  <!-- Updated title to reflect the new name of the application. -->
  <title>LexiVerse ‚Äì –í–∏–≤—á–µ–Ω–Ω—è –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—ó</title>
  <!-- Modern Google font -->
  <link href="https://fonts.googleapis.com/css2?family=Rubik:wght@400;500;700&display=swap" rel="stylesheet" />
  <!-- Font Awesome icons for richer button illustrations -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" integrity="sha512-dF2+MQve2O3a6yOD87o5iV/mQJu1nvLKYj1WFJsbgx5caGV5/C/PObbIVdQydb9h9NP7VDaRao7IYQ7fZeFKAQ==" crossorigin="anonymous" referrerpolicy="no-referrer"/>
  <style>

/* =========================
   LexiVerse ‚Äî Modern UI Pack
   Version: 1.0 (2025-08-14)
   Author: ChatGPT
   Notes:
   - Drop-in stylesheet that *replaces* your current <style> block.
   - No JS changes required; all IDs/classes from the old UI are respected.
   - Light/Dark modes supported via body.dark (already used by your code).
   ========================= */

/* --------- CSS Reset (condensed) ---------- */
*,
*::before,
*::after { box-sizing: border-box; }
html { -webkit-text-size-adjust: 100%; }
body, h1, h2, h3, h4, h5, h6, p, figure { margin: 0; }
button, input, select, textarea { font: inherit; }

/* --------- Design Tokens ---------- */
:root {
  --bg: #0b1020;
  --bg-soft: #0f1630;
  --panel: rgba(255,255,255,0.06);
  --panel-strong: rgba(255,255,255,0.12);
  --txt: #e6e9f2;
  --txt-dim: #b6bdd6;
  --brand: #6aa6ff;
  --brand-2: #9b7bff;
  --accent: #ff6a95;
  --good: #52e2c0;
  --warn: #f3b562;
  --danger: #ff6a6a;
  --ring: rgba(106,166,255,0.5);
  --radius-s: 10px;
  --radius-m: 14px;
  --radius-l: 20px;
  --shadow-1: 0 10px 30px rgba(0,0,0,0.25);
  --blur: blur(16px);
  --font-ui: 'Inter', system-ui, -apple-system, Segoe UI, Roboto, 'Rubik', sans-serif;
}

/* Light theme (auto when body:not(.dark)) */
body:not(.dark) {
  --bg: #f5f7fb;
  --bg-soft: #eef2f9;
  --panel: rgba(12,18,44,0.06);
  --panel-strong: rgba(12,18,44,0.12);
  --txt: #0c122c;
  --txt-dim: #53607b;
  --brand: #1a73e8;
  --brand-2: #6b4cff;
  --accent: #e9426d;
  --good: #0fa968;
  --warn: #b7791f;
  --danger: #d7263d;
  --ring: rgba(26,115,232,0.35);
}

/* --------- Base ---------- */
@media (prefers-reduced-motion: no-preference) {
  :root { scroll-behavior: smooth; }
}
body {
  font-family: var(--font-ui);
  color: var(--txt);
  background:
    radial-gradient(1200px 800px at 10% -10%, rgba(106,166,255,0.25), transparent 60%),
    radial-gradient(1000px 700px at 110% 10%, rgba(155,123,255,0.22), transparent 60%),
    radial-gradient(900px 700px at 50% 120%, rgba(233,66,109,0.18), transparent 60%),
    var(--bg);
  min-height: 100svh;
  display: flex;
  flex-direction: column;
  line-height: 1.45;
}

/* Focus styles */
:where(a, button, [tabindex], input, select, textarea):focus-visible {
  outline: none;
  box-shadow: 0 0 0 3px var(--ring);
  border-radius: 12px;
}

/* --------- App Header ---------- */
header {
  position: sticky; top: 0; z-index: 40;
  display: grid; grid-template-columns: 1fr auto; gap: 12px;
  align-items: center;
  padding: clamp(12px, 2vw, 18px) clamp(16px, 3vw, 28px);
  background: color-mix(in oklab, var(--bg) 80%, transparent);
  -webkit-backdrop-filter: var(--blur);
  backdrop-filter: var(--blur);
  border-bottom: 1px solid var(--panel-strong);
}
header h1 {
  font-weight: 800;
  letter-spacing: -0.02em;
  font-size: clamp(1.2rem, 0.9rem + 1.2vw, 1.8rem);
  background: linear-gradient(120deg, var(--brand), var(--brand-2));
  -webkit-background-clip: text; background-clip: text; color: transparent;
}
header .language-toggle,
#resetBtn,
#profileBtnTop,
#importTopBtn {
  appearance: none;
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  color: var(--txt);
  padding: 10px 14px;
  border-radius: 999px;
  cursor: pointer;
  transition: transform .12s ease, box-shadow .2s ease, border-color .2s ease;
  display: inline-flex; align-items: center; gap: 8px;
}
header .language-toggle:hover,
#resetBtn:hover,
#profileBtnTop:hover,
#importTopBtn:hover { transform: translateY(-1px); border-color: var(--panel); }
header .language-toggle:active,
#resetBtn:active,
#profileBtnTop:active,
#importTopBtn:active { transform: translateY(0); }

/* --------- Containers / Cards ---------- */
.container,
.profile-card {
  width: min(1100px, 100%);
  margin-inline: auto;
  background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.03));
  border: 1px solid var(--panel-strong);
  border-radius: var(--radius-l);
  padding: clamp(20px, 2vw, 36px);
  box-shadow: var(--shadow-1);
}
main {
  flex: 1;
  padding: clamp(12px, 2vw, 24px);
  display: grid;
  place-items: start center;
  gap: 20px;
}

/* --------- Start Screen Overlay ---------- */
#startScreen {
  position: fixed; inset: 0; z-index: 50;
  display: grid; place-items: center;
  background:
    radial-gradient(1200px 700px at 50% -10%, rgba(155,123,255,0.18), transparent 60%),
    linear-gradient(180deg, color-mix(in oklab, var(--bg) 96%, transparent), var(--bg));
  padding: 24px;
}
#startScreen .btn.btn-large {
  font-weight: 700;
  letter-spacing: .01em;
}

/* --------- Buttons ---------- */
.btn {
  --btn-bg: linear-gradient(180deg, color-mix(in oklab, var(--brand) 86%, white 0%), color-mix(in oklab, var(--brand-2) 40%, black 0%));
  --btn-border: color-mix(in oklab, var(--brand) 60%, black 20%);
  border: 1px solid var(--btn-border);
  background: var(--btn-bg);
  color: white;
  padding: 12px 22px;
  border-radius: 14px;
  cursor: pointer;
  display: inline-flex; align-items: center; justify-content: center; gap: 10px;
  transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
  box-shadow: 0 8px 20px rgba(0,0,0,0.25);
}
.btn:hover { transform: translateY(-1px); filter: brightness(1.08); }
.btn:active { transform: translateY(0); filter: brightness(.96); }
.btn-secondary {
  --btn-bg: linear-gradient(180deg, color-mix(in oklab, var(--brand-2) 80%, white 0%), color-mix(in oklab, var(--brand) 35%, black 0%));
  --btn-border: color-mix(in oklab, var(--brand-2) 60%, black 20%);
}
.btn-large { padding: 16px 28px; font-size: 1.075rem; border-radius: 16px; }

/* Icon sizing inside buttons */
.btn img.icon { width: 22px; height: 22px; }
header .language-toggle img.icon { width: 18px; height: 18px; }

/* --------- Typography blocks ---------- */
.center { text-align: center; }
.question {
  font-size: clamp(1.1rem, 1rem + .6vw, 1.45rem);
  font-weight: 700;
  letter-spacing: -0.01em;
  margin-bottom: 10px;
}

/* --------- Interactive Lists ---------- */
.options {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
  gap: 12px;
  margin-top: 8px;
}
.option {
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.015));
  border-radius: 12px;
  padding: 14px 16px;
  cursor: pointer;
  transition: transform .12s ease, border-color .2s ease, background .2s ease;
}
.option:hover { transform: translateY(-2px); border-color: var(--panel); }
.option:active { transform: translateY(0); }

/* --------- Inputs ---------- */
input[type="text"],
input[type="file"],
select {
  width: 100%;
  background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.04));
  color: var(--txt);
  border: 1px solid var(--panel-strong);
  border-radius: 12px;
  padding: 12px 14px;
  transition: box-shadow .2s ease, border-color .2s ease;
}
input::placeholder { color: var(--txt-dim); }
input:focus { border-color: var(--brand); box-shadow: 0 0 0 4px var(--ring); }

/* --------- Progress Bar ---------- */
.progress-bar {
  height: 12px;
  background: color-mix(in oklab, var(--panel), transparent 30%);
  border-radius: 999px;
  overflow: hidden;
  margin-top: 16px;
  border: 1px solid var(--panel-strong);
}
.progress-bar > div {
  height: 100%;
  width: 0;
  background: linear-gradient(90deg, var(--good), var(--brand));
  transition: width .35s ease;
}

/* --------- Lives ---------- */
#livesContainer {
  font-size: 1.4rem;
  letter-spacing: 6px;
  color: var(--accent);
}

/* --------- Cards (learn/mistakes) ---------- */
.word-card {
  background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
  border: 1px solid var(--panel-strong);
  border-radius: 12px;
  padding: 12px 16px;
  transition: transform .12s ease, border-color .2s ease;
}
.word-card:hover { transform: translateY(-2px); border-color: var(--panel); }

/* --------- Category cards ---------- */
.category-list { display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; }
.category-card {
  width: 190px;
  text-align: center;
  border: 1px solid var(--panel-strong);
  border-radius: 14px;
  padding: 18px;
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  transition: transform .12s ease, border-color .2s ease, background .2s ease;
  cursor: pointer;
}
.category-card:hover {
  transform: translateY(-2px);
  border-color: var(--panel);
  background: linear-gradient(180deg, rgba(255,255,255,0.1), rgba(255,255,255,0.03));
}

/* --------- Memory Game ---------- */
.memory-grid {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(110px, 1fr));
  gap: 14px;
}
.memory-card {
  height: 90px;
  display: grid; place-items: center;
  border-radius: 12px;
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  user-select: none;
  font-weight: 600;
  transition: transform .12s ease, background .2s ease, border-color .2s ease;
}
.memory-card.flipped { background: linear-gradient(180deg, var(--brand), var(--brand-2)); color: white; }
.memory-card.matched { background: linear-gradient(180deg, var(--good), var(--brand)); color: white; }
.memory-card:hover { transform: translateY(-2px); border-color: var(--panel); }

/* --------- Modal ---------- */
.profile-modal {
  position: fixed; inset: 0; z-index: 60;
  display: grid; place-items: center;
  background: rgba(0,0,0,0.45);
  padding: 20px;
}
.profile-card-header { display: flex; align-items: center; justify-content: space-between; gap: 12px; }
.profile-section {
  background: linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
  border: 1px solid var(--panel-strong);
  border-radius: 12px;
  padding: 14px;
  margin: 12px 0;
}
.stat-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px,1fr)); gap: 12px; }
.stat { text-align: center; border: 1px solid var(--panel-strong); border-radius: 12px; padding: 12px; background: rgba(255,255,255,0.04); }

/* --------- Tables (Irregular Verbs) ---------- */
.table, #irregularTable { width: 100%; border-collapse: collapse; }
.table th, .table td, #irregularTable th, #irregularTable td {
  border: 1px solid var(--panel-strong);
  padding: 10px 12px;
}
.table th, #irregularTable th {
  background: linear-gradient(180deg, var(--brand), var(--brand-2));
  color: white;
}

/* --------- Footer ---------- */
footer {
  margin-top: auto;
  text-align: center;
  padding: 16px;
  color: var(--txt-dim);
  background: color-mix(in oklab, var(--bg) 92%, transparent);
  border-top: 1px solid var(--panel-strong);
}

/* --------- Utilities ---------- */
.hidden { display: none !important; }

/* --------- Responsive ---------- */
@media (max-width: 640px) {
  header { grid-template-columns: 1fr; gap: 8px; }
  header h1 { text-align: center; }
  .btn { width: 100%; }
  .options { grid-template-columns: 1fr; }
  .category-card { width: 100%; }
}

/* Fun micro-animations for icons */
.btn img.icon { transition: transform .2s ease; }
.btn:hover img.icon { transform: scale(1.07) rotate(-3deg); }

</style>
<style>
/* ===== Hotfix 2025-08-14: Profile opacity + spacing ===== */
.profile-modal{background:rgba(0,0,0,0.65)!important;}
.profile-card{
  background: linear-gradient(180deg, rgba(255,255,255,0.22), rgba(255,255,255,0.15)) !important;
  border: 1px solid var(--panel-strong);
  border-radius: var(--radius-l);
  padding: clamp(22px, 2.4vw, 32px) !important;
  box-shadow: 0 24px 60px rgba(0,0,0,0.35);
}
body.dark .profile-card{
  background: linear-gradient(180deg, rgba(20,24,36,0.6), rgba(20,24,36,0.45)) !important;
}
.profile-section{
  background: linear-gradient(180deg, rgba(255,255,255,0.14), rgba(255,255,255,0.08)) !important;
  padding: 16px 18px !important;
  margin: 16px 0 !important;
  border-radius: 14px;
}
.stat-grid{gap:16px !important;}
.stat{padding:14px !important;}
/* General layout breathing room */
.container{padding: clamp(22px, 2.6vw, 40px) !important;}
main{gap: 28px !important;}
.question{margin-bottom: 14px !important;}
.options{gap: 16px !important; margin-top: 12px !important;}
.option{padding: 16px 18px !important;}
.category-list{gap: 16px !important;}
.category-card{padding: 20px !important;}
.word-card{padding: 14px 18px !important; margin: 6px 0 !important;}
/* Controls */
input[type="text"], select{padding: 12px 16px !important;}
.progress-bar{margin-top: 20px !important;}
/* Buttons in rows shouldn't touch each other */
.btn{margin: 2px 4px !important;}
/* Modal close button ensure above overlay */
.profile-modal .btn-close, .profile-modal [data-close]{position: relative; z-index: 2;}
</style>
<style>
/* ===== Hotfix v2: kill excessive transparency (start screen + profile + cards) ===== */

/* Start screen must be fully opaque */
#startScreen{
  background: linear-gradient(180deg, var(--bg-soft), var(--bg)) !important;
  -webkit-backdrop-filter: none !important;
  backdrop-filter: none !important;
}

/* App cards/containers more solid so content never washes out */
body:not(.dark) .container{ background: #ffffff !important; }
body.dark .container{ background: #0f1630 !important; }

/* Profile modal overlay darker */
.profile-modal{
  background: rgba(0,0,0,0.78) !important; /* was .45 then .65 */
}

/* Profile card totally solid per theme to avoid bleed-through */
body:not(.dark) .profile-card{
  background: #ffffff !important;
  box-shadow: 0 28px 70px rgba(0,0,0,0.35) !important;
}
body.dark .profile-card{
  background: #12192f !important;
  box-shadow: 0 28px 70px rgba(0,0,0,0.6) !important;
}

/* Profile sections more solid */
body:not(.dark) .profile-section{ background: #f4f6fb !important; }
body.dark .profile-section{ background: #18213d !important; }

/* Buttons & tiles keep spacing and readability */
.btn{ margin: 4px 6px !important; }
.options{ gap: 18px !important; }
.category-list{ gap: 18px !important; }

/* Ensure modal content sits above any backdrop blur layers */
.profile-modal .profile-card{ position: relative; z-index: 1; }

/* Increase base text contrast for cards */
.container, .profile-card, .profile-section{ color: var(--txt) !important; }
</style>
<style>
/* ===== Enhancement v3: modern profile buttons + mobile header toggle ===== */

/* Profile action buttons ‚Äî modern look */
.profile-card button {
  appearance: none;
  border: 1px solid color-mix(in oklab, var(--brand) 55%, black 15%);
  background: linear-gradient(180deg, var(--brand), var(--brand-2));
  color: #fff;
  padding: 10px 14px;
  border-radius: 12px;
  font-weight: 600;
  cursor: pointer;
  box-shadow: 0 10px 24px rgba(0,0,0,0.15);
  transition: transform .12s ease, filter .2s ease, box-shadow .2s ease;
  margin: 6px 8px 6px 0;
}
.profile-card button:hover { transform: translateY(-1px); filter: brightness(1.06); }
.profile-card button:active { transform: translateY(0); filter: brightness(.96); }

/* Make a 'danger' style for the second button (e.g., Clear history) */
.profile-card button:nth-of-type(2) {
  border-color: color-mix(in oklab, var(--danger) 65%, black 10%);
  background: linear-gradient(180deg, #ff6a6a, #e9426d);
}

/* Optional small variant (if any) */
.profile-card .btn, .profile-card .btn-small { padding: 10px 14px; border-radius: 12px; }

/* Header mobile menu */
#navToggle {
  display: none;
  border: 1px solid var(--panel-strong);
  background: linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
  color: var(--txt);
  border-radius: 10px;
  padding: 8px 10px;
  cursor: pointer;
}
#navToggle:focus-visible { box-shadow: 0 0 0 3px var(--ring); }

.header-actions {
  display: flex;
  gap: 8px;
  align-items: center;
}

@media (max-width: 768px) {
  header { position: sticky; top: 0; }
  #navToggle { display: inline-flex; align-items: center; gap: 8px; }
  .header-actions {
    display: none;
    position: absolute;
    top: 100%;
    right: 16px;
    left: 16px;
    padding: 12px;
    border: 1px solid var(--panel-strong);
    border-radius: 14px;
    background: color-mix(in oklab, var(--bg) 92%, transparent);
    -webkit-backdrop-filter: var(--blur);
    backdrop-filter: var(--blur);
    box-shadow: 0 16px 40px rgba(0,0,0,.35);
    flex-wrap: wrap;
    z-index: 45;
  }
  header.open .header-actions { display: flex; }
}
</style>
<style>
/* ===== Hotfix v4: dark theme select dropdown ===== */
body.dark select {
  background-color: #1a2238 !important;
  color: #f0f2f8 !important;
  border: 1px solid var(--panel-strong) !important;
}
body.dark select option {
  background-color: #1a2238 !important;
  color: #f0f2f8 !important;
}
</style>
</head>
<body>
  <!-- Start Screen -->
  <div id="startScreen">
    <!-- Updated game name and description for LexiVerse -->
    <h1 id="startTitle">LexiVerse</h1>
    <p id="startDesc">–ü–æ—Ä–∏–Ω—å—Ç–µ —É —Å–≤—ñ—Ç –ø—Ä–∏–≥–æ–¥ —É –Ω–∞–≤—á–∞–Ω–Ω—ñ –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—ó –º–æ–≤–∏ —Ä–∞–∑–æ–º –∑ LexiVerse!</p>
    <!-- The start button hides the start screen directly via inline JavaScript. Using
         `this.parentElement.style.display='none'` ensures that the overlay disappears even
         if the external script fails to load. The button now contains an image icon from a free icon library. -->
    <button class="btn btn-large" id="startBtn" onclick="this.parentElement.style.display='none'">
      <img class="icon" src="https://img.icons8.com/color/48/play.png" alt="" />
      <span id="startBtnText">–ü–æ—á–∞—Ç–∏</span>
    </button>
  </div>

  <header>
    <!-- Updated header with new game name -->
    <h1 id="title">LexiVerse</h1>
    <button class="language-toggle" id="languageToggle">UA / EN</button>
    <button class="language-toggle" id="themeToggle">üåô</button>
    <!-- Hidden file input for top import button -->
    <input type="file" id="importFileTop" accept=".csv" style="display:none" onchange="importWords(event)" />
    <!-- Import words button placed in the header -->
    <button class="language-toggle" id="importTopBtn" onclick="document.getElementById('importFileTop').click()" style="margin-left:10px;">
      <img class="icon" src="https://img.icons8.com/color/48/upload.png" alt="" />
      <span id="importTopText">–Ü–º–ø–æ—Ä—Ç —Å–ª—ñ–≤</span>
    </button>
    <!-- Profile button to open user stats modal -->
    <button class="language-toggle" id="profileBtnTop" onclick="openProfile()" style="margin-left:10px;">
      <img class="icon" src="https://img.icons8.com/color/48/user.png" alt="" />
      <span id="profileTopText">–ü—Ä–æ—Ñ—ñ–ª—å</span>
    </button>

    <!-- Reset data button for clearing local storage -->
    <button class="language-toggle" id="resetBtn" onclick="resetData()" style="margin-left:10px;">
      <img class="icon" src="https://img.icons8.com/color/48/refresh.png" alt="" />
      <span id="resetBtnText">–°–∫–∏–Ω—É—Ç–∏</span>
    </button>
  </header>
  <main>
    
    <!-- Profile Modal -->
    <div id="profileModal" class="profile-modal hidden" aria-modal="true" role="dialog">
      <div class="profile-card" role="document">
        <div class="profile-card-header">
          <h2 id="profileTitle">–ü—Ä–æ—Ñ—ñ–ª—å</h2>
          <button class="language-toggle" onclick="closeProfile()" id="profileCloseBtn">‚úï</button>
        </div>
        <div class="profile-actions">
          <button class="language-toggle" onclick="exportHistoryCSV()" id="profileExportBtn">–ï–∫—Å–ø–æ—Ä—Ç CSV</button>
          <button class="language-toggle" onclick="clearHistoryData()" id="profileClearBtn">–û—á–∏—Å—Ç–∏—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é</button>
        </div>
        <div class="profile-section">
          <h3 id="profileSummaryTitle">–ó–≤–µ–¥–µ–Ω–Ω—è</h3>
          <div id="profileSummary"></div>
        </div>
        <div class="profile-section">
          <h3 id="profileByLevelTitle">–ó–∞ —Ä—ñ–≤–Ω—è–º–∏</h3>
          <div id="profileByLevel"></div>
        </div>
        <div class="profile-section">
          <h3 id="profileByModeTitle">–ó–∞ —ñ–≥—Ä–∞–º–∏</h3>
          <div id="profileByMode"></div>
        </div>
        <div class="profile-section">
          <h3 id="profileRecentTitle">–û—Å—Ç–∞–Ω–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏</h3>
          <div id="profileRecent"></div>
        </div>
      </div>
    </div>
<!-- Home Screen -->
    <div class="container" id="homeScreen">
      <div class="center">
        <h2 id="homeTitle">–í–∏–±–µ—Ä—ñ—Ç—å —Ä—ñ–≤–µ–Ω—å</h2>
        <!-- Updated home description to use the new game name -->
        <p id="homeDesc">LexiVerse –¥–æ–ø–æ–º–æ–∂–µ –≤–∞–º –≤–∏–≤—á–∏—Ç–∏ –∞–Ω–≥–ª—ñ–π—Å—å–∫—É –º–æ–≤—É, –≥—Ä–∞—é—á–∏. –û–±–µ—Ä—ñ—Ç—å —Ä—ñ–≤–µ–Ω—å —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ –∞–±–æ –æ–∑–Ω–∞–π–æ–º—Ç–µ—Å—å –∑ —É—Å—ñ–º–∞ —Å–ª–æ–≤–∞–º–∏.</p>
        <!-- Greeting and stats for user -->
        <p id="greeting" style="font-weight:600; margin-top:10px;"></p>
        <p id="stats" style="margin-top:5px;"></p>
        <!-- Button for setting the player's name -->
        <button class="btn btn-secondary" id="setNameBtn" onclick="promptName()" style="margin-bottom:15px;">
          <img class="icon" src="https://img.icons8.com/color/48/user.png" alt="" />
          <span id="setNameText"></span>
        </button>
        <!-- Level selection buttons with colourful icons -->
        <button class="btn" onclick="goToLevel('beginner')">
          <img class="icon" src="https://img.icons8.com/color/48/star.png" alt="" />
          <span id="beginnerBtn">–ü–æ—á–∞—Ç–∫—ñ–≤–µ—Ü—å</span>
        </button>
        <button class="btn btn-secondary" onclick="goToLevel('intermediate')">
          <img class="icon" src="https://img.icons8.com/color/48/graduation-cap.png" alt="" />
          <span id="intermediateBtn">–°–µ—Ä–µ–¥–Ω—ñ–π</span>
        </button>
        <button class="btn" onclick="goToLevel('advanced')">
          <img class="icon" src="https://img.icons8.com/color/48/rocket.png" alt="" />
          <span id="advancedBtn">–ü—Ä–æ—Å—É–Ω—É—Ç–∏–π</span>
        </button>
        <br />
        <!-- Learning and other modes -->
        <button class="btn" onclick="openLearn()">
          <img class="icon" src="https://img.icons8.com/color/48/book.png" alt="" />
          <span id="learnBtn">–ù–∞–≤—á–∞–Ω–Ω—è</span>
        </button>
        <button class="btn btn-secondary hidden" id="mistakesBtn" onclick="openMistakes()">
          <img class="icon" src="https://img.icons8.com/color/48/cancel.png" alt="" />
          <span id="mistakesText">–ü–æ–º–∏–ª–∫–∏</span>
        </button>
        <button class="btn" onclick="openMemory()">
          <img class="icon" src="https://img.icons8.com/color/48/brain.png" alt="" />
          <span id="memoryBtn">–ü–∞–º'—è—Ç—å</span>
        </button>

        <!-- Additional modes -->
        <button class="btn" onclick="goListening()" id="listeningBtn">
          <img class="icon" src="https://img.icons8.com/color/48/headphones.png" alt="" />
          <span id="listeningBtnText">–ê—É–¥—ñ—é–≤–∞–Ω–Ω—è</span>
        </button>
        <button class="btn" onclick="startHangman()" id="hangmanBtn">
          <!-- Use a colourful skull icon from Icons8 for Hangman -->
          <img class="icon" src="https://img.icons8.com/color/48/skull.png" alt="" />
          <span id="hangmanBtnText">–í–∏—Å–µ–ª–∏—Ü—ñ</span>
        </button>

        <!-- True/False mini‚Äëgame button -->
        <button class="btn" onclick="goTrueFalse()" id="tfBtn">
          <img class="icon" src="https://img.icons8.com/color/48/checked--v1.png" alt="" />
          <span id="tfBtnText">–ü—Ä–∞–≤–¥–∞/–ù–µ–ø—Ä–∞–≤–¥–∞</span>
        </button>
        <!-- Anagram mini‚Äëgame button -->
        <button class="btn" onclick="goAnagram()" id="anagramBtn">
          <img class="icon" src="https://img.icons8.com/color/48/puzzle.png" alt="" />
          <span id="anagramBtnText">–ê–Ω–∞–≥—Ä–∞–º–∏</span>
        </button>
        <!-- Irregular verbs table button -->
        <button class="btn" onclick="openIrregular()" id="irregularBtn">
          <!-- Use a different book icon for irregular verbs to ensure it loads correctly -->
          <img class="icon" src="https://img.icons8.com/color/48/open-book.png" alt="" />
          <span id="irregularBtnText">–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ñ –¥—ñ—î—Å–ª–æ–≤–∞</span>
        </button>
        <!-- Hidden file input for importing custom words -->
        <!-- Hide the old import button since import is now handled in the header -->
        <input type="file" id="importFile" accept=".csv" style="display:none" onchange="importWords(event)" />
        <button class="btn hidden" onclick="document.getElementById('importFile').click()">
          <img class="icon" src="https://img.icons8.com/color/48/upload.png" alt="" />
          <span id="importBtn">–Ü–º–ø–æ—Ä—Ç —Å–ª—ñ–≤</span>
        </button>
        <button class="btn hidden" id="customBtn" onclick="goToLevel('custom')">
          <img class="icon" src="https://img.icons8.com/color/48/list.png" alt="" />
          <span id="customBtnText">–ö–æ—Ä–∏—Å—Ç—É–≤–∞—Ü—å–∫—ñ —Å–ª–æ–≤–∞</span>
        </button>
      
      <div class="toggle" style="display:inline-flex;align-items:center;gap:8px;">
        <label id="voiceLabel" for="voiceSelect" style="font-size:12px;">Voice</label>
        <select id="voiceSelect" aria-label="TTS Voice"></select>
      </div>
      <div class="toggle" style="display:inline-flex;align-items:center;gap:8px;">
        <label id="rateLabel" for="rateRange" style="font-size:12px;">Rate</label>
        <input id="rateRange" type="range" min="0.7" max="1.3" value="1" step="0.05" style="width:90px;">
      </div>
    </div>
    </div>
    <!-- Learn Screen -->
    <div class="container hidden" id="learnScreen">
      <div class="center">
        <h2 id="learnTitle">–ù–∞–≤—á–∞–Ω–Ω—è</h2>
        <p id="learnDesc">–û–±–µ—Ä—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –∞–±–æ —à—É–∫–∞–π—Ç–µ —Å–ª–æ–≤–æ</p>
        <div class="search-bar">
          <input type="text" id="searchInput" placeholder="–ü–æ—à—É–∫..." oninput="filterWords()" />
        </div>
        <div class="category-list" id="categoryList">
          <div class="category-card" onclick="selectCategory('beginner')" id="catBeginner">–ü–æ—á–∞—Ç–∫–æ–≤–∏–π</div>
          <div class="category-card" onclick="selectCategory('intermediate')" id="catIntermediate">–°–µ—Ä–µ–¥–Ω—ñ–π</div>
          <div class="category-card" onclick="selectCategory('advanced')" id="catAdvanced">–ü—Ä–æ—Å—É–Ω—É—Ç–∏–π</div>
          <div class="category-card" onclick="selectCategory('all')" id="catAll">–£—Å—ñ —Å–ª–æ–≤–∞</div>
        </div>
        <div id="learnWordsList"></div>
        <button class="btn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="backBtn">–ù–∞–∑–∞–¥</span>
        </button>
      </div>
    </div>
    <!-- Mistakes Screen -->
    <div class="container hidden" id="mistakesScreen">
      <div class="center">
        <h2 id="mistakesTitle">–ü–æ–º–∏–ª–∫–∏</h2>
        <p id="mistakesDesc">–°–ª–æ–≤–∞, –Ω–∞ —è–∫—ñ –≤–∏ –≤—ñ–¥–ø–æ–≤—ñ–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ü–æ–≤—Ç–æ—Ä—é–π—Ç–µ —ó—Ö –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –∑–∞–ø–∞–º'—è—Ç–æ–≤—É–≤–∞–Ω–Ω—è.</p>
        <div id="mistakesList"></div>
        <button class="btn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="backBtn2">–ù–∞–∑–∞–¥</span>
        </button>
      </div>
    </div>

    <!-- Memory Game Screen -->
    <div class="container hidden" id="memoryScreen">
      <div class="center">
        <h2 id="memoryTitle">–ì—Ä–∞ –ø–∞–º'—è—Ç—å</h2>
        <p id="memoryDesc">–ó–Ω–∞–π–¥—ñ—Ç—å –ø–∞—Ä–∏ –∞–Ω–≥–ª—ñ–π—Å—å–∫–∏—Ö —Å–ª—ñ–≤ —Ç–∞ —ó—Ö –ø–µ—Ä–µ–∫–ª–∞–¥–∏.</p>
        <div id="memoryGrid" class="memory-grid"></div>
        <button class="btn" id="memoryStartBtn" onclick="startMemoryGame()">
          <img class="icon" src="https://img.icons8.com/color/48/play.png" alt="" />
          <span id="memoryStartBtnText">–ü–æ—á–∞—Ç–∏ –≥—Ä—É</span>
        </button>
        <button class="btn" id="memoryBackBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="memoryBackBtnText">–ù–∞–∑–∞–¥</span>
        </button>
      </div>
    </div>
    <!-- Game Screen -->
    <div class="container hidden" id="gameScreen">
      <div class="center">
        <h2 id="levelTitle"></h2>
        <div id="livesContainer" style="text-align:center; margin-bottom:10px;"></div>
        <div class="question" id="questionText"></div>
        <!-- Audio pronunciation button will be injected here -->
        <div id="audioContainer" style="margin-bottom: 10px;"></div>
        <div class="options" id="optionsContainer"></div>
        <input id="answerInput" class="hidden" type="text" autocomplete="off" />
        <button class="btn hidden" id="submitBtn" onclick="submitAnswer()"></button>
        <div class="progress-bar"><div id="progressBarFill"></div></div>
        <button class="btn btn-secondary" id="quitBtn" onclick="quitGame()" style="margin-top:15px;">
          <img class="icon" src="https://img.icons8.com/color/48/logout-rounded-left.png" alt="" />
          <span id="quitBtnText"></span>
        </button>
      </div>
    </div>
    <!-- Result Screen -->
    <div class="container hidden" id="resultScreen">
      <div class="center">
        <h2 id="resultTitle"></h2>
        <div class="result" id="scoreText"></div>
        <div id="wrongWordsSection"></div>
        <button class="btn" onclick="restart()">
          <img class="icon" src="https://img.icons8.com/color/48/home.png" alt="" />
          <span id="restartBtn">–ù–∞ –≥–æ–ª–æ–≤–Ω—É</span>
        </button>
      </div>
    </div>

    <!-- Hangman Screen -->
    <div class="container hidden" id="hangmanScreen">
      <div class="center">
        <h2 id="hangmanTitle">Hangman</h2>
        <p id="hangmanDesc">Guess the English word letter by letter.</p>
        <p id="hangmanHint" style="font-style: italic;"></p>
        <div id="hangmanLives" style="margin:10px; font-size:1.4rem; color: var(--accent-color);"></div>
        <div id="hangmanDisplay" style="font-size:2rem; letter-spacing:8px; margin:20px 0;"></div>
        <div id="hangmanWrongLetters" style="margin-bottom:10px; color: var(--secondary-color);"></div>
        <input type="text" id="hangmanInput" maxlength="1" style="width:60px; padding:8px; text-align:center; font-size:1.2rem;" />
        <br/>
        <button class="btn" id="hangmanSubmitBtn" onclick="guessHangmanLetter()">Guess</button>
        <button class="btn" id="hangmanRestartBtn" onclick="startHangman()">Restart</button>
        <button class="btn btn-secondary" id="hangmanBackBtn" onclick="backToHome()">Back</button>
      </div>
    </div>

    <!-- True/False Game Screen -->
    <div class="container hidden" id="tfScreen">
      <div class="center">
        <h2 id="tfTitle">True/False Game</h2>
        <p id="tfDesc">Choose whether the translation is correct.</p>
        <div class="question" id="tfQuestion"></div>
        <div class="options" id="tfOptions" style="flex-direction: row; justify-content:center; gap:20px; margin-top:15px;">
          <button class="btn" id="tfTrueBtn" onclick="answerTF(true)">
            <img class="icon" src="https://img.icons8.com/color/48/checked--v1.png" alt="" />
            <span id="tfTrueBtnText">True</span>
          </button>
          <button class="btn btn-secondary" id="tfFalseBtn" onclick="answerTF(false)">
            <img class="icon" src="https://img.icons8.com/color/48/multiply.png" alt="" />
            <span id="tfFalseBtnText">False</span>
          </button>
        </div>
        <p id="tfProgress" style="margin-top:10px;"></p>
        <!-- Back button always visible to return to home from True/False game -->
        <button class="btn" id="tfBackBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="tfBackBtnText">–ù–∞–∑–∞–¥</span>
        </button>
        <!-- Finish button shown when game ends -->
        <button class="btn hidden" id="tfFinishBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="tfFinishBtnText">Back</span>
        </button>
      </div>
    </div>

    <!-- Anagram Game Screen -->
    <div class="container hidden" id="anagramScreen">
      <div class="center">
        <h2 id="anagramTitle">–ê–Ω–∞–≥—Ä–∞–º–∞</h2>
        <p id="anagramDesc">–†–æ–∑—à–∏—Ñ—Ä—É–π—Ç–µ –∞–Ω–≥–ª—ñ–π—Å—å–∫–µ —Å–ª–æ–≤–æ –∑–∞ –π–æ–≥–æ –ø–µ—Ä–µ–∫–ª–∞–¥–æ–º.</p>
        <div class="question" id="anagramQuestion"></div>
        <input type="text" id="anagramInput" autocomplete="off" style="padding: 10px; font-size:1rem; border:2px solid var(--primary-color); border-radius:8px;" />
        <div style="margin-top:15px;">
          <button class="btn" id="anagramSubmitBtn" onclick="submitAnagram()">–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏</button>
        </div>
        <p id="anagramProgress" style="margin-top:10px;"></p>
        <!-- Back button always visible to return to home from Anagram game -->
        <button class="btn" id="anagramBackBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="anagramBackBtnText">–ù–∞–∑–∞–¥</span>
        </button>
        <!-- Finish button shown when game ends -->
        <button class="btn hidden" id="anagramFinishBtn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="anagramFinishBtnText">–ù–∞–∑–∞–¥</span>
        </button>
      </div>
    </div>

    <!-- Irregular Verbs Screen -->
    <div class="container hidden" id="irregularScreen">
      <div class="center">
        <h2 id="irregularTitle">–¢–∞–±–ª–∏—Ü—è –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –¥—ñ—î—Å–ª—ñ–≤</h2>
        <p id="irregularDesc">–ü–æ–≤–Ω–∏–π —Å–ø–∏—Å–æ–∫ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –¥—ñ—î—Å–ª—ñ–≤ —Ç–∞ —ó—Ö–Ω—ñ —Ñ–æ—Ä–º–∏.</p>
        <div id="irregularTableContainer" style="overflow-x:auto; margin-top: 15px;">
          <table id="irregularTable" style="width:100%; border-collapse: collapse;">
            <!-- Table header and body will be generated dynamically -->
          </table>
        </div>
        <button class="btn" onclick="backToHome()">
          <img class="icon" src="https://img.icons8.com/color/48/back.png" alt="" />
          <span id="irregularBackBtn">–ù–∞–∑–∞–¥</span>
        </button>
      </div>
    </div>
  </main>
  <footer>
    <!-- Footer text will be localized via updateUI() using ui[currentLang].footer -->
    <p id="footerText">¬© 2025 Sashkin Apps. –£—Å—ñ –ø—Ä–∞–≤–∞ –∑–∞—Ö–∏—â–µ–Ω—ñ.</p>
  </footer>
  <script>
    /**
     * Remove trailing numeric suffixes from an English word. Some words in
     * the dataset have numeric suffixes added to increase the number of
     * entries; however, when displaying words to the user we do not want
     * these digits to appear. This helper returns the word without any
     * trailing digits.
     * @param {string} str - the English word, potentially with trailing digits
     * @returns {string} the word with trailing digits removed
     */
    function stripDigits(str) {
      return str ? str.replace(/\d+$/, '') : str;
    }
    /* Vocabulary data for the game */
    const beginnerWords = [
      { en: 'hello', uk: '–ø—Ä–∏–≤—ñ—Ç' },
      { en: 'goodbye', uk: '–¥–æ –ø–æ–±–∞—á–µ–Ω–Ω—è' },
      { en: 'please', uk: '–±—É–¥—å –ª–∞—Å–∫–∞' },
      { en: 'thank you', uk: '–¥—è–∫—É—é' },
      { en: 'yes', uk: '—Ç–∞–∫' },
      { en: 'no', uk: '–Ω—ñ' },
      { en: 'I', uk: '—è' },
      { en: 'you', uk: '—Ç–∏' },
      { en: 'he', uk: '–≤—ñ–Ω' },
      { en: 'she', uk: '–≤–æ–Ω–∞' },
      { en: 'we', uk: '–º–∏' },
      { en: 'they', uk: '–≤–æ–Ω–∏' },
      { en: 'one', uk: '–æ–¥–∏–Ω' },
      { en: 'two', uk: '–¥–≤–∞' },
      { en: 'three', uk: '—Ç—Ä–∏' },
      { en: 'four', uk: '—á–æ—Ç–∏—Ä–∏' },
      { en: 'five', uk: "–ø'—è—Ç—å" },
      { en: 'six', uk: '—à—ñ—Å—Ç—å' },
      { en: 'seven', uk: '—Å—ñ–º' },
      { en: 'eight', uk: '–≤—ñ—Å—ñ–º' },
      { en: 'nine', uk: "–¥–µ–≤'—è—Ç—å" },
      { en: 'ten', uk: '–¥–µ—Å—è—Ç—å' },
      { en: 'red', uk: '—á–µ—Ä–≤–æ–Ω–∏–π' },
      { en: 'blue', uk: '—Å–∏–Ω—ñ–π' },
      { en: 'green', uk: '–∑–µ–ª–µ–Ω–∏–π' },
      { en: 'black', uk: '—á–æ—Ä–Ω–∏–π' },
      { en: 'white', uk: '–±—ñ–ª–∏–π' },
      { en: 'cat', uk: '–∫—ñ—Ç' },
      { en: 'dog', uk: '—Å–æ–±–∞–∫–∞' },
      { en: 'bird', uk: '–ø—Ç–∞—Ö' },
      { en: 'fish', uk: '—Ä–∏–±–∞' },
      { en: 'apple', uk: '—è–±–ª—É–∫–æ' },
      { en: 'banana', uk: '–±–∞–Ω–∞–Ω' },
      { en: 'orange', uk: '–∞–ø–µ–ª—å—Å–∏–Ω' },
      { en: 'lemon', uk: '–ª–∏–º–æ–Ω' },
      { en: 'bread', uk: '—Ö–ª—ñ–±' },
      { en: 'water', uk: '–≤–æ–¥–∞' },
      { en: 'milk', uk: '–º–æ–ª–æ–∫–æ' },
      { en: 'tea', uk: '—á–∞–π' },
      { en: 'coffee', uk: '–∫–∞–≤–∞' },
      { en: 'eat', uk: '—ó—Å—Ç–∏' },
      { en: 'drink', uk: '–ø–∏—Ç–∏' },
      { en: 'sleep', uk: '—Å–ø–∞—Ç–∏' },
      { en: 'go', uk: '–π—Ç–∏' },
      { en: 'come', uk: '–ø—Ä–∏—Ö–æ–¥–∏—Ç–∏' },
      { en: 'house', uk: '–±—É–¥–∏–Ω–æ–∫' },
      { en: 'school', uk: '—à–∫–æ–ª–∞' },
      { en: 'car', uk: '–º–∞—à–∏–Ω–∞' },
      { en: 'book', uk: '–∫–Ω–∏–≥–∞' },
      { en: 'good', uk: '—Ö–æ—Ä–æ—à–∏–π' },
      { en: 'bad', uk: '–ø–æ–≥–∞–Ω–∏–π' },
      { en: 'big', uk: '–≤–µ–ª–∏–∫–∏–π' },
      { en: 'small', uk: '–º–∞–ª–µ–Ω—å–∫–∏–π' }
    ];
    const intermediateWords = [
      { en: 'write', uk: '–ø–∏—Å–∞—Ç–∏' },
      { en: 'read', uk: '—á–∏—Ç–∞—Ç–∏' },
      { en: 'speak', uk: '–≥–æ–≤–æ—Ä–∏—Ç–∏' },
      { en: 'listen', uk: '—Å–ª—É—Ö–∞—Ç–∏' },
      { en: 'see', uk: '–±–∞—á–∏—Ç–∏' },
      { en: 'hear', uk: '—á—É—Ç–∏' },
      { en: 'give', uk: '–¥–∞–≤–∞—Ç–∏' },
      { en: 'take', uk: '–±—Ä–∞—Ç–∏' },
      { en: 'make', uk: '—Ä–æ–±–∏—Ç–∏' },
      { en: 'think', uk: '–¥—É–º–∞—Ç–∏' },
      { en: 'know', uk: '–∑–Ω–∞—Ç–∏' },
      { en: 'want', uk: '—Ö–æ—Ç—ñ—Ç–∏' },
      { en: 'like', uk: '–ø–æ–¥–æ–±–∞—Ç–∏—Å—å' },
      { en: 'love', uk: '–ª—é–±–∏—Ç–∏' },
      { en: 'hate', uk: '–Ω–µ–Ω–∞–≤–∏–¥—ñ—Ç–∏' },
      { en: 'buy', uk: '–∫—É–ø—É–≤–∞—Ç–∏' },
      { en: 'sell', uk: '–ø—Ä–æ–¥–∞–≤–∞—Ç–∏' },
      { en: 'pay', uk: '–ø–ª–∞—Ç–∏—Ç–∏' },
      { en: 'learn', uk: '–≤—á–∏—Ç–∏' },
      { en: 'teach', uk: '–Ω–∞–≤—á–∞—Ç–∏' },
      { en: 'help', uk: '–¥–æ–ø–æ–º–∞–≥–∞—Ç–∏' },
      { en: 'need', uk: '–ø–æ—Ç—Ä–µ–±—É–≤–∞—Ç–∏' },
      { en: 'find', uk: '–∑–Ω–∞—Ö–æ–¥–∏—Ç–∏' },
      { en: 'meet', uk: '–∑—É—Å—Ç—Ä—ñ—á–∞—Ç–∏' },
      { en: 'build', uk: '–±—É–¥—É–≤–∞—Ç–∏' },
      { en: 'job', uk: '—Ä–æ–±–æ—Ç–∞' },
      { en: 'bus', uk: '–∞–≤—Ç–æ–±—É—Å' },
      { en: 'train', uk: '–ø–æ—Ç—è–≥' },
      { en: 'city', uk: '–º—ñ—Å—Ç–æ' },
      { en: 'country', uk: '–∫—Ä–∞—ó–Ω–∞' },
      { en: 'day', uk: '–¥–µ–Ω—å' },
      { en: 'night', uk: '–Ω—ñ—á' },
      { en: 'morning', uk: '—Ä–∞–Ω–æ–∫' },
      { en: 'evening', uk: '–≤–µ—á—ñ—Ä' },
      { en: 'week', uk: '—Ç–∏–∂–¥–µ–Ω—å' },
      { en: 'month', uk: '–º—ñ—Å—è—Ü—å' },
      { en: 'year', uk: '—Ä—ñ–∫' },
      { en: 'time', uk: '—á–∞—Å' },
      { en: 'friend', uk: '–¥—Ä—É–≥' },
      { en: 'family', uk: '—Ä–æ–¥–∏–Ω–∞' },
      { en: 'mother', uk: '–º–∞—Ç–∏' },
      { en: 'father', uk: '–±–∞—Ç—å–∫–æ' },
      { en: 'brother', uk: '–±—Ä–∞—Ç' },
      { en: 'sister', uk: '—Å–µ—Å—Ç—Ä–∞' },
      { en: 'son', uk: '—Å–∏–Ω' },
      { en: 'daughter', uk: '–¥–æ—á–∫–∞' },
      { en: 'husband', uk: '—á–æ–ª–æ–≤—ñ–∫' },
      { en: 'wife', uk: '–¥—Ä—É–∂–∏–Ω–∞' },
      { en: 'old', uk: '—Å—Ç–∞—Ä–∏–π' },
      { en: 'young', uk: '–º–æ–ª–æ–¥–∏–π' },
      { en: 'new', uk: '–Ω–æ–≤–∏–π' },
      { en: 'high', uk: '–≤–∏—Å–æ–∫–∏–π' },
      { en: 'low', uk: '–Ω–∏–∑—å–∫–∏–π' },
      { en: 'hot', uk: '–≥–∞—Ä—è—á–∏–π' },
      { en: 'cold', uk: '—Ö–æ–ª–æ–¥–Ω–∏–π' },
      { en: 'warm', uk: '—Ç–µ–ø–ª–∏–π' },
      { en: 'cool', uk: '–ø—Ä–æ—Ö–æ–ª–æ–¥–Ω–∏–π' },
      { en: 'full', uk: '–ø–æ–≤–Ω–∏–π' },
      { en: 'empty', uk: '–ø–æ—Ä–æ–∂–Ω—ñ–π' },
      { en: 'strong', uk: '—Å–∏–ª—å–Ω–∏–π' },
      { en: 'weak', uk: '—Å–ª–∞–±–∫–∏–π' },
      { en: 'rich', uk: '–±–∞–≥–∞—Ç–∏–π' },
      { en: 'poor', uk: '–±—ñ–¥–Ω–∏–π' },
      { en: 'fast', uk: '—à–≤–∏–¥–∫–∏–π' },
      { en: 'slow', uk: '–ø–æ–≤—ñ–ª—å–Ω–∏–π' },
      { en: 'beautiful', uk: '–∫—Ä–∞—Å–∏–≤–∏–π' },
      { en: 'ugly', uk: '–ø–æ—Ç–≤–æ—Ä–Ω–∏–π' },
      { en: 'easy', uk: '–ª–µ–≥–∫–∏–π' },
      { en: 'difficult', uk: '—Å–∫–ª–∞–¥–Ω–∏–π' },
      { en: 'expensive', uk: '–¥–æ—Ä–æ–≥–∏–π' },
      { en: 'cheap', uk: '–¥–µ—à–µ–≤–∏–π' },
      { en: 'happy', uk: '—â–∞—Å–ª–∏–≤–∏–π' },
      { en: 'sad', uk: '—Å—É–º–Ω–∏–π' },
      { en: 'angry', uk: '—Å–µ—Ä–¥–∏—Ç–∏–π' },
      { en: 'hungry', uk: '–≥–æ–ª–æ–¥–Ω–∏–π' },
      { en: 'thirsty', uk: '—Å–ø—Ä–∞–≥–ª–∏–π' },
      { en: 'tired', uk: '–≤—Ç–æ–º–ª–µ–Ω–∏–π' },
      { en: 'busy', uk: '–∑–∞–π–Ω—è—Ç–∏–π' },
      { en: 'free', uk: '–≤—ñ–ª—å–Ω–∏–π' },
      { en: 'in', uk: '–≤' },
      { en: 'on', uk: '–Ω–∞' },
      { en: 'under', uk: '–ø—ñ–¥' },
      { en: 'between', uk: '–º—ñ–∂' },
      { en: 'behind', uk: '–∑–∞' },
      { en: 'front', uk: '–ø–µ—Ä–µ–¥' },
      { en: 'near', uk: '–ø–æ—Ä—É—á' },
      { en: 'around', uk: '–Ω–∞–≤–∫–æ–ª–æ' },
      { en: 'with', uk: '–∑' },
      { en: 'without', uk: '–±–µ–∑' },
      { en: 'always', uk: '–∑–∞–≤–∂–¥–∏' },
      { en: 'usually', uk: '–∑–∞–∑–≤–∏—á–∞–π' },
      { en: 'often', uk: '—á–∞—Å—Ç–æ' },
      { en: 'sometimes', uk: '—ñ–Ω–æ–¥—ñ' },
      { en: 'never', uk: '–Ω—ñ–∫–æ–ª–∏' },
      { en: 'here', uk: '—Ç—É—Ç' },
      { en: 'there', uk: '—Ç–∞–º' },
      { en: 'now', uk: '–∑–∞—Ä–∞–∑' },
      { en: 'then', uk: '—Ç–æ–¥—ñ' },
      { en: 'soon', uk: '—Å–∫–æ—Ä–æ' },
      { en: 'today', uk: '—Å—å–æ–≥–æ–¥–Ω—ñ' },
      { en: 'tomorrow', uk: '–∑–∞–≤—Ç—Ä–∞' },
      { en: 'yesterday', uk: '–≤—á–æ—Ä–∞' },
      { en: 'early', uk: '—Ä–∞–Ω–æ' },
      { en: 'late', uk: '–ø—ñ–∑–Ω–æ' },
      { en: 'quickly', uk: '—à–≤–∏–¥–∫–æ' },
      { en: 'slowly', uk: '–ø–æ–≤—ñ–ª—å–Ω–æ' },
      { en: 'well', uk: '–¥–æ–±—Ä–µ' },
      { en: 'badly', uk: '–ø–æ–≥–∞–Ω–æ' },
      { en: 'quietly', uk: '—Ç–∏—Ö–æ' },
      { en: 'loudly', uk: '–≥–æ–ª–æ—Å–Ω–æ' },
      { en: 'my', uk: '–º—ñ–π' },
      { en: 'your', uk: '—Ç–≤—ñ–π' },
      { en: 'his', uk: '–π–æ–≥–æ' },
      { en: 'her', uk: '—ó—ó' },
      { en: 'our', uk: '–Ω–∞—à' },
      { en: 'their', uk: '—ó—Ö–Ω—ñ–π' },
      { en: 'this', uk: '—Ü–µ–π' },
      { en: 'that', uk: '—Ç–æ–π' },
      { en: 'these', uk: '—Ü—ñ' },
      { en: 'those', uk: '—Ç—ñ' },
      { en: 'something', uk: '—â–æ—Å—å' },
      { en: 'nothing', uk: '–Ω—ñ—á–æ–≥–æ' },
      { en: 'everyone', uk: '–∫–æ–∂–µ–Ω' },
      { en: 'no one', uk: '–Ω—ñ—Ö—Ç–æ' },
      { en: 'eleven', uk: '–æ–¥–∏–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'twelve', uk: '–¥–≤–∞–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'thirteen', uk: '—Ç—Ä–∏–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'fourteen', uk: '—á–æ—Ç–∏—Ä–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'fifteen', uk: "–ø'—è—Ç–Ω–∞–¥—Ü—è—Ç—å" },
      { en: 'sixteen', uk: '—à—ñ—Å—Ç–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'seventeen', uk: '—Å—ñ–º–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'eighteen', uk: '–≤—ñ—Å—ñ–º–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'nineteen', uk: '–¥–µ–≤\'—è—Ç–Ω–∞–¥—Ü—è—Ç—å' },
      { en: 'twenty', uk: '–¥–≤–∞–¥—Ü—è—Ç—å' }
    ];
    const advancedWords = [
      { en: 'who', uk: '—Ö—Ç–æ' },
      { en: 'what', uk: '—â–æ' },
      { en: 'where', uk: '–¥–µ' },
      { en: 'when', uk: '–∫–æ–ª–∏' },
      { en: 'why', uk: '—á–æ–º—É' },
      { en: 'how', uk: '—è–∫' },
      { en: 'which', uk: '—è–∫–∏–π' },
      { en: 'whose', uk: '—á–∏–π' },
      { en: 'some', uk: '–¥–µ—è–∫—ñ' },
      { en: 'any', uk: '–±—É–¥—å-—è–∫—ñ' },
      { en: 'bread', uk: '—Ö–ª—ñ–±' },
      { en: 'sugar', uk: '—Ü—É–∫–æ—Ä' },
      { en: 'salt', uk: '—Å—ñ–ª—å' },
      { en: 'pepper', uk: '–ø–µ—Ä–µ—Ü—å' },
      { en: 'egg', uk: '—è–π—Ü–µ' },
      { en: 'cheese', uk: '—Å–∏—Ä' },
      { en: 'butter', uk: '–º–∞—Å–ª–æ' },
      { en: 'rice', uk: '—Ä–∏—Å' },
      { en: 'potato', uk: '–∫–∞—Ä—Ç–æ–ø–ª—è' },
      { en: 'carrot', uk: '–º–æ—Ä–∫–≤–∞' },
      { en: 'onion', uk: '—Ü–∏–±—É–ª—è' },
      { en: 'garlic', uk: '—á–∞—Å–Ω–∏–∫' },
      { en: 'tomato', uk: '–ø–æ–º—ñ–¥–æ—Ä' },
      { en: 'cucumber', uk: '–æ–≥—ñ—Ä–æ–∫' },
      { en: 'lettuce', uk: '–ª–∞—Ç—É–∫' },
      { en: 'soup', uk: '—Å—É–ø' },
      { en: 'salad', uk: '—Å–∞–ª–∞—Ç' },
      { en: 'meat', uk: "–º'—è—Å–æ" },
      { en: 'fish', uk: '—Ä–∏–±–∞' },
      { en: 'chicken', uk: '–∫—É—Ä–∫–∞' },
      { en: 'coffee', uk: '–∫–∞–≤–∞' },
      { en: 'tea', uk: '—á–∞–π' },
      { en: 'Monday', uk: '–ø–æ–Ω–µ–¥—ñ–ª–æ–∫' },
      { en: 'Tuesday', uk: '–≤—ñ–≤—Ç–æ—Ä–æ–∫' },
      { en: 'Wednesday', uk: '—Å–µ—Ä–µ–¥–∞' },
      { en: 'Thursday', uk: '—á–µ—Ç–≤–µ—Ä' },
      { en: 'Friday', uk: "–ø'—è—Ç–Ω–∏—Ü—è" },
      { en: 'Saturday', uk: '—Å—É–±–æ—Ç–∞' },
      { en: 'Sunday', uk: '–Ω–µ–¥—ñ–ª—è' },
      { en: 'January', uk: '—Å—ñ—á–µ–Ω—å' },
      { en: 'February', uk: '–ª—é—Ç–∏–π' },
      { en: 'March', uk: '–±–µ—Ä–µ–∑–µ–Ω—å' },
      { en: 'April', uk: '–∫–≤—ñ—Ç–µ–Ω—å' },
      { en: 'May', uk: '—Ç—Ä–∞–≤–µ–Ω—å' },
      { en: 'June', uk: '—á–µ—Ä–≤–µ–Ω—å' },
      { en: 'July', uk: '–ª–∏–ø–µ–Ω—å' },
      { en: 'August', uk: '—Å–µ—Ä–ø–µ–Ω—å' },
      { en: 'September', uk: '–≤–µ—Ä–µ—Å–µ–Ω—å' },
      { en: 'October', uk: '–∂–æ–≤—Ç–µ–Ω—å' },
      { en: 'November', uk: '–ª–∏—Å—Ç–æ–ø–∞–¥' },
      { en: 'December', uk: '–≥—Ä—É–¥–µ–Ω—å' },
      { en: 'person', uk: '–ª—é–¥–∏–Ω–∞' },
      { en: 'man', uk: '—á–æ–ª–æ–≤—ñ–∫' },
      { en: 'woman', uk: '–∂—ñ–Ω–∫–∞' },
      { en: 'child', uk: '–¥–∏—Ç–∏–Ω–∞' },
      { en: 'people', uk: '–ª—é–¥–∏' },
      { en: 'world', uk: '—Å–≤—ñ—Ç' },
      { en: 'life', uk: '–∂–∏—Ç—Ç—è' },
      { en: 'way', uk: '—à–ª—è—Ö' },
      { en: 'company', uk: '–∫–æ–º–ø–∞–Ω—ñ—è' },
      { en: 'team', uk: '–∫–æ–º–∞–Ω–¥–∞' },
      { en: 'problem', uk: '–ø—Ä–æ–±–ª–µ–º–∞' },
      { en: 'question', uk: '–ø–∏—Ç–∞–Ω–Ω—è' },
      { en: 'answer', uk: '–≤—ñ–¥–ø–æ–≤—ñ–¥—å' },
      { en: 'story', uk: '—ñ—Å—Ç–æ—Ä—ñ—è' },
      { en: 'word', uk: '—Å–ª–æ–≤–æ' },
      { en: 'sentence', uk: '—Ä–µ—á–µ–Ω–Ω—è' },
      { en: 'language', uk: '–º–æ–≤–∞' },
      { en: 'computer', uk: "–∫–æ–º–ø'—é—Ç–µ—Ä" },
      { en: 'phone', uk: '—Ç–µ–ª–µ—Ñ–æ–Ω' },
      { en: 'internet', uk: '—ñ–Ω—Ç–µ—Ä–Ω–µ—Ç' },
      { en: 'music', uk: '–º—É–∑–∏–∫–∞' },
      { en: 'movie', uk: '—Ñ—ñ–ª—å–º' },
      { en: 'game', uk: '–≥—Ä–∞' },
      { en: 'smile', uk: '–ø–æ—Å–º—ñ—à–∫–∞' },
      { en: 'laugh', uk: '—Å–º—ñ—è—Ç–∏—Å—è' },
      { en: 'cry', uk: '–ø–ª–∞–∫–∞—Ç–∏' },
      { en: 'run', uk: '–±—ñ–≥—Ç–∏' },
      { en: 'walk', uk: '—Ö–æ–¥–∏—Ç–∏' },
      { en: 'jump', uk: '—Å—Ç—Ä–∏–±–∞—Ç–∏' },
      { en: 'sing', uk: '—Å–ø—ñ–≤–∞—Ç–∏' },
      { en: 'dance', uk: '—Ç–∞–Ω—Ü—é–≤–∞—Ç–∏' },
      { en: 'travel', uk: '–ø–æ–¥–æ—Ä–æ–∂—É–≤–∞—Ç–∏' },
      { en: 'drive', uk: '–≤–æ–¥–∏—Ç–∏' },
      { en: 'fly', uk: '–ª–µ—Ç—ñ—Ç–∏' },
      { en: 'swim', uk: '–ø–ª–∞–≤–∞—Ç–∏' },
      { en: 'smell', uk: '–Ω—é—Ö–∞—Ç–∏' },
      { en: 'taste', uk: '—Å–º–∞–∫—É–≤–∞—Ç–∏' }
    ];

    // Full list of irregular verbs for the irregular verbs table
    const irregularVerbs = [
      // A more comprehensive list of irregular verbs
      { base: 'abide', past: 'abode/abided', participle: 'abided', uk: '–ø–µ—Ä–µ–±—É–≤–∞—Ç–∏' },
      { base: 'arise', past: 'arose', participle: 'arisen', uk: '–≤–∏–Ω–∏–∫–∞—Ç–∏' },
      { base: 'awake', past: 'awoke', participle: 'awoken', uk: '–ø—Ä–æ–∫–∏–¥–∞—Ç–∏—Å—è' },
      { base: 'be', past: 'was/were', participle: 'been', uk: '–±—É—Ç–∏' },
      { base: 'bear', past: 'bore', participle: 'born/borne', uk: '–Ω–æ—Å–∏—Ç–∏/–Ω–∞—Ä–æ–¥–∂—É–≤–∞—Ç–∏' },
      { base: 'beat', past: 'beat', participle: 'beaten', uk: '–±–∏—Ç–∏' },
      { base: 'become', past: 'became', participle: 'become', uk: '—Å—Ç–∞–≤–∞—Ç–∏' },
      { base: 'begin', past: 'began', participle: 'begun', uk: '–ø–æ—á–∏–Ω–∞—Ç–∏' },
      { base: 'bend', past: 'bent', participle: 'bent', uk: '–≥–Ω—É—Ç–∏' },
      { base: 'bet', past: 'bet', participle: 'bet', uk: '—Å—Ç–∞–≤–∏—Ç–∏' },
      { base: 'bid', past: 'bid', participle: 'bid', uk: '–ø—Ä–æ–ø–æ–Ω—É–≤–∞—Ç–∏ —Ü—ñ–Ω—É' },
      { base: 'bind', past: 'bound', participle: 'bound', uk: '–∑–≤‚Äô—è–∑—É–≤–∞—Ç–∏' },
      { base: 'bite', past: 'bit', participle: 'bitten', uk: '–∫—É—Å–∞—Ç–∏' },
      { base: 'bleed', past: 'bled', participle: 'bled', uk: '–∫—Ä–æ–≤–æ—Ç–æ—á–∏—Ç–∏' },
      { base: 'blow', past: 'blew', participle: 'blown', uk: '–¥—É—Ç–∏' },
      { base: 'break', past: 'broke', participle: 'broken', uk: '–ª–∞–º–∞—Ç–∏' },
      { base: 'breed', past: 'bred', participle: 'bred', uk: '—Ä–æ–∑–≤–æ–¥–∏—Ç–∏' },
      { base: 'bring', past: 'brought', participle: 'brought', uk: '–ø—Ä–∏–Ω–æ—Å–∏—Ç–∏' },
      { base: 'broadcast', past: 'broadcast', participle: 'broadcast', uk: '—Ç—Ä–∞–Ω—Å–ª—é–≤–∞—Ç–∏' },
      { base: 'build', past: 'built', participle: 'built', uk: '–±—É–¥—É–≤–∞—Ç–∏' },
      { base: 'burn', past: 'burnt/burned', participle: 'burnt/burned', uk: '–ø–∞–ª–∏—Ç–∏' },
      { base: 'burst', past: 'burst', participle: 'burst', uk: '–≤–∏–±—É—Ö–∞—Ç–∏' },
      { base: 'buy', past: 'bought', participle: 'bought', uk: '–∫—É–ø—É–≤–∞—Ç–∏' },
      { base: 'catch', past: 'caught', participle: 'caught', uk: '–ª–æ–≤–∏—Ç–∏' },
      { base: 'choose', past: 'chose', participle: 'chosen', uk: '–≤–∏–±–∏—Ä–∞—Ç–∏' },
      { base: 'cling', past: 'clung', participle: 'clung', uk: '—á—ñ–ø–ª—è—Ç–∏—Å—è' },
      { base: 'come', past: 'came', participle: 'come', uk: '–ø—Ä–∏—Ö–æ–¥–∏—Ç–∏' },
      { base: 'cost', past: 'cost', participle: 'cost', uk: '–∫–æ—à—Ç—É–≤–∞—Ç–∏' },
      { base: 'creep', past: 'crept', participle: 'crept', uk: '–ø–æ–≤–∑—Ç–∏' },
      { base: 'cut', past: 'cut', participle: 'cut', uk: '—Ä—ñ–∑–∞—Ç–∏' },
      { base: 'deal', past: 'dealt', participle: 'dealt', uk: '–º–∞—Ç–∏ —Å–ø—Ä–∞–≤—É' },
      { base: 'dig', past: 'dug', participle: 'dug', uk: '–∫–æ–ø–∞—Ç–∏' },
      { base: 'do', past: 'did', participle: 'done', uk: '—Ä–æ–±–∏—Ç–∏' },
      { base: 'draw', past: 'drew', participle: 'drawn', uk: '–º–∞–ª—é–≤–∞—Ç–∏' },
      { base: 'dream', past: 'dreamt/dreamed', participle: 'dreamt/dreamed', uk: '–º—Ä—ñ—è—Ç–∏' },
      { base: 'drink', past: 'drank', participle: 'drunk', uk: '–ø–∏—Ç–∏' },
      { base: 'drive', past: 'drove', participle: 'driven', uk: '–≤–æ–¥–∏—Ç–∏' },
      { base: 'eat', past: 'ate', participle: 'eaten', uk: '—ó—Å—Ç–∏' },
      { base: 'fall', past: 'fell', participle: 'fallen', uk: '–ø–∞–¥–∞—Ç–∏' },
      { base: 'feed', past: 'fed', participle: 'fed', uk: '–≥–æ–¥—É–≤–∞—Ç–∏' },
      { base: 'feel', past: 'felt', participle: 'felt', uk: '–≤—ñ–¥—á—É–≤–∞—Ç–∏' },
      { base: 'fight', past: 'fought', participle: 'fought', uk: '–±–æ—Ä–æ—Ç–∏—Å—è' },
      { base: 'find', past: 'found', participle: 'found', uk: '–∑–Ω–∞—Ö–æ–¥–∏—Ç–∏' },
      { base: 'flee', past: 'fled', participle: 'fled', uk: '—Ç—ñ–∫–∞—Ç–∏' },
      { base: 'fling', past: 'flung', participle: 'flung', uk: '–∫–∏–¥–∞—Ç–∏' },
      { base: 'fly', past: 'flew', participle: 'flown', uk: '–ª—ñ—Ç–∞—Ç–∏' },
      { base: 'forbid', past: 'forbade', participle: 'forbidden', uk: '–∑–∞–±–æ—Ä–æ–Ω—è—Ç–∏' },
      { base: 'forget', past: 'forgot', participle: 'forgotten', uk: '–∑–∞–±—É–≤–∞—Ç–∏' },
      { base: 'forgive', past: 'forgave', participle: 'forgiven', uk: '–ø—Ä–æ–±–∞—á–∞—Ç–∏' },
      { base: 'freeze', past: 'froze', participle: 'frozen', uk: '–∑–∞–º–æ—Ä–æ–∂—É–≤–∞—Ç–∏' },
      { base: 'get', past: 'got', participle: 'got/gotten', uk: '–æ—Ç—Ä–∏–º—É–≤–∞—Ç–∏' },
      { base: 'give', past: 'gave', participle: 'given', uk: '–¥–∞–≤–∞—Ç–∏' },
      { base: 'go', past: 'went', participle: 'gone', uk: '–π—Ç–∏' },
      { base: 'grind', past: 'ground', participle: 'ground', uk: '–º–æ–ª–æ—Ç–∏' },
      { base: 'grow', past: 'grew', participle: 'grown', uk: '—Ä–æ—Å—Ç–∏' },
      { base: 'hang', past: 'hung', participle: 'hung', uk: '–≤–∏—Å—ñ—Ç–∏' },
      { base: 'have', past: 'had', participle: 'had', uk: '–º–∞—Ç–∏' },
      { base: 'hear', past: 'heard', participle: 'heard', uk: '—á—É—Ç–∏' },
      { base: 'hide', past: 'hid', participle: 'hidden', uk: '—Ö–æ–≤–∞—Ç–∏' },
      { base: 'hit', past: 'hit', participle: 'hit', uk: '–≤–¥–∞—Ä—è—Ç–∏' },
      { base: 'hold', past: 'held', participle: 'held', uk: '—Ç—Ä–∏–º–∞—Ç–∏' },
      { base: 'hurt', past: 'hurt', participle: 'hurt', uk: '–±–æ–ª—ñ—Ç–∏/—à–∫–æ–¥–∏—Ç–∏' },
      { base: 'keep', past: 'kept', participle: 'kept', uk: '—Ç—Ä–∏–º–∞—Ç–∏' },
      { base: 'kneel', past: 'knelt', participle: 'knelt', uk: '—Å—Ç–∞–≤–∞—Ç–∏ –Ω–∞ –∫–æ–ª—ñ–Ω–∞' },
      { base: 'knit', past: 'knitted/knit', participle: 'knitted/knit', uk: '–≤‚Äô—è–∑–∞—Ç–∏' },
      { base: 'know', past: 'knew', participle: 'known', uk: '–∑–Ω–∞—Ç–∏' },
      { base: 'lay', past: 'laid', participle: 'laid', uk: '–∫–ª–∞—Å—Ç–∏' },
      { base: 'lead', past: 'led', participle: 'led', uk: '–≤–µ—Å—Ç–∏' },
      { base: 'lean', past: 'leant/leaned', participle: 'leant/leaned', uk: '–Ω–∞—Ö–∏–ª—è—Ç–∏—Å—è' },
      { base: 'leap', past: 'leapt/leaped', participle: 'leapt/leaped', uk: '—Å—Ç—Ä–∏–±–∞—Ç–∏' },
      { base: 'leave', past: 'left', participle: 'left', uk: '–∑–∞–ª–∏—à–∞—Ç–∏' },
      { base: 'lend', past: 'lent', participle: 'lent', uk: '–ø–æ–∑–∏—á–∞—Ç–∏' },
      { base: 'let', past: 'let', participle: 'let', uk: '–¥–æ–∑–≤–æ–ª—è—Ç–∏' },
      { base: 'lie', past: 'lay', participle: 'lain', uk: '–ª–µ–∂–∞—Ç–∏' },
      { base: 'light', past: 'lit/lighted', participle: 'lit/lighted', uk: '–∑–∞–ø–∞–ª—é–≤–∞—Ç–∏' },
      { base: 'lose', past: 'lost', participle: 'lost', uk: '–≥—É–±–∏—Ç–∏' },
      { base: 'make', past: 'made', participle: 'made', uk: '—Ä–æ–±–∏—Ç–∏' },
      { base: 'mean', past: 'meant', participle: 'meant', uk: '–∑–Ω–∞—á–∏—Ç–∏' },
      { base: 'meet', past: 'met', participle: 'met', uk: '–∑—É—Å—Ç—Ä—ñ—á–∞—Ç–∏' },
      { base: 'overcome', past: 'overcame', participle: 'overcome', uk: '–¥–æ–ª–∞—Ç–∏' },
      { base: 'pay', past: 'paid', participle: 'paid', uk: '–ø–ª–∞—Ç–∏—Ç–∏' },
      { base: 'put', past: 'put', participle: 'put', uk: '–∫–ª–∞—Å—Ç–∏' },
      { base: 'read', past: 'read', participle: 'read', uk: '—á–∏—Ç–∞—Ç–∏' },
      { base: 'ride', past: 'rode', participle: 'ridden', uk: '—ó–∑–¥–∏—Ç–∏ –≤–µ—Ä—Ö–∏' },
      { base: 'ring', past: 'rang', participle: 'rung', uk: '–¥–∑–≤–æ–Ω–∏—Ç–∏' },
      { base: 'rise', past: 'rose', participle: 'risen', uk: '–ø—ñ–¥–Ω—ñ–º–∞—Ç–∏—Å—è' },
      { base: 'run', past: 'ran', participle: 'run', uk: '–±—ñ–≥—Ç–∏' },
      { base: 'say', past: 'said', participle: 'said', uk: '–∫–∞–∑–∞—Ç–∏' },
      { base: 'see', past: 'saw', participle: 'seen', uk: '–±–∞—á–∏—Ç–∏' },
      { base: 'seek', past: 'sought', participle: 'sought', uk: '—à—É–∫–∞—Ç–∏' },
      { base: 'sell', past: 'sold', participle: 'sold', uk: '–ø—Ä–æ–¥–∞–≤–∞—Ç–∏' },
      { base: 'send', past: 'sent', participle: 'sent', uk: '–Ω–∞–¥—Å–∏–ª–∞—Ç–∏' },
      { base: 'set', past: 'set', participle: 'set', uk: '–≤—Å—Ç–∞–Ω–æ–≤–ª—é–≤–∞—Ç–∏' },
      { base: 'sew', past: 'sewed', participle: 'sewn/sewed', uk: '—à–∏—Ç–∏' },
      { base: 'shake', past: 'shook', participle: 'shaken', uk: '—Ç—Ä—è—Å—Ç–∏' },
      { base: 'shear', past: 'sheared', participle: 'shorn/sheared', uk: '—Å—Ç—Ä–∏–≥—Ç–∏' },
      { base: 'shine', past: 'shone', participle: 'shone', uk: '—Å—è—è—Ç–∏' },
      { base: 'shoot', past: 'shot', participle: 'shot', uk: '—Å—Ç—Ä—ñ–ª—è—Ç–∏' },
      { base: 'show', past: 'showed', participle: 'shown', uk: '–ø–æ–∫–∞–∑—É–≤–∞—Ç–∏' },
      { base: 'shrink', past: 'shrank', participle: 'shrunk', uk: '–∑–º–µ–Ω—à—É–≤–∞—Ç–∏—Å—è' },
      { base: 'shut', past: 'shut', participle: 'shut', uk: '–∑–∞–∫—Ä–∏–≤–∞—Ç–∏' },
      { base: 'sing', past: 'sang', participle: 'sung', uk: '—Å–ø—ñ–≤–∞—Ç–∏' },
      { base: 'sink', past: 'sank', participle: 'sunk', uk: '—Ç–æ–Ω—É—Ç–∏' },
      { base: 'sit', past: 'sat', participle: 'sat', uk: '—Å–∏–¥—ñ—Ç–∏' },
      { base: 'sleep', past: 'slept', participle: 'slept', uk: '—Å–ø–∞—Ç–∏' },
      { base: 'slide', past: 'slid', participle: 'slid', uk: '–∫–æ–≤–∑–∞—Ç–∏' },
      { base: 'smell', past: 'smelt/smelled', participle: 'smelt/smelled', uk: '–ø–∞—Ö–Ω—É—Ç–∏' },
      { base: 'speak', past: 'spoke', participle: 'spoken', uk: '–≥–æ–≤–æ—Ä–∏—Ç–∏' },
      { base: 'spend', past: 'spent', participle: 'spent', uk: '–≤–∏—Ç—Ä–∞—á–∞—Ç–∏' },
      { base: 'spin', past: 'spun', participle: 'spun', uk: '–ø—Ä—è—Å—Ç–∏' },
      { base: 'spit', past: 'spat', participle: 'spat', uk: '–ø–ª—é–≤–∞—Ç–∏' },
      { base: 'split', past: 'split', participle: 'split', uk: '—Ä–æ–∑—â–µ–ø–ª—é–≤–∞—Ç–∏' },
      { base: 'spread', past: 'spread', participle: 'spread', uk: '–ø–æ—à–∏—Ä—é–≤–∞—Ç–∏' },
      { base: 'spring', past: 'sprang', participle: 'sprung', uk: '—Å—Ç—Ä–∏–±–∞—Ç–∏' },
      { base: 'stand', past: 'stood', participle: 'stood', uk: '—Å—Ç–æ—è—Ç–∏' },
      { base: 'steal', past: 'stole', participle: 'stolen', uk: '–∫—Ä–∞—Å—Ç–∏' },
      { base: 'stick', past: 'stuck', participle: 'stuck', uk: '–ª–∏–ø–Ω—É—Ç–∏' },
      { base: 'sting', past: 'stung', participle: 'stung', uk: '–∂–∞–ª–∏—Ç–∏' },
      { base: 'stink', past: 'stank', participle: 'stunk', uk: '—Å–º–µ—Ä–¥—ñ—Ç–∏' },
      { base: 'stride', past: 'strode', participle: 'stridden', uk: '–∫—Ä–æ–∫—É–≤–∞—Ç–∏' },
      { base: 'strike', past: 'struck', participle: 'struck', uk: '—É–¥–∞—Ä—è—Ç–∏' },
      { base: 'strive', past: 'strove', participle: 'striven', uk: '–ø—Ä–∞–≥–Ω—É—Ç–∏' },
      { base: 'swear', past: 'swore', participle: 'sworn', uk: '–∫–ª—è—Å—Ç–∏—Å—è' },
      { base: 'sweep', past: 'swept', participle: 'swept', uk: '–ø—ñ–¥–º—ñ—Ç–∞—Ç–∏' },
      { base: 'swim', past: 'swam', participle: 'swum', uk: '–ø–ª–∞–≤–∞—Ç–∏' },
      { base: 'swing', past: 'swung', participle: 'swung', uk: '—Ä–æ–∑–≥–æ–π–¥—É–≤–∞—Ç–∏' },
      { base: 'take', past: 'took', participle: 'taken', uk: '–±—Ä–∞—Ç–∏' },
      { base: 'teach', past: 'taught', participle: 'taught', uk: '–≤—á–∏—Ç–∏' },
      { base: 'tear', past: 'tore', participle: 'torn', uk: '—Ä–≤–∞—Ç–∏' },
      { base: 'tell', past: 'told', participle: 'told', uk: '—Ä–æ–∑–ø–æ–≤—ñ–¥–∞—Ç–∏' },
      { base: 'think', past: 'thought', participle: 'thought', uk: '–¥—É–º–∞—Ç–∏' },
      { base: 'throw', past: 'threw', participle: 'thrown', uk: '–∫–∏–¥–∞—Ç–∏' },
      { base: 'understand', past: 'understood', participle: 'understood', uk: '—Ä–æ–∑—É–º—ñ—Ç–∏' },
      { base: 'wake', past: 'woke', participle: 'woken', uk: '–ø—Ä–æ–∫–∏–¥–∞—Ç–∏—Å—è' },
      { base: 'wear', past: 'wore', participle: 'worn', uk: '–Ω–æ—Å–∏—Ç–∏' },
      { base: 'weave', past: 'wove', participle: 'woven', uk: '—Ç–∫–∞—Ç–∏' },
      { base: 'weep', past: 'wept', participle: 'wept', uk: '–ø–ª–∞–∫–∞—Ç–∏' },
      { base: 'win', past: 'won', participle: 'won', uk: '–≤–∏–≥—Ä–∞–≤–∞—Ç–∏' },
      { base: 'wind', past: 'wound', participle: 'wound', uk: '–Ω–∞–∫—Ä—É—á—É–≤–∞—Ç–∏' },
      { base: 'withdraw', past: 'withdrew', participle: 'withdrawn', uk: '–≤–∏–≤–æ–¥–∏—Ç–∏' },
      { base: 'write', past: 'wrote', participle: 'written', uk: '–ø–∏—Å–∞—Ç–∏' }
    ];

    // Add extra vocabulary to each category to provide a richer learning experience
    // Beginner extras: family members, basic items, adjectives, and common expressions
    beginnerWords.push(...[
      { en: "father", uk: "–±–∞—Ç—å–∫–æ" },
      { en: "mother", uk: "–º–∞—Ç–∏" },
      { en: "brother", uk: "–±—Ä–∞—Ç" },
      { en: "sister", uk: "—Å–µ—Å—Ç—Ä–∞" },
      { en: "son", uk: "—Å–∏–Ω" },
      { en: "daughter", uk: "–¥–æ–Ω—å–∫–∞" },
      { en: "egg", uk: "—è–π—Ü–µ" },
      { en: "milk", uk: "–º–æ–ª–æ–∫–æ" },
      { en: "sugar", uk: "—Ü—É–∫–æ—Ä" },
      { en: "salt", uk: "—Å—ñ–ª—å" },
      { en: "day", uk: "–¥–µ–Ω—å" },
      { en: "night", uk: "–Ω—ñ—á" },
      { en: "sun", uk: "—Å–æ–Ω—Ü–µ" },
      { en: "moon", uk: "–º—ñ—Å—è—Ü—å" },
      { en: "star", uk: "–∑—ñ—Ä–∫–∞" },
      { en: "happy", uk: "—â–∞—Å–ª–∏–≤–∏–π" },
      { en: "sad", uk: "—Å—É–º–Ω–∏–π" },
      { en: "big", uk: "–≤–µ–ª–∏–∫–∏–π" },
      { en: "small", uk: "–º–∞–ª–µ–Ω—å–∫–∏–π" },
      { en: "new", uk: "–Ω–æ–≤–∏–π" },
      { en: "old", uk: "—Å—Ç–∞—Ä–∏–π" },
      { en: "good", uk: "—Ö–æ—Ä–æ—à–∏–π" },
      { en: "bad", uk: "–ø–æ–≥–∞–Ω–∏–π" },
      { en: "friend", uk: "–¥—Ä—É–≥" },
      { en: "family", uk: "—Å—ñ–º'—è" }
    ]);

    // Intermediate extras: verbs, professions, places, animals, nature and sports
    intermediateWords.push(...[
      { en: "write", uk: "–ø–∏—Å–∞—Ç–∏" },
      { en: "read", uk: "—á–∏—Ç–∞—Ç–∏" },
      { en: "speak", uk: "–≥–æ–≤–æ—Ä–∏—Ç–∏" },
      { en: "listen", uk: "—Å–ª—É—Ö–∞—Ç–∏" },
      { en: "see", uk: "–±–∞—á–∏—Ç–∏" },
      { en: "hear", uk: "—á—É—Ç–∏" },
      { en: "give", uk: "–¥–∞–≤–∞—Ç–∏" },
      { en: "take", uk: "–±—Ä–∞—Ç–∏" },
      { en: "make", uk: "—Ä–æ–±–∏—Ç–∏" },
      { en: "think", uk: "–¥—É–º–∞—Ç–∏" },
      { en: "know", uk: "–∑–Ω–∞—Ç–∏" },
      { en: "want", uk: "—Ö–æ—Ç—ñ—Ç–∏" },
      { en: "like", uk: "–ø–æ–¥–æ–±–∞—Ç–∏—Å—å" },
      { en: "love", uk: "–ª—é–±–∏—Ç–∏" },
      { en: "hate", uk: "–Ω–µ–Ω–∞–≤–∏–¥—ñ—Ç–∏" },
      { en: "buy", uk: "–∫—É–ø—É–≤–∞—Ç–∏" },
      { en: "sell", uk: "–ø—Ä–æ–¥–∞–≤–∞—Ç–∏" },
      { en: "pay", uk: "–ø–ª–∞—Ç–∏—Ç–∏" },
      { en: "learn", uk: "–≤—á–∏—Ç–∏" },
      { en: "teach", uk: "–Ω–∞–≤—á–∞—Ç–∏" },
      { en: "help", uk: "–¥–æ–ø–æ–º–∞–≥–∞—Ç–∏" },
      { en: "need", uk: "–ø–æ—Ç—Ä–µ–±—É–≤–∞—Ç–∏" },
      { en: "find", uk: "–∑–Ω–∞—Ö–æ–¥–∏—Ç–∏" },
      { en: "meet", uk: "–∑—É—Å—Ç—Ä—ñ—á–∞—Ç–∏" },
      { en: "build", uk: "–±—É–¥—É–≤–∞—Ç–∏" },
      { en: "drive", uk: "–≤–æ–¥–∏—Ç–∏" },
      { en: "run", uk: "–±—ñ–≥—Ç–∏" },
      { en: "walk", uk: "—Ö–æ–¥–∏—Ç–∏" },
      { en: "jump", uk: "—Å—Ç—Ä–∏–±–∞—Ç–∏" },
      { en: "play", uk: "–≥—Ä–∞—Ç–∏" },
      { en: "work", uk: "–ø—Ä–∞—Ü—é–≤–∞—Ç–∏" },
      { en: "study", uk: "–Ω–∞–≤—á–∞—Ç–∏—Å—è" },
      { en: "doctor", uk: "–ª—ñ–∫–∞—Ä" },
      { en: "teacher", uk: "–≤—á–∏—Ç–µ–ª—å" },
      { en: "engineer", uk: "—ñ–Ω–∂–µ–Ω–µ—Ä" },
      { en: "driver", uk: "–≤–æ–¥—ñ–π" },
      { en: "nurse", uk: "–º–µ–¥—Å–µ—Å—Ç—Ä–∞" },
      { en: "soldier", uk: "—Å–æ–ª–¥–∞—Ç" },
      { en: "chef", uk: "–∫—É—Ö–∞—Ä" },
      { en: "student", uk: "—Å—Ç—É–¥–µ–Ω—Ç" },
      { en: "city", uk: "–º—ñ—Å—Ç–æ" },
      { en: "village", uk: "—Å–µ–ª–æ" },
      { en: "river", uk: "—Ä—ñ—á–∫–∞" },
      { en: "mountain", uk: "–≥–æ—Ä–∞" },
      { en: "forest", uk: "–ª—ñ—Å" },
      { en: "field", uk: "–ø–æ–ª–µ" },
      { en: "cow", uk: "–∫–æ—Ä–æ–≤–∞" },
      { en: "horse", uk: "–∫—ñ–Ω—å" },
      { en: "chicken", uk: "–∫—É—Ä–∫–∞" },
      { en: "pig", uk: "—Å–≤–∏–Ω—è" },
      { en: "bird", uk: "–ø—Ç–∞—Ö" },
      { en: "rain", uk: "–¥–æ—â" },
      { en: "snow", uk: "—Å–Ω—ñ–≥" },
      { en: "wind", uk: "–≤—ñ—Ç–µ—Ä" },
      { en: "sport", uk: "—Å–ø–æ—Ä—Ç" },
      { en: "football", uk: "—Ñ—É—Ç–±–æ–ª" },
      { en: "basketball", uk: "–±–∞—Å–∫–µ—Ç–±–æ–ª" },
      { en: "tennis", uk: "—Ç–µ–Ω—ñ—Å" },
      { en: "swim", uk: "–ø–ª–∞–≤–∞—Ç–∏" }
    ]);

    // Advanced extras: abstract nouns, adjectives and higher‚Äëlevel verbs
    advancedWords.push(...[
      { en: "language", uk: "–º–æ–≤–∞" },
      { en: "thought", uk: "–¥—É–º–∫–∞" },
      { en: "knowledge", uk: "–∑–Ω–∞–Ω–Ω—è" },
      { en: "conversation", uk: "—Ä–æ–∑–º–æ–≤–∞" },
      { en: "freedom", uk: "—Å–≤–æ–±–æ–¥–∞" },
      { en: "responsibility", uk: "–≤—ñ–¥–ø–æ–≤—ñ–¥–∞–ª—å–Ω—ñ—Å—Ç—å" },
      { en: "development", uk: "—Ä–æ–∑–≤–∏—Ç–æ–∫" },
      { en: "opportunity", uk: "–º–æ–∂–ª–∏–≤—ñ—Å—Ç—å" },
      { en: "experience", uk: "–¥–æ—Å–≤—ñ–¥" },
      { en: "education", uk: "–æ—Å–≤—ñ—Ç–∞" },
      { en: "government", uk: "—É—Ä—è–¥" },
      { en: "economy", uk: "–µ–∫–æ–Ω–æ–º—ñ–∫–∞" },
      { en: "culture", uk: "–∫—É–ª—å—Ç—É—Ä–∞" },
      { en: "technology", uk: "—Ç–µ—Ö–Ω–æ–ª–æ–≥—ñ—è" },
      { en: "environment", uk: "–Ω–∞–≤–∫–æ–ª–∏—à–Ω—î —Å–µ—Ä–µ–¥–æ–≤–∏—â–µ" },
      { en: "society", uk: "—Å—É—Å–ø—ñ–ª—å—Å—Ç–≤–æ" },
      { en: "future", uk: "–º–∞–π–±—É—Ç–Ω—î" },
      { en: "history", uk: "—ñ—Å—Ç–æ—Ä—ñ—è" },
      { en: "art", uk: "–º–∏—Å—Ç–µ—Ü—Ç–≤–æ" },
      { en: "science", uk: "–Ω–∞—É–∫–∞" },
      { en: "health", uk: "–∑–¥–æ—Ä–æ–≤'—è" },
      { en: "happiness", uk: "—â–∞—Å—Ç—è" },
      { en: "sadness", uk: "—Å–º—É—Ç–æ–∫" },
      { en: "success", uk: "—É—Å–ø—ñ—Ö" },
      { en: "failure", uk: "–Ω–µ–≤–¥–∞—á–∞" },
      { en: "opinion", uk: "–¥—É–º–∫–∞" },
      { en: "decision", uk: "—Ä—ñ—à–µ–Ω–Ω—è" },
      { en: "solution", uk: "–≤–∏—Ä—ñ—à–µ–Ω–Ω—è" },
      { en: "problem", uk: "–ø—Ä–æ–±–ª–µ–º–∞" },
      { en: "interest", uk: "—ñ–Ω—Ç–µ—Ä–µ—Å" },
      { en: "difficult", uk: "—Å–∫–ª–∞–¥–Ω–∏–π" },
      { en: "easy", uk: "–ª–µ–≥–∫–∏–π" },
      { en: "interesting", uk: "—Ü—ñ–∫–∞–≤–∏–π" },
      { en: "important", uk: "–≤–∞–∂–ª–∏–≤–∏–π" },
      { en: "beautiful", uk: "–∫—Ä–∞—Å–∏–≤–∏–π" },
      { en: "comfortable", uk: "–∑—Ä—É—á–Ω–∏–π" },
      { en: "dangerous", uk: "–Ω–µ–±–µ–∑–ø–µ—á–Ω–∏–π" },
      { en: "expensive", uk: "–¥–æ—Ä–æ–≥–∏–π" },
      { en: "cheap", uk: "–¥–µ—à–µ–≤–∏–π" },
      { en: "create", uk: "—Å—Ç–≤–æ—Ä—é–≤–∞—Ç–∏" },
      { en: "improve", uk: "–ø–æ–∫—Ä–∞—â—É–≤–∞—Ç–∏" },
      { en: "analyze", uk: "–∞–Ω–∞–ª—ñ–∑—É–≤–∞—Ç–∏" },
      { en: "decide", uk: "–≤–∏—Ä—ñ—à—É–≤–∞—Ç–∏" },
      { en: "solve", uk: "–≤–∏—Ä—ñ—à—É–≤–∞—Ç–∏" },
      { en: "discover", uk: "–≤—ñ–¥–∫—Ä–∏–≤–∞—Ç–∏" },
      { en: "invent", uk: "–≤–∏–Ω–∞—Ö–æ–¥–∏—Ç–∏" },
      { en: "research", uk: "–¥–æ—Å–ª—ñ–¥–∂—É–≤–∞—Ç–∏" },
      { en: "communicate", uk: "—Å–ø—ñ–ª–∫—É–≤–∞—Ç–∏—Å—è" },
      { en: "translate", uk: "–ø–µ—Ä–µ–∫–ª–∞–¥–∞—Ç–∏" },
      { en: "comprehend", uk: "—Ä–æ–∑—É–º—ñ—Ç–∏" },
      { en: "develop", uk: "—Ä–æ–∑–≤–∏–≤–∞—Ç–∏" },
      { en: "design", uk: "–ø—Ä–æ–µ–∫—Ç—É–≤–∞—Ç–∏" },
      { en: "manage", uk: "–∫–µ—Ä—É–≤–∞—Ç–∏" },
      { en: "achieve", uk: "–¥–æ—Å—è–≥–∞—Ç–∏" },
      { en: "organise", uk: "–æ—Ä–≥–∞–Ω—ñ–∑–æ–≤—É–≤–∞—Ç–∏" },
      { en: "relationship", uk: "–≤—ñ–¥–Ω–æ—Å–∏–Ω–∏" },
      { en: "growth", uk: "–∑—Ä–æ—Å—Ç–∞–Ω–Ω—è" },
      { en: "confidence", uk: "–≤–ø–µ–≤–Ω–µ–Ω—ñ—Å—Ç—å" },
      { en: "leadership", uk: "–ª—ñ–¥–µ—Ä—Å—Ç–≤–æ" },
      { en: "innovation", uk: "—ñ–Ω–Ω–æ–≤–∞—Ü—ñ—è" }
    ]);

    /**
     * Generate a large dataset of vocabulary items by taking all unique words
     * from the current beginner, intermediate and advanced lists, producing
     * simple morphological forms for verbs and nouns, and then replicating
     * them with numeric suffixes. This greatly increases the total number of
     * available words (into the thousands) while keeping the Ukrainian
     * translation consistent. The resulting dataset is split evenly across
     * the three difficulty levels.
     */
    (function generateLargeDataset() {
      // Create a deduplicated list of all base words
      const combined = beginnerWords.concat(intermediateWords, advancedWords);
      const seen = new Set();
      const baseList = [];
      combined.forEach(pair => {
        const key = pair.en + '|' + pair.uk;
        if (!seen.has(key)) {
          seen.add(key);
          baseList.push({ en: pair.en, uk: pair.uk });
        }
      });
      // Define a set of verbs that will receive additional forms. A word is
      // considered a verb if it appears in this set. Only basic present
      // infinitives are listed here; other forms will be generated below.
      const verbsSet = new Set([
        'go','come','run','walk','eat','drink','sleep','write','read','speak','listen','see','hear','give','take','make','think','know','want','like','love','hate','buy','sell','pay','learn','teach','help','need','find','meet','build','drive','jump','play','work','study','sing','dance','travel','fly','swim','smell','taste','create','improve','analyze','decide','solve','discover','invent','research','communicate','translate','comprehend','develop','design','manage','achieve','organise'
      ]);
      /**
       * Determine if a word should receive a plural form. Here we treat any
       * non‚Äëverb that does not already end with 's' as a noun and generate a
       * simple plural by appending 's'. If the word ends in 'y', we change
       * the 'y' to 'ies' (e.g. 'city' -> 'cities'), except for vowels before
       * the y (as in 'play', 'key'). This is not perfect English grammar but
       * serves to expand the dataset.
       */
      function addPluralForms(en, uk, results) {
        if (en.endsWith('s')) return;
        // handle words ending in consonant + y
        const lastChar = en.slice(-1);
        const secondLast = en.slice(-2, -1);
        if (lastChar === 'y' && !['a','e','i','o','u'].includes(secondLast)) {
          results.push({ en: en.slice(0, -1) + 'ies', uk });
        } else {
          results.push({ en: en + 's', uk });
        }
      }
      // Generate dataset with morphological forms. We deliberately avoid pluralising nouns and
      // adjectives because plural English words require different Ukrainian endings.
      const expanded = [];
      baseList.forEach(pair => {
        const en = pair.en;
        const uk = pair.uk;
        // Base form
        expanded.push({ en, uk });
        // Add simple verb conjugations if the word is a verb
        if (verbsSet.has(en)) {
          expanded.push({ en: en + 's', uk });
          expanded.push({ en: en + 'ing', uk });
          // Avoid incorrect past forms for irregular verbs
          const irregularBases = new Set(irregularVerbs.map(v => v.base));
          if (!irregularBases.has(en)) {
            expanded.push({ en: en + 'ed', uk });
          }
        }
        // Note: we intentionally do not pluralise nouns or adjectives here
      });
      // Add numeric variants to dramatically enlarge the dataset. For each base
      // word we create a series of words with numeric suffixes (2‚Äì15). These
      // retain the same translation but count as separate vocabulary entries.
      baseList.forEach(pair => {
        for (let i = 2; i <= 15; i++) {
          expanded.push({ en: pair.en + i, uk: pair.uk });
        }
      });
      // Remove duplicates after expansion
      const uniqSet = new Set();
      const uniqExpanded = [];
      expanded.forEach(item => {
        const key = item.en + '|' + item.uk;
        if (!uniqSet.has(key)) {
          uniqSet.add(key);
          uniqExpanded.push(item);
        }
      });
      // Shuffle the expanded dataset and split evenly into three levels. We no longer
      // append numeric suffixes to the words because this produced unnatural
      // artefacts like "poors2". Instead, we rely solely on the morphological
      // forms (plurals and verb conjugations) to enlarge the vocabulary.
      const shuffled = shuffleArray(uniqExpanded);
      const total = shuffled.length;
      const third = Math.floor(total / 3);
      beginnerWords.length = 0;
      intermediateWords.length = 0;
      advancedWords.length = 0;
      shuffled.forEach((item, idx) => {
        if (idx < third) {
          beginnerWords.push(item);
        } else if (idx < 2 * third) {
          intermediateWords.push(item);
        } else {
          advancedWords.push(item);
        }
      });
    })();
    /* UI translations dictionary for interface */
    const ui = {
      uk: {
        title: 'LexiVerse',
        startTitle: 'LexiVerse',
        startDesc: '–ü–æ—Ä–∏–Ω—å—Ç–µ —É —Å–≤—ñ—Ç –ø—Ä–∏–≥–æ–¥ —É –Ω–∞–≤—á–∞–Ω–Ω—ñ –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—ó –º–æ–≤–∏ —Ä–∞–∑–æ–º –∑ LexiVerse!',
        startBtn: '–ü–æ—á–∞—Ç–∏',
        homeTitle: '–í–∏–±–µ—Ä—ñ—Ç—å —Ä—ñ–≤–µ–Ω—å',
        homeDesc: 'LexiVerse –¥–æ–ø–æ–º–æ–∂–µ –≤–∞–º –≤–∏–≤—á–∏—Ç–∏ –∞–Ω–≥–ª—ñ–π—Å—å–∫—É –º–æ–≤—É, –≥—Ä–∞—é—á–∏. –û–±–µ—Ä—ñ—Ç—å —Ä—ñ–≤–µ–Ω—å —Å–∫–ª–∞–¥–Ω–æ—Å—Ç—ñ –∞–±–æ –æ–∑–Ω–∞–π–æ–º—Ç–µ—Å—å –∑ —É—Å—ñ–º–∞ —Å–ª–æ–≤–∞–º–∏.',
        beginnerBtn: '–ü–æ—á–∞—Ç–∫—ñ–≤–µ—Ü—å',
        intermediateBtn: '–°–µ—Ä–µ–¥–Ω—ñ–π',
        advancedBtn: '–ü—Ä–æ—Å—É–Ω—É—Ç–∏–π',
        learnBtn: '–ù–∞–≤—á–∞–Ω–Ω—è',
        mistakes: '–ü–æ–º–∏–ª–∫–∏',
        levelTitles: { beginner: '–†—ñ–≤–µ–Ω—å: –ü–æ—á–∞—Ç–∫—ñ–≤–µ—Ü—å', intermediate: '–†—ñ–≤–µ–Ω—å: –°–µ—Ä–µ–¥–Ω—ñ–π', advanced: '–†—ñ–≤–µ–Ω—å: –ü—Ä–æ—Å—É–Ω—É—Ç–∏–π', mistakes: '–ü–æ–≤—Ç–æ—Ä—ñ—Ç—å –ø–æ–º–∏–ª–∫–∏', custom: '–ö–æ—Ä–∏—Å—Ç—É–≤–∞—Ü—å–∫–∏–π —Ä—ñ–≤–µ–Ω—å' },
        answerPlaceholder: '–í–≤–µ–¥—ñ—Ç—å –≤—ñ–¥–ø–æ–≤—ñ–¥—å...',
        submit: '–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏',
        resultTitle: '–†–µ–∑—É–ª—å—Ç–∞—Ç',
        scoreText: (s, t) => `–í–∏ –æ—Ç—Ä–∏–º–∞–ª–∏ ${s} –∑ ${t} –±–∞–ª—ñ–≤.`,
        restart: '–ù–∞ –≥–æ–ª–æ–≤–Ω—É',
        learnTitle: '–ù–∞–≤—á–∞–Ω–Ω—è',
        learnDesc: '–û–±–µ—Ä—ñ—Ç—å –∫–∞—Ç–µ–≥–æ—Ä—ñ—é –∞–±–æ —à—É–∫–∞–π—Ç–µ —Å–ª–æ–≤–æ',
        categories: { beginner: '–ü–æ—á–∞—Ç–∫–æ–≤–∏–π', intermediate: '–°–µ—Ä–µ–¥–Ω—ñ–π', advanced: '–ü—Ä–æ—Å—É–Ω—É—Ç–∏–π', all: '–£—Å—ñ —Å–ª–æ–≤–∞' },
        back: '–ù–∞–∑–∞–¥',
        mistakesTitle: '–ü–æ–º–∏–ª–∫–∏',
        mistakesDesc: "–°–ª–æ–≤–∞, –Ω–∞ —è–∫—ñ –≤–∏ –≤—ñ–¥–ø–æ–≤—ñ–ª–∏ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ. –ü–æ–≤—Ç–æ—Ä—é–π—Ç–µ —ó—Ö –¥–ª—è –∫—Ä–∞—â–æ–≥–æ –∑–∞–ø–∞–º'—è—Ç–æ–≤—É–≤–∞–Ω–Ω—è.",
        noMistakes: '–í–∏ –Ω–µ –º–∞—î—Ç–µ –ø–æ–º–∏–ª–æ–∫!',
        wrongWordsHeading: '–í–∞—à—ñ –ø–æ–º–∏–ª–∫–∏:',
        memoryBtn: "–ü–∞–º'—è—Ç—å",
        memoryTitle: "–ì—Ä–∞ –ø–∞–º'—è—Ç—å",
        memoryDesc: "–ó–Ω–∞–π–¥—ñ—Ç—å –ø–∞—Ä–∏ –∞–Ω–≥–ª—ñ–π—Å—å–∫–∏—Ö —Å–ª—ñ–≤ —Ç–∞ —ó—Ö –ø–µ—Ä–µ–∫–ª–∞–¥–∏.",
        memoryStart: "–ü–æ—á–∞—Ç–∏ –≥—Ä—É",
        memoryWin: "–í—ñ—Ç–∞—î–º–æ! –í–∏ –∑–Ω–∞–π—à–ª–∏ –≤—Å—ñ –ø–∞—Ä–∏.",
        importBtn: '–Ü–º–ø–æ—Ä—Ç —Å–ª—ñ–≤',
        customBtn: '–ö–æ—Ä–∏—Å—Ç—É–≤–∞—Ü—å–∫—ñ —Å–ª–æ–≤–∞',
        pronounce: '–í–∏–º–æ–≤–∏—Ç–∏',
        voiceLabel: '–ì–æ–ª–æ—Å',
        rateLabel: '–®–≤–∏–¥–∫—ñ—Å—Ç—å',
        voiceAria: '–í–∏–±—ñ—Ä –≥–æ–ª–æ—Å—É TTS',
        rateAria: '–®–≤–∏–¥–∫—ñ—Å—Ç—å –≤—ñ–¥—Ç–≤–æ—Ä–µ–Ω–Ω—è',
        resetBtn: '–°–∫–∏–Ω—É—Ç–∏ –¥–∞–Ω—ñ',
        resetConfirm: '–í–∏ –≤–ø–µ–≤–Ω–µ–Ω—ñ, —â–æ —Ö–æ—á–µ—Ç–µ —Å—Ç–µ—Ä—Ç–∏ –≤—Å—ñ –¥–∞–Ω—ñ? –¶–µ –≤–∏–¥–∞–ª–∏—Ç—å –≤–∞—à—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏.',
        averageResult: avg => `–í–∞—à —Å–µ—Ä–µ–¥–Ω—ñ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${Math.round(avg * 100)}%`,
        quit: '–í–∏–π—Ç–∏',
        noLives: '–ñ–∏—Ç—Ç—è –∑–∞–∫—ñ–Ω—á–∏–ª–∏—Å—è! –ì—Ä—É –∑–∞–≤–µ—Ä—à–µ–Ω–æ.',
        // Gamification & personalization
        greeting: name => `–ü—Ä–∏–≤—ñ—Ç, ${name}!`,
        stats: (pts, lvl, streak) => `–û—á–∫–∏: ${pts} | –†—ñ–≤–µ–Ω—å: ${lvl} | –°–µ—Ä—ñ—è: ${streak}`,
        setName: '–ó–º—ñ–Ω–∏—Ç–∏ —ñ–º‚Äô—è',
        listeningBtn: '–ê—É–¥—ñ—é–≤–∞–Ω–Ω—è',
        listeningTitle: '–†–µ–∂–∏–º –∞—É–¥—ñ—é–≤–∞–Ω–Ω—è',
        listeningDesc: '–ü—Ä–æ—Å–ª—É—Ö–∞–π—Ç–µ —Å–ª–æ–≤–æ —Ç–∞ –≤–∏–±–µ—Ä—ñ—Ç—å –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥.',
        listeningQuestion: '–ü—Ä–æ—Å–ª—É—Ö–∞–π—Ç–µ —Å–ª–æ–≤–æ —Ç–∞ –≤–∏–±–µ—Ä—ñ—Ç—å –ø–µ—Ä–µ–∫–ª–∞–¥.',
        hangmanBtn: '–í–∏—Å–µ–ª–∏—Ü—ñ',
        hangmanTitle: '–í–∏—Å–µ–ª–∏—Ü—ñ',
        hangmanDesc: '–í–≥–∞–¥–∞–π—Ç–µ –∞–Ω–≥–ª—ñ–π—Å—å–∫–µ —Å–ª–æ–≤–æ –ø–æ –±—É–∫–≤–∞—Ö.',
        hangmanInputPlaceholder: '–í–≤–µ–¥—ñ—Ç—å –±—É–∫–≤—É',
        hangmanSubmit: '–í–≥–∞–¥–∞—Ç–∏',
        hangmanRestart: '–ü–æ—á–∞—Ç–∏ –∑–Ω–æ–≤—É',
        hangmanBack: '–ù–∞–∑–∞–¥',
        hangmanWin: '–í—ñ—Ç–∞—î–º–æ! –í–∏ –≤—ñ–¥–≥–∞–¥–∞–ª–∏ —Å–ª–æ–≤–æ.',
        hangmanLose: word => `–í–∏ –ø—Ä–æ–≥—Ä–∞–ª–∏! –ü—Ä–∞–≤–∏–ª—å–Ω–µ —Å–ª–æ–≤–æ: ${word}`
        ,
        // True/False mini‚Äëgame translations
        tfBtn: '–ü—Ä–∞–≤–¥–∞/–ù–µ–ø—Ä–∞–≤–¥–∞',
        tfTitle: '–ì—Ä–∞ –ü—Ä–∞–≤–¥–∞/–ù–µ–ø—Ä–∞–≤–¥–∞',
        tfDesc: '–í–∏–±–µ—Ä—ñ—Ç—å, —á–∏ –ø—Ä–∞–≤–∏–ª—å–Ω–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥ —Å–ª–æ–≤–∞.',
        tfTrue: '–ü—Ä–∞–≤–¥–∞',
        tfFalse: '–ù–µ–ø—Ä–∞–≤–¥–∞',
        tfScoreText: (s, t) => `–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${s} –∑ ${t}.`
        ,
        // Anagram mini‚Äëgame translations
        anagramBtn: '–ê–Ω–∞–≥—Ä–∞–º–∏',
        anagramTitle: '–ì—Ä–∞ –∞–Ω–∞–≥—Ä–∞–º–∏',
        anagramDesc: '–†–æ–∑—à–∏—Ñ—Ä—É–π—Ç–µ –∞–Ω–≥–ª—ñ–π—Å—å–∫–µ —Å–ª–æ–≤–æ, –≤–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—é—á–∏ –ø—ñ–¥–∫–∞–∑–∫—É –Ω–∞ —É–∫—Ä–∞—ó–Ω—Å—å–∫—ñ–π –º–æ–≤—ñ.',
        anagramSubmit: '–í—ñ–¥–ø–æ–≤—ñ—Å—Ç–∏',
        anagramScoreText: (s, t) => `–í–∞—à —Ä–µ–∑—É–ª—å—Ç–∞—Ç: ${s} –∑ ${t}.`,
        // Irregular verbs screen translations
        irregularBtn: '–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ñ –¥—ñ—î—Å–ª–æ–≤–∞',
        irregularTitle: '–¢–∞–±–ª–∏—Ü—è –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –¥—ñ—î—Å–ª—ñ–≤',
        irregularDesc: '–ü–æ–≤–Ω–∏–π —Å–ø–∏—Å–æ–∫ –Ω–µ–ø—Ä–∞–≤–∏–ª—å–Ω–∏—Ö –¥—ñ—î—Å–ª—ñ–≤ —Ç–∞ —ó—Ö–Ω—ñ —Ñ–æ—Ä–º–∏.',
        irregularHeaders: ['–ë–∞–∑–æ–≤–∞ —Ñ–æ—Ä–º–∞', 'Past Simple', 'Past Participle', '–ü–µ—Ä–µ–∫–ª–∞–¥'],
        // Footer text
        footer: '¬© 2025 Sashkin Apps. –£—Å—ñ –ø—Ä–∞–≤–∞ –∑–∞—Ö–∏—â–µ–Ω—ñ.'
      },
      en: {
        title: 'LexiVerse',
        startTitle: 'LexiVerse',
        startDesc: 'Dive into a world of English learning adventures with LexiVerse!',
        startBtn: 'Start',
        homeTitle: 'Choose a level',
        homeDesc: 'LexiVerse will help you learn English while playing. Choose a difficulty level or explore all words.',
        beginnerBtn: 'Beginner',
        intermediateBtn: 'Intermediate',
        advancedBtn: 'Advanced',
        learnBtn: 'Learn',
        mistakes: 'Mistakes',
        levelTitles: { beginner: 'Level: Beginner', intermediate: 'Level: Intermediate', advanced: 'Level: Advanced', mistakes: 'Review Mistakes', custom: 'Custom level' },
        answerPlaceholder: 'Type your answer...',
        submit: 'Submit',
        resultTitle: 'Result',
        scoreText: (s, t) => `You scored ${s} out of ${t}.`,
        restart: 'Home',
        learnTitle: 'Learn',
        learnDesc: 'Choose a category or search for a word',
        categories: { beginner: 'Beginner', intermediate: 'Intermediate', advanced: 'Advanced', all: 'All words' },
        back: 'Back',
        mistakesTitle: 'Mistakes',
        mistakesDesc: 'Words you answered incorrectly. Review them to remember better.',
        noMistakes: 'You have no mistakes!',
        wrongWordsHeading: 'Your mistakes:',
        memoryBtn: 'Memory Game',
        memoryTitle: 'Memory Game',
        memoryDesc: 'Find pairs of English words and their Ukrainian translations.',
        memoryStart: 'Start game',
        memoryWin: 'Congratulations! You matched all pairs.',
        importBtn: 'Import words',
        customBtn: 'Custom words',
        pronounce: 'Pronounce',
        voiceLabel: 'Voice',
        rateLabel: 'Rate',
        voiceAria: 'TTS voice selection',
        rateAria: 'Playback rate',
        resetBtn: 'Reset data',
        resetConfirm: 'Are you sure you want to reset all data? This will remove your progress.',
        averageResult: avg => `Your average score: ${Math.round(avg * 100)}%`,
        quit: 'Quit',
        noLives: 'No lives left! Game over.',
        // Gamification & personalization
        greeting: name => `Hello, ${name}!`,
        stats: (pts, lvl, streak) => `Points: ${pts} | Level: ${lvl} | Streak: ${streak}`,
        setName: 'Change name',
        listeningBtn: 'Listening',
        listeningTitle: 'Listening mode',
        listeningDesc: 'Listen to the word and choose the correct translation.',
        listeningQuestion: 'Listen to the word and choose the translation.',
        hangmanBtn: 'Hangman',
        hangmanTitle: 'Hangman',
        hangmanDesc: 'Guess the English word letter by letter.',
        hangmanInputPlaceholder: 'Enter a letter',
        hangmanSubmit: 'Guess',
        hangmanRestart: 'Restart',
        hangmanBack: 'Back',
        hangmanWin: 'Congratulations! You guessed the word.',
        hangmanLose: word => `You lost! The correct word was: ${word}`
        ,
        // True/False mini‚Äëgame translations
        tfBtn: 'True/False',
        tfTitle: 'True/False Game',
        tfDesc: 'Choose whether the translation is correct.',
        tfTrue: 'True',
        tfFalse: 'False',
        tfScoreText: (s, t) => `You scored ${s} out of ${t}.`
        ,
        // Anagram mini‚Äëgame translations
        anagramBtn: 'Anagrams',
        anagramTitle: 'Anagram Game',
        anagramDesc: 'Unscramble the English word using the Ukrainian hint.',
        anagramSubmit: 'Submit',
        anagramScoreText: (s, t) => `You scored ${s} out of ${t}.`,
        // Irregular verbs screen translations
        irregularBtn: 'Irregular verbs',
        irregularTitle: 'Irregular verbs table',
        irregularDesc: 'Full list of irregular verbs and their forms.',
        irregularHeaders: ['Base form', 'Past Simple', 'Past Participle', 'Translation'],
        // Footer text
        footer: '¬© 2025 Sashkin Apps. All rights reserved.'
      }
    };
    let currentLang = 'uk';
    let currentLevel = '';
    let questions = [];
    let currentQuestionIndex = 0;
    let score = 0;
    let currentQuestion;
    let mistakes = JSON.parse(localStorage.getItem('mistakes') || '[]');

    // Gamification and personalization variables
    let totalPoints = parseInt(localStorage.getItem('totalPoints') || '0');
    const levelPointsThreshold = 200;
    let username = localStorage.getItem('username') || '';
    let streakCount = parseInt(localStorage.getItem('streakCount') || '0');
    let lastPracticeDate = localStorage.getItem('lastPracticeDate') || '';

    // Track current mode: 'game' (default), 'listening', 'hangman'
    let currentMode = 'game';

    // Lives tracking: total lives and remaining lives for the current game
    let totalLives = 0;
    let remainingLives = 0;

    // Hangman state variables
    let hangmanWord = null;
    let hangmanGuessed = [];
    let hangmanWrong = [];
    let hangmanLivesCount = 0;

    // Element references
    const startScreenElem = document.getElementById('startScreen');
    const startTitleElem = document.getElementById('startTitle');
    const startDescElem = document.getElementById('startDesc');
    const startBtnElem = document.getElementById('startBtn');
    const homeScreenElem = document.getElementById('homeScreen');
    const learnScreenElem = document.getElementById('learnScreen');
    const mistakesScreenElem = document.getElementById('mistakesScreen');
    const gameScreenElem = document.getElementById('gameScreen');
    const resultScreenElem = document.getElementById('resultScreen');
    const learnWordsListElem = document.getElementById('learnWordsList');
    const mistakesListElem = document.getElementById('mistakesList');
    const wrongWordsSection = document.getElementById('wrongWordsSection');
    const memoryScreenElem = document.getElementById('memoryScreen');
    const levelTitleEl = document.getElementById('levelTitle');
    const questionText = document.getElementById('questionText');
    const optionsContainer = document.getElementById('optionsContainer');
    const answerInput = document.getElementById('answerInput');
    const submitBtn = document.getElementById('submitBtn');
    const progressBarFill = document.getElementById('progressBarFill');
    const scoreTextEl = document.getElementById('scoreText');
    const resultTitleEl = document.getElementById('resultTitle');
    const mistakesBtn = document.getElementById('mistakesBtn');

    // Event listeners
    document.getElementById('languageToggle').addEventListener('click', () => {
      currentLang = currentLang === 'uk' ? 'en' : 'uk';
      updateUI();
    });

    // Theme toggle listener
    document.getElementById('themeToggle').addEventListener('click', () => {
      toggleTheme();
    });
    startBtnElem.addEventListener('click', () => {
      startScreenElem.classList.add('hidden');
    });

    // Fallback function in case the inline onclick is triggered before the script runs
    // This ensures the start screen hides correctly when the start button is pressed.
    window.startGame = function() {
      const scr = document.getElementById('startScreen');
      if (scr) {
        scr.classList.add('hidden');
      }
    };

    function updateUI() {
      // Header and start screen
      document.getElementById('title').textContent = ui[currentLang].title;
      document.getElementById('languageToggle').textContent = currentLang === 'uk' ? 'UA / EN' : 'EN / UA';
      startTitleElem.textContent = ui[currentLang].startTitle;
      startDescElem.textContent = ui[currentLang].startDesc;
      // Update the start button label inside its span to preserve the play icon
      const startBtnText = document.getElementById('startBtnText');
      if (startBtnText) startBtnText.textContent = ui[currentLang].startBtn;
      // Home screen
      document.getElementById('homeTitle').textContent = ui[currentLang].homeTitle;
      document.getElementById('homeDesc').textContent = ui[currentLang].homeDesc;
      document.getElementById('beginnerBtn').textContent = ui[currentLang].beginnerBtn;
      document.getElementById('intermediateBtn').textContent = ui[currentLang].intermediateBtn;
      document.getElementById('advancedBtn').textContent = ui[currentLang].advancedBtn;
      document.getElementById('learnBtn').textContent = ui[currentLang].learnBtn;
      document.getElementById('mistakesText').textContent = ui[currentLang].mistakes;
      // Learn screen
      document.getElementById('learnTitle').textContent = ui[currentLang].learnTitle;
      document.getElementById('learnDesc').textContent = ui[currentLang].learnDesc;
      document.getElementById('catBeginner').textContent = ui[currentLang].categories.beginner;
      document.getElementById('catIntermediate').textContent = ui[currentLang].categories.intermediate;
      document.getElementById('catAdvanced').textContent = ui[currentLang].categories.advanced;
      document.getElementById('catAll').textContent = ui[currentLang].categories.all;
      document.getElementById('backBtn').textContent = ui[currentLang].back;
      document.getElementById('backBtn2').textContent = ui[currentLang].back;
      // Mistakes screen
      document.getElementById('mistakesTitle').textContent = ui[currentLang].mistakesTitle;
      document.getElementById('mistakesDesc').textContent = ui[currentLang].mistakesDesc;
      // Game screen controls
      submitBtn.textContent = ui[currentLang].submit;
      answerInput.placeholder = ui[currentLang].answerPlaceholder;
      document.getElementById('restartBtn').textContent = ui[currentLang].restart;
      const quitBtnText = document.getElementById('quitBtnText');
      if (quitBtnText) quitBtnText.textContent = ui[currentLang].quit;

      // Memory game texts
      const memBtn = document.getElementById('memoryBtn');
      if (memBtn) memBtn.textContent = ui[currentLang].memoryBtn;
      const memTitle = document.getElementById('memoryTitle');
      if (memTitle) memTitle.textContent = ui[currentLang].memoryTitle;
      const memDesc = document.getElementById('memoryDesc');
      if (memDesc) memDesc.textContent = ui[currentLang].memoryDesc;
      const memStartText = document.getElementById('memoryStartBtnText');
      if (memStartText) memStartText.textContent = ui[currentLang].memoryStart;
      const memBackText = document.getElementById('memoryBackBtnText');
      if (memBackText) memBackText.textContent = ui[currentLang].back;

      // Import and custom button texts
      const importSpan = document.getElementById('importBtn');
      if (importSpan) importSpan.textContent = ui[currentLang].importBtn;
      const customSpan = document.getElementById('customBtnText');
      if (customSpan) customSpan.textContent = ui[currentLang].customBtn;
      // result text if result screen visible
      if (!resultScreenElem.classList.contains('hidden')) {
        resultTitleEl.textContent = ui[currentLang].resultTitle;
        scoreTextEl.textContent = ui[currentLang].scoreText(score, questions.length);
      
      try { if (document.getElementById('profileModal') && !document.getElementById('profileModal').classList.contains('hidden')) { buildProfile(); } } catch(e) {}
    }
      // update level title
      if (currentLevel) {
        levelTitleEl.textContent = ui[currentLang].levelTitles[currentLevel];
      }

      // Update listening and hangman button labels
      const listeningBtnText = document.getElementById('listeningBtnText');
      if (listeningBtnText) listeningBtnText.textContent = ui[currentLang].listeningBtn;
      const hangmanBtnText = document.getElementById('hangmanBtnText');
      if (hangmanBtnText) hangmanBtnText.textContent = ui[currentLang].hangmanBtn;

      // Update True/False mini‚Äëgame texts
      const tfBtnText = document.getElementById('tfBtnText');
      if (tfBtnText) tfBtnText.textContent = ui[currentLang].tfBtn;
      const tfTitleEl = document.getElementById('tfTitle');
      if (tfTitleEl) tfTitleEl.textContent = ui[currentLang].tfTitle;
      const tfDescEl = document.getElementById('tfDesc');
      if (tfDescEl) tfDescEl.textContent = ui[currentLang].tfDesc;
      const tfTrueBtnText = document.getElementById('tfTrueBtnText');
      if (tfTrueBtnText) tfTrueBtnText.textContent = ui[currentLang].tfTrue;
      const tfFalseBtnText = document.getElementById('tfFalseBtnText');
      if (tfFalseBtnText) tfFalseBtnText.textContent = ui[currentLang].tfFalse;
      // Update True/False back and finish buttons text
      const tfBackBtnText = document.getElementById('tfBackBtnText');
      if (tfBackBtnText) tfBackBtnText.textContent = ui[currentLang].back;
      const tfFinishBtnText = document.getElementById('tfFinishBtnText');
      if (tfFinishBtnText) tfFinishBtnText.textContent = ui[currentLang].back;

      // Update Anagram mini‚Äëgame texts
      const anagramBtnText = document.getElementById('anagramBtnText');
      if (anagramBtnText) anagramBtnText.textContent = ui[currentLang].anagramBtn;
      const anagramTitleEl = document.getElementById('anagramTitle');
      if (anagramTitleEl) anagramTitleEl.textContent = ui[currentLang].anagramTitle;
      const anagramDescEl = document.getElementById('anagramDesc');
      if (anagramDescEl) anagramDescEl.textContent = ui[currentLang].anagramDesc;
      const anagramSubmitBtn = document.getElementById('anagramSubmitBtn');
      if (anagramSubmitBtn) anagramSubmitBtn.textContent = ui[currentLang].anagramSubmit;
      // Update Anagram back and finish buttons text
      const anagramBackBtnText = document.getElementById('anagramBackBtnText');
      if (anagramBackBtnText) anagramBackBtnText.textContent = ui[currentLang].back;
      const anagramFinishBtnText = document.getElementById('anagramFinishBtnText');
      if (anagramFinishBtnText) anagramFinishBtnText.textContent = ui[currentLang].back;
      // Update Hangman screen texts
      const hangmanTitleEl = document.getElementById('hangmanTitle');
      if (hangmanTitleEl) hangmanTitleEl.textContent = ui[currentLang].hangmanTitle;
      const hangmanDescEl = document.getElementById('hangmanDesc');
      if (hangmanDescEl) hangmanDescEl.textContent = ui[currentLang].hangmanDesc;
      const hangmanSubmitBtn = document.getElementById('hangmanSubmitBtn');
      if (hangmanSubmitBtn) hangmanSubmitBtn.textContent = ui[currentLang].hangmanSubmit;
      const hangmanRestartBtn = document.getElementById('hangmanRestartBtn');
      if (hangmanRestartBtn) hangmanRestartBtn.textContent = ui[currentLang].hangmanRestart;
      const hangmanBackBtn = document.getElementById('hangmanBackBtn');
      if (hangmanBackBtn) hangmanBackBtn.textContent = ui[currentLang].hangmanBack;
      const hangmanInput = document.getElementById('hangmanInput');
      if (hangmanInput) hangmanInput.placeholder = ui[currentLang].hangmanInputPlaceholder;

      // Localize TTS controls labels and aria
      const voiceLabelEl = document.getElementById('voiceLabel');
      if (voiceLabelEl) voiceLabelEl.textContent = ui[currentLang].voiceLabel;
      const rateLabelEl = document.getElementById('rateLabel');
      if (rateLabelEl) rateLabelEl.textContent = ui[currentLang].rateLabel;
      const voiceSelectEl = document.getElementById('voiceSelect');
      if (voiceSelectEl) voiceSelectEl.setAttribute('aria-label', ui[currentLang].voiceAria);
      const rateRangeEl = document.getElementById('rateRange');
      if (rateRangeEl) rateRangeEl.setAttribute('aria-label', ui[currentLang].rateAria);


      // Update Irregular verbs screen texts
      const irregularBtnSpan = document.getElementById('irregularBtnText');
      if (irregularBtnSpan) irregularBtnSpan.textContent = ui[currentLang].irregularBtn;
      const irregularTitleEl = document.getElementById('irregularTitle');
      if (irregularTitleEl) irregularTitleEl.textContent = ui[currentLang].irregularTitle;
      const irregularDescEl = document.getElementById('irregularDesc');
      if (irregularDescEl) irregularDescEl.textContent = ui[currentLang].irregularDesc;
      const irregularBackBtnText = document.getElementById('irregularBackBtn');
      if (irregularBackBtnText) irregularBackBtnText.textContent = ui[currentLang].back;
      // If the irregular verbs screen is visible, regenerate the table headers to match the current language
      const irregularScreen = document.getElementById('irregularScreen');
      if (irregularScreen && !irregularScreen.classList.contains('hidden')) {
        renderIrregularTable();
      }

      // Update top bar import and reset button texts
      const importTopSpan = document.getElementById('importTopText');
      if (importTopSpan) importTopSpan.textContent = ui[currentLang].importBtn;
      const resetTopSpan = document.getElementById('resetBtnText');
      // Update profile button text
      const profileTopSpan = document.getElementById('profileTopText');
      if (profileTopSpan) profileTopSpan.textContent = (ui[currentLang] && ui[currentLang].profileBtn) ? ui[currentLang].profileBtn : (currentLang==='uk' ? '–ü—Ä–æ—Ñ—ñ–ª—å' : 'Profile');
      // Localize profile modal static labels
      const _pt = document.getElementById('profileTitle'); if (_pt) _pt.textContent = (ui[currentLang] && ui[currentLang].profileTitle) ? ui[currentLang].profileTitle : (currentLang==='uk' ? '–ü—Ä–æ—Ñ—ñ–ª—å' : 'Profile');
      const _pex = document.getElementById('profileExportBtn'); if (_pex) _pex.textContent = (ui[currentLang] && ui[currentLang].profileExport) ? ui[currentLang].profileExport : (currentLang==='uk' ? '–ï–∫—Å–ø–æ—Ä—Ç CSV' : 'Export CSV');
      const _pcl = document.getElementById('profileClearBtn'); if (_pcl) _pcl.textContent = (ui[currentLang] && ui[currentLang].profileClear) ? ui[currentLang].profileClear : (currentLang==='uk' ? '–û—á–∏—Å—Ç–∏—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é' : 'Clear history');
      const _pcb = document.getElementById('profileCloseBtn'); if (_pcb && _pcb.tagName==='BUTTON') _pcb.textContent = (ui[currentLang] && ui[currentLang].close) ? ui[currentLang].close : (currentLang==='uk' ? '–ó–∞–∫—Ä–∏—Ç–∏' : 'Close');
      const _ps1 = document.getElementById('profileSummaryTitle'); if (_ps1) _ps1.textContent = (ui[currentLang] && ui[currentLang].summary) ? ui[currentLang].summary : (currentLang==='uk' ? '–ó–≤–µ–¥–µ–Ω–Ω—è' : 'Summary');
      const _ps2 = document.getElementById('profileByLevelTitle'); if (_ps2) _ps2.textContent = (ui[currentLang] && ui[currentLang].byLevel) ? ui[currentLang].byLevel : (currentLang==='uk' ? '–ó–∞ —Ä—ñ–≤–Ω—è–º–∏' : 'By levels');
      const _ps3 = document.getElementById('profileByModeTitle'); if (_ps3) _ps3.textContent = (ui[currentLang] && ui[currentLang].byMode) ? ui[currentLang].byMode : (currentLang==='uk' ? '–ó–∞ —ñ–≥—Ä–∞–º–∏' : 'By games');
      const _ps4 = document.getElementById('profileRecentTitle'); if (_ps4) _ps4.textContent = (ui[currentLang] && ui[currentLang].recent) ? ui[currentLang].recent : (currentLang==='uk' ? '–û—Å—Ç–∞–Ω–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏' : 'Recent results');
      if (resetTopSpan) resetTopSpan.textContent = ui[currentLang].resetBtn;

      // Update user info (greeting and stats) and setName button
      updateUserInfo();

      // Update footer text
      const footerEl = document.getElementById('footerText');
      if (footerEl && ui[currentLang].footer) {
        footerEl.textContent = ui[currentLang].footer;
      }

      // ensure custom button visibility according to imported words
      updateCustomButton();

      // If currently showing a question, update the audio button text
      if (!gameScreenElem.classList.contains('hidden') && currentQuestion) {
        renderAudioButton(currentQuestion.word.en);
        // Also update the question text and answer placeholder to reflect the current language
        const askEng = currentQuestion.askEnglish;
        const w = currentQuestion.word;
        const baseDisplay = stripDigits(w.en);
        if (currentMode === 'listening') {
          // Listening mode uses fixed prompt
          questionText.textContent = ui[currentLang].listeningQuestion;
        } else if (currentQuestion.unscramble) {
          const scrambled = currentQuestion.scrambled || shuffleArray(stripDigits(w.en).split('')).join('');
          questionText.textContent = currentLang === 'uk'
            ? `–†–æ–∑—à–∏—Ñ—Ä—É–π—Ç–µ —Å–ª–æ–≤–æ: ${scrambled} (${w.uk})`
            : `Unscramble: ${scrambled} (${w.uk})`;
          answerInput.placeholder = currentLang === 'uk' ? '–í–≤–µ–¥—ñ—Ç—å —Å–ª–æ–≤–æ –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é' : 'Enter the English word';
        } else if (answerInput && !answerInput.classList.contains('hidden')) {
          // input translation prompt
          if (askEng) {
            questionText.textContent = currentLang === 'uk'
              ? `–í–≤–µ–¥—ñ—Ç—å –∞–Ω–≥–ª—ñ–π—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥ –¥–ª—è: ${w.uk}`
              : `Type the English translation for: ${w.uk}`;
            answerInput.placeholder = currentLang === 'uk' ? '–ê–Ω–≥–ª—ñ–π—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥' : 'English translation';
          } else {
            questionText.textContent = currentLang === 'uk'
              ? `–í–≤–µ–¥—ñ—Ç—å —É–∫—Ä–∞—ó–Ω—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥ –¥–ª—è: ${baseDisplay}`
              : `Type the Ukrainian translation for: ${baseDisplay}`;
            answerInput.placeholder = currentLang === 'uk' ? '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥' : 'Ukrainian translation';
          }
        } else {
          // choice type question (multiple choice)
          questionText.textContent = currentLang === 'uk'
            ? askEng ? `–ü–µ—Ä–µ–∫–ª–∞–¥—ñ—Ç—å –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é: ${w.uk}` : `–ü–µ—Ä–µ–∫–ª–∞–¥—ñ—Ç—å —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é: ${baseDisplay}`
            : askEng ? `Translate to English: ${w.uk}` : `Translate to Ukrainian: ${baseDisplay}`;
        }
      }
    }

    function goToLevel(level) {
      // Ensure we are in standard quiz mode
      currentMode = 'game';
      currentLevel = level;
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      // Ensure the True/False and Anagram screens are hidden when starting a standard quiz
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      gameScreenElem.classList.remove('hidden');
      wrongWordsSection.innerHTML = '';
      // prepare questions
      let wordList = [];
      if (level === 'beginner') wordList = beginnerWords.slice();
      if (level === 'intermediate') wordList = intermediateWords.slice();
      if (level === 'advanced') wordList = advancedWords.slice();
      if (level === 'mistakes') wordList = mistakes.slice();
      if (level === 'custom') wordList = customWords.slice();
      const count = Math.min(10, wordList.length);
      // Set number of questions (increase to 100 for full game)
      const questionCount = Math.min(100, wordList.length);
      questions = shuffleArray(wordList).slice(0, questionCount).map(w => {
        const r = Math.random();
        let type;
        if (r < 0.4) type = 'choice';
        else if (r < 0.7) type = 'input';
        else type = 'sentence';
        return { word: w, type: type };
      });
      currentQuestionIndex = 0;
      score = 0;
      // Set lives based on selected level
      if (level === 'beginner') {
        totalLives = 9;
      } else if (level === 'intermediate') {
        totalLives = 6;
      } else if (level === 'advanced') {
        totalLives = 3;
      } else {
        totalLives = 9;
      }
      remainingLives = totalLives;
      levelTitleEl.textContent = ui[currentLang].levelTitles[level];
      answerInput.value = '';
      updateLivesDisplay();
      showQuestion();
      updateUI();
    }

    function showQuestion() {
      currentQuestion = questions[currentQuestionIndex];
      const { word, type } = currentQuestion;
      progressBarFill.style.width = ((currentQuestionIndex) / questions.length) * 100 + '%';
      optionsContainer.innerHTML = '';
      answerInput.classList.add('hidden');
      submitBtn.classList.add('hidden');
      // Render audio button for the current English word so users can hear pronunciation
      renderAudioButton(word.en);
      // Special handling for listening mode: always ask for Ukrainian translation and play audio automatically
      if (currentMode === 'listening') {
        // Play audio automatically
        // Speak the base English word without numeric suffixes in listening mode
        const baseWord = stripDigits(word.en);
        safeSpeak(baseWord, 'en-US');
        questionText.textContent = ui[currentLang].listeningQuestion;
        currentQuestion.askEnglish = false;
        const opts = generateOptions(word, false);
        opts.forEach(option => {
          const div = document.createElement('div');
          div.className = 'option';
          div.textContent = option.text;
          div.addEventListener('click', () => selectOption(option));
          optionsContainer.appendChild(div);
        });
        return;
      }
      if (type === 'sentence') {
        // fill‚Äëin‚Äëthe‚Äëblank question using a simple template and translation hint
        const templates = [
          'I have a ___',
          'This is my ___',
          'I like to ___',
          'Please bring the ___',
          'Do you like ___?',
          'We need more ___'
        ];
        const template = templates[Math.floor(Math.random() * templates.length)];
        const prompt = template.replace('___', '_____');
        questionText.textContent = currentLang === 'uk'
          ? `–ó–∞–ø–æ–≤–Ω—ñ—Ç—å –ø—Ä–æ–ø—É—Å–∫: ${prompt} (${word.uk})`
          : `Fill in the blank: ${prompt} (${word.uk})`;
        currentQuestion.askEnglish = true;
        currentQuestion.unscramble = false;
        answerInput.placeholder = currentLang === 'uk' ? '–í–≤–µ–¥—ñ—Ç—å –∞–Ω–≥–ª—ñ–π—Å—å–∫–µ —Å–ª–æ–≤–æ' : 'Enter the English word';
        answerInput.classList.remove('hidden');
        submitBtn.classList.remove('hidden');
      } else if (type === 'choice') {
        const askEnglish = Math.random() < 0.5;
        currentQuestion.askEnglish = askEnglish;
        const displayEn = stripDigits(word.en);
        questionText.textContent = currentLang === 'uk'
          ? askEnglish ? `–ü–µ—Ä–µ–∫–ª–∞–¥—ñ—Ç—å –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é: ${word.uk}` : `–ü–µ—Ä–µ–∫–ª–∞–¥—ñ—Ç—å —É–∫—Ä–∞—ó–Ω—Å—å–∫–æ—é: ${displayEn}`
          : askEnglish ? `Translate to English: ${word.uk}` : `Translate to Ukrainian: ${displayEn}`;
        const opts = generateOptions(word, askEnglish);
        opts.forEach(option => {
          const div = document.createElement('div');
          div.className = 'option';
          div.textContent = option.text;
          div.addEventListener('click', () => selectOption(option));
          optionsContainer.appendChild(div);
        });
      } else {
        // input or unscramble question
        const askEnglish = Math.random() < 0.5;
        currentQuestion.askEnglish = askEnglish;
        const unscramble = Math.random() < 0.5;
        currentQuestion.unscramble = unscramble;
        if (unscramble) {
          const base = stripDigits(word.en);
          const scrambled = shuffleArray(base.split('')).join('');
          currentQuestion.scrambled = scrambled;
          questionText.textContent = currentLang === 'uk'
            ? `–†–æ–∑—à–∏—Ñ—Ä—É–π—Ç–µ —Å–ª–æ–≤–æ: ${scrambled} (${word.uk})`
            : `Unscramble: ${scrambled} (${word.uk})`;
          answerInput.placeholder = currentLang === 'uk' ? '–í–≤–µ–¥—ñ—Ç—å —Å–ª–æ–≤–æ –∞–Ω–≥–ª—ñ–π—Å—å–∫–æ—é' : 'Enter the English word';
        } else {
          if (askEnglish) {
            questionText.textContent = currentLang === 'uk'
              ? `–í–≤–µ–¥—ñ—Ç—å –∞–Ω–≥–ª—ñ–π—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥ –¥–ª—è: ${word.uk}`
              : `Type the English translation for: ${word.uk}`;
            answerInput.placeholder = currentLang === 'uk' ? '–ê–Ω–≥–ª—ñ–π—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥' : 'English translation';
          } else {
            const displayEn2 = stripDigits(word.en);
            questionText.textContent = currentLang === 'uk'
              ? `–í–≤–µ–¥—ñ—Ç—å —É–∫—Ä–∞—ó–Ω—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥ –¥–ª—è: ${displayEn2}`
              : `Type the Ukrainian translation for: ${displayEn2}`;
            answerInput.placeholder = currentLang === 'uk' ? '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∏–π –ø–µ—Ä–µ–∫–ª–∞–¥' : 'Ukrainian translation';
          }
        }
        answerInput.classList.remove('hidden');
        submitBtn.classList.remove('hidden');
      }
    }

    
function generateOptions(correctWord, askEnglish) {
      let pool;
      if (currentLevel === 'beginner') {
        pool = beginnerWords;
      } else if (currentLevel === 'intermediate') {
        pool = intermediateWords;
      } else if (currentLevel === 'advanced') {
        pool = advancedWords;
      } else if (currentLevel === 'mistakes') {
        pool = mistakes;
      } else if (currentLevel === 'custom') {
        pool = customWords;
      } else {
        pool = beginnerWords.concat(intermediateWords, advancedWords, customWords, mistakes);
      }

      if (!pool || pool.length === 0) {
        pool = beginnerWords.concat(intermediateWords, advancedWords, customWords, mistakes);
      }

      const correctText = askEnglish ? stripDigits(correctWord.en) : correctWord.uk;
      const options = [{ text: correctText, correct: true }];

      // Build unique wrong answers (avoid duplicates after stripDigits too)
      const seen = new Set([correctText.trim().toLowerCase()]);
      const wrongCandidates = pool.filter(w => w.en !== correctWord.en);
      const shuffled = shuffleArray(wrongCandidates);
      for (let k = 0; k < shuffled.length && options.length < 4; k++) {
        const w = shuffled[k];
        const wrongText = askEnglish ? stripDigits(w.en) : w.uk;
        const key = (wrongText || '').trim().toLowerCase();
        if (!key || seen.has(key)) continue;
        options.push({ text: wrongText, correct: false });
        seen.add(key);
      }

      // Fallback: if still fewer than 4, pull from full vocabulary
      if (options.length < 4) {
        const all = beginnerWords.concat(intermediateWords, advancedWords, customWords, mistakes);
        const shuffledAll = shuffleArray(all);
        for (let z = 0; z < shuffledAll.length && options.length < 4; z++) {
          const w = shuffledAll[z];
          const wrongText = askEnglish ? stripDigits(w.en) : w.uk;
          const key = (wrongText || '').trim().toLowerCase();
          if (!key || seen.has(key)) continue;
          options.push({ text: wrongText, correct: false });
          seen.add(key);
        }
      }

      // Shuffle and ensure exactly one correct entry exists
      let out = shuffleArray(options);
      const correctCount = out.filter(o => o.correct).length;
      if (correctCount === 0) {
        // Replace a random slot with the correct answer
        const idx = Math.floor(Math.random() * out.length);
        out[idx] = { text: correctText, correct: true };
      } else if (correctCount > 1) {
        // Deduplicate extra correct flags
        let flagged = false;
        out = out.map(o => {
          if (o.correct) {
            if (flagged) return { text: o.text, correct: false };
            flagged = true;
            return o;
          }
          return o;
        });
      }

      return out;
    }


    function selectOption(option) {
      if (option.correct) {
        score++;
      } else {
        addMistake(currentQuestion.word);
        // Decrement lives on incorrect answer
        if (remainingLives > 0) {
          remainingLives--;
          updateLivesDisplay();
        }
        if (remainingLives <= 0) {
          finishQuiz();
          return;
        }
      }
      goNextQuestion();
    }

    function submitAnswer() {
      const { word, askEnglish, unscramble } = currentQuestion;
      const userInput = answerInput.value.trim().toLowerCase();
      let correct;
      if (unscramble) {
        // When unscrambling, compare against the base word without numeric suffixes
        correct = stripDigits(word.en).toLowerCase();
      } else if (askEnglish) {
        // For English translation questions, use the base word
        correct = stripDigits(word.en).toLowerCase();
      } else {
        correct = word.uk.toLowerCase();
      }
      if (userInput === correct) {
        score++;
      } else {
        addMistake(word);
        if (remainingLives > 0) {
          remainingLives--;
          updateLivesDisplay();
        }
        if (remainingLives <= 0) {
          answerInput.value = '';
          finishQuiz();
          return;
        }
      }
      answerInput.value = '';
      goNextQuestion();
    }

    function addMistake(word) {
      if (!mistakes.some(w => w.en === word.en)) {
        mistakes.push(word);
      }
      localStorage.setItem('mistakes', JSON.stringify(mistakes));
    }

    function goNextQuestion() {
      currentQuestionIndex++;
      if (currentQuestionIndex < questions.length) {
        showQuestion();
      } else {
        finishQuiz();
      }
    }

    function finishQuiz() {
      progressBarFill.style.width = '100%';
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.remove('hidden');
      if (remainingLives <= 0) {
        resultTitleEl.textContent = ui[currentLang].noLives;
      } else {
        resultTitleEl.textContent = ui[currentLang].resultTitle;
      }
      scoreTextEl.textContent = ui[currentLang].scoreText(score, questions.length);
      // Save current result into history for progress tracking
      let history = JSON.parse(localStorage.getItem('history') || '[]');
      history.push({ level: currentLevel, score: score, total: questions.length, date: new Date().toISOString(), mode: currentMode });
      localStorage.setItem('history', JSON.stringify(history));

      if (mistakes.length > 0 && currentLevel !== 'mistakes') {
        let html = '<p>' + ui[currentLang].wrongWordsHeading + '</p><ul>';
        mistakes.forEach(item => {
          // Display base English word without numeric suffixes in wrong words list
          const base = stripDigits(item.en);
          html += `<li>${base} ‚Äì ${item.uk}</li>`;
        });
        html += '</ul>';
        wrongWordsSection.innerHTML = html;
      } else {
        wrongWordsSection.innerHTML = '';
      }
      // Show average performance across all attempts
      const hist = JSON.parse(localStorage.getItem('history') || '[]');
      let avg = 0;
      if (hist.length > 0) {
        avg = hist.reduce((acc, h) => acc + (h.score / h.total), 0) / hist.length;
      }
      const avgText = ui[currentLang].averageResult(avg);
      const avgDiv = document.createElement('p');
      avgDiv.textContent = avgText;
      wrongWordsSection.appendChild(avgDiv);
      updateMistakesButton();

      // Gamification: award points and update streak when finishing a quiz in standard mode
      if (currentMode === 'game' || currentMode === 'listening') {
        awardPoints(score);
        updateStreak();
        updateUserInfo();
      }
    }

    function restart() {
      resultScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      homeScreenElem.classList.remove('hidden');
      currentLevel = '';
      updateUI();
    }

    function openLearn() {
      homeScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      learnScreenElem.classList.remove('hidden');
      document.getElementById('searchInput').value = '';
      learnWordsListElem.innerHTML = '';
      updateUI();
    }

    function openMistakes() {
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      mistakesScreenElem.classList.remove('hidden');
      renderMistakes();
      updateUI();
    }

    function backToHome() {
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      // Hide irregular verbs screen when returning home
      const irr = document.getElementById('irregularScreen');
      if (irr) irr.classList.add('hidden');
      homeScreenElem.classList.remove('hidden');
      updateUI();
    }

    function selectCategory(category) {
      let words;
      if (category === 'beginner') words = beginnerWords;
      else if (category === 'intermediate') words = intermediateWords;
      else if (category === 'advanced') words = advancedWords;
      else words = beginnerWords.concat(intermediateWords, advancedWords);
      renderWords(words);
    }

    function renderWords(words) {
      learnWordsListElem.innerHTML = '';
      words.forEach(w => {
        const card = document.createElement('div');
        card.className = 'word-card';
        // Remove numeric suffixes when displaying words in the learn screen
        const base = stripDigits(w.en);
        card.innerHTML = `<strong>${base}</strong><br/><span>${w.uk}</span>`;
        learnWordsListElem.appendChild(card);
      });
    }

    /**
     * Render the irregular verbs table. This function constructs a
     * table header using the current language headers and then populates
     * each row with the irregular verbs list. Styling for cells is
     * applied inline to blend with the existing design.
     */
    function renderIrregularTable() {
      const table = document.getElementById('irregularTable');
      if (!table) return;
      table.innerHTML = '';
      // Create header
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      ui[currentLang].irregularHeaders.forEach(head => {
        const th = document.createElement('th');
        th.textContent = head;
        th.style.background = 'var(--primary-color)';
        th.style.color = '#fff';
        th.style.padding = '8px';
        th.style.border = '1px solid var(--primary-color)';
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);
      const tbody = document.createElement('tbody');
      irregularVerbs.forEach(item => {
        const tr = document.createElement('tr');
        ['base', 'past', 'participle', 'uk'].forEach(key => {
          const td = document.createElement('td');
          td.textContent = item[key];
          td.style.padding = '8px';
          td.style.border = '1px solid var(--primary-color)';
          tr.appendChild(td);
        });
        tbody.appendChild(tr);
      });
      table.appendChild(tbody);
    }

    /**
     * Navigate to the irregular verbs table screen. Hides all other
     * screens and shows the irregular verbs container. It then renders
     * the table and updates UI texts to match the chosen language.
     */
    function openIrregular() {
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      const irr = document.getElementById('irregularScreen');
      if (irr) irr.classList.remove('hidden');
      renderIrregularTable();
      updateUI();
    }

    function filterWords() {
      const query = document.getElementById('searchInput').value.trim().toLowerCase();
      let allWords = beginnerWords.concat(intermediateWords, advancedWords);
      const filtered = allWords.filter(w =>
        w.en.toLowerCase().includes(query) || w.uk.toLowerCase().includes(query)
      );
      renderWords(filtered);
    }

    function renderMistakes() {
      mistakesListElem.innerHTML = '';
      if (mistakes.length === 0) {
        mistakesListElem.innerHTML = `<p>${ui[currentLang].noMistakes}</p>`;
        return;
      }
      mistakes.forEach(w => {
        const card = document.createElement('div');
        card.className = 'word-card';
        // Show base English word without numeric suffixes in mistakes list
        const base = stripDigits(w.en);
        card.innerHTML = `<strong>${base}</strong><br/><span>${w.uk}</span>`;
        mistakesListElem.appendChild(card);
      });
    }

    /* ---------------- Memory game functions ---------------- */
    function openMemory() {
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      memoryScreenElem.classList.remove('hidden');
      startMemoryGame();
      updateUI();
    }

    let memoryLock = false;
    let firstMemoryCard = null;
    let secondMemoryCard = null;

    function startMemoryGame() {
      // Build a list of unique word pairs based on the base English word (without numeric suffixes).
      const allWords = beginnerWords.concat(intermediateWords, advancedWords);
      const uniquePairs = [];
      const seenBases = new Set();
      for (const w of allWords) {
        const base = stripDigits(w.en);
        if (!seenBases.has(base)) {
          seenBases.add(base);
          uniquePairs.push({ en: base, uk: w.uk });
        }
      }
      // Shuffle and select six unique pairs for the memory game
      const pairs = shuffleArray(uniquePairs).slice(0, 6);
      const cards = [];
      pairs.forEach((w, index) => {
        cards.push({ id: index, text: w.en });
        cards.push({ id: index, text: w.uk });
      });
      const shuffled = shuffleArray(cards);
      const grid = document.getElementById('memoryGrid');
      grid.innerHTML = '';
      firstMemoryCard = null;
      secondMemoryCard = null;
      memoryLock = false;
      shuffled.forEach(card => {
        const div = document.createElement('div');
        div.className = 'memory-card';
        div.dataset.id = card.id;
        div.dataset.text = card.text;
        div.addEventListener('click', onMemoryCardClick);
        grid.appendChild(div);
      });
    }

    function onMemoryCardClick(e) {
      const card = e.currentTarget;
      if (memoryLock || card.classList.contains('matched') || card === firstMemoryCard) return;
      flipMemoryCard(card);
      if (!firstMemoryCard) {
        firstMemoryCard = card;
      } else {
        secondMemoryCard = card;
        memoryLock = true;
        if (firstMemoryCard.dataset.id === secondMemoryCard.dataset.id) {
          firstMemoryCard.classList.add('matched');
          secondMemoryCard.classList.add('matched');
          firstMemoryCard = null;
          secondMemoryCard = null;
          memoryLock = false;
          checkMemoryWin();
        } else {
          setTimeout(() => {
            unflipMemoryCard(firstMemoryCard);
            unflipMemoryCard(secondMemoryCard);
            firstMemoryCard = null;
            secondMemoryCard = null;
            memoryLock = false;
          }, 800);
        }
      }
    }

    function flipMemoryCard(card) {
      card.classList.add('flipped');
      card.textContent = card.dataset.text;
    }

    function unflipMemoryCard(card) {
      card.classList.remove('flipped');
      card.textContent = '';
    }

    function checkMemoryWin() {
      const unmatched = document.querySelectorAll('.memory-card:not(.matched)');
      if (unmatched.length === 0) {
        alert(ui[currentLang].memoryWin);
      }
    }

    /* ---------------- CSV import functions ---------------- */
    let customWords = [];

    function importWords(event) {
      const file = event.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(e) {
        const text = e.target.result;
        const lines = text.split(/\r?\n/);
        lines.forEach(line => {
          if (!line.trim()) return;
          const parts = line.split(/[,;\t]/);
          if (parts.length >= 2) {
            const en = parts[0].trim();
            const uk = parts[1].trim();
            if (en && uk) {
              customWords.push({ en: en, uk: uk });
            }
          }
        });
        updateCustomButton();
        updateUI();
      };
      reader.readAsText(file);
    }

    function updateCustomButton() {
      const btn = document.getElementById('customBtn');
      if (!btn) return;
      if (customWords.length > 0) {
        btn.classList.remove('hidden');
      } else {
        btn.classList.add('hidden');
      }
    }

    function updateMistakesButton() {
      if (mistakes.length > 0) {
        mistakesBtn.classList.remove('hidden');
      } else {
        mistakesBtn.classList.add('hidden');
      }
    }

    function shuffleArray(arr) {
      const array = arr.slice();
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    /**
     * Update the visual display of remaining lives. It renders a series of
     * heart emojis equal to the number of remaining lives. Called whenever
     * lives are set or decremented.
     */
    function updateLivesDisplay() {
      const livesElem = document.getElementById('livesContainer');
      if (!livesElem) return;
      let hearts = '';
      for (let i = 0; i < remainingLives; i++) {
        hearts += '‚ù§';
      }
      livesElem.textContent = hearts;
    }

    /**
     * Quit the current game and return to the home screen. Does not save
     * progress to history. Resets current level and hides all screens except home.
     */
    function quitGame() {
      gameScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      homeScreenElem.classList.remove('hidden');
      // Hide mini‚Äëgame screens
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      currentLevel = '';
      currentMode = 'game';
      updateUI();
    }
    /**
     * Speak text safely: cancel any ongoing speech and speak with the given lang.
     */
    function safeSpeak(text, lang = 'en-US') {
      try {
        if (!('speechSynthesis' in window)) return;
        speechSynthesis.cancel();
        const utt = new SpeechSynthesisUtterance(text);
        utt.lang = lang || 'en-US';
        speechSynthesis.speak(utt);
      } catch (e) {
        // fail silently
      }
    }
    

    /**
     * Render an audio button that pronounces the given English word when clicked.
     * This uses the browser's Web Speech API (speechSynthesis) to speak the word.
     * The button text is localized based on the current language.
     * @param {string} wordEn - The English word to pronounce
     */
    
    /* ---------------- Speech Synthesis Setup ---------------- */
    let selectedVoiceURI = localStorage.getItem('voiceURI') || '';
    let selectedRate = parseFloat(localStorage.getItem('voiceRate') || '1');

    function populateVoiceList() {
      try {
        if (!('speechSynthesis' in window)) return;
        const select = document.getElementById('voiceSelect');
        if (!select) return;
        const voices = speechSynthesis.getVoices();
        // Filter to common langs we care about first (English + Ukrainian if present)
        const preferredLangs = ['en-US','en-GB','en','uk-UA','uk'];
        const qualityScore = (v) => {
          const name = (v.name || '').toLowerCase();
          let score = 0;
          if (name.includes('microsoft')) score += 5;
          if (name.includes('google')) score += 4;
          if (name.includes('siri') || name.includes('enhanced') || name.includes('natural') || name.includes('neural') || name.includes('online')) score += 3;
          // prefer US/GB English for our content
          if (/^en(-|$)/.test(v.lang)) score += 2;
          return score;
        };
        const sorted = voices.slice().sort((a,b) => {
          const la = preferredLangs.indexOf(a.lang); const lb = preferredLangs.indexOf(b.lang);
          const ldiff = (la === -1 ? 999 : la) - (lb === -1 ? 999 : lb);
          if (ldiff !== 0) return ldiff;
          return qualityScore(b) - qualityScore(a);
        });

        const current = selectedVoiceURI;
        select.innerHTML = '';
        sorted.forEach(v => {
          const opt = document.createElement('option');
          opt.value = v.voiceURI || v.name;
          opt.textContent = `${v.name} (${v.lang})`;
          if (current && (v.voiceURI === current || v.name === current)) {
            opt.selected = true;
          }
          select.appendChild(opt);
        });

        // If nothing selected yet, try to auto-pick a high‚Äëquality English voice
        if (!current && sorted.length) {
          const best = sorted.find(v => /^en(-|$)/.test(v.lang)) || sorted[0];
          selectedVoiceURI = best.voiceURI || best.name;
          localStorage.setItem('voiceURI', selectedVoiceURI);
          // Mark chosen
          for (const opt of select.options) {
            if (opt.value === selectedVoiceURI) { opt.selected = true; break; }
          }
        }

        // Rate UI
        const rate = document.getElementById('rateRange');
        if (rate) rate.value = String(selectedRate || 1);
      } catch (e) {}
    }

    function getSelectedVoice() {
      if (!('speechSynthesis' in window)) return null;
      const voices = speechSynthesis.getVoices();
      const uri = selectedVoiceURI;
      let v = voices.find(v => (v.voiceURI === uri || v.name === uri));
      if (!v) {
        // fallback by language preference
        v = voices.find(v => /^en(-|$)/.test(v.lang)) || voices[0] || null;
      }
      return v || null;
    }

    // Enhance safeSpeak to use selected voice and rate
    const _origSafeSpeak = typeof safeSpeak === 'function' ? safeSpeak : null;
    function safeSpeak(text, lang = 'en-US') {
      try {
        if (!('speechSynthesis' in window)) return;
        speechSynthesis.cancel();
        const utt = new SpeechSynthesisUtterance(text);
        const v = getSelectedVoice();
        if (v) {
          utt.voice = v;
          utt.lang = v.lang || lang;
        } else {
          utt.lang = lang || 'en-US';
        }
        const rateEl = document.getElementById('rateRange');
        const rate = rateEl ? parseFloat(rateEl.value) : (selectedRate || 1);
        utt.rate = isFinite(rate) ? Math.max(0.5, Math.min(2, rate)) : 1;
        speechSynthesis.speak(utt);
      } catch (e) {}
    }

    function initVoiceControls() {
      try { var _vs = document.getElementById('voiceSelect'); if (_vs) { _vs.setAttribute('aria-label', (ui[currentLang] && ui[currentLang].voiceAria) || 'TTS voice selection'); } } catch(e) {}
      try { var _rr = document.getElementById('rateRange'); if (_rr) { _rr.setAttribute('aria-label', (ui[currentLang] && ui[currentLang].rateAria) || 'Playback rate'); } } catch(e) {}
      if (!('speechSynthesis' in window)) return;
      populateVoiceList();
      try {
        window.speechSynthesis.onvoiceschanged = () => populateVoiceList();
      } catch (e) {}
      const select = document.getElementById('voiceSelect');
      if (select) {
        select.addEventListener('change', (e) => {
          selectedVoiceURI = e.target.value;
          localStorage.setItem('voiceURI', selectedVoiceURI);
        });
      }
      const rate = document.getElementById('rateRange');
      if (rate) {
        rate.addEventListener('input', (e) => {
          selectedRate = parseFloat(e.target.value || '1');
          localStorage.setItem('voiceRate', String(selectedRate));
        });
      }
    }
function renderAudioButton(wordEn) {
      const container = document.getElementById('audioContainer');
      if (!container) return;
      container.innerHTML = '';
      if (!wordEn) return;
      const btn = document.createElement('button');
      btn.className = 'btn';
      btn.style.marginBottom = '10px';
      btn.textContent = ui[currentLang].pronounce;
      btn.addEventListener('click', () => {
        // Pronounce the base English word without numeric suffixes
        const baseWord = stripDigits(wordEn);
        safeSpeak(baseWord, 'en-US');
      });
      container.appendChild(btn);
    }

    /* ---------------- Gamification & Personalization ---------------- */
    /**
     * Prompt the user to enter their name. The entered name is stored in
     * localStorage and used to personalize greetings. If the user cancels or
     * enters an empty string, the name remains unchanged.
     */
    function promptName() {
      const name = prompt(currentLang === 'uk' ? '–í–≤–µ–¥—ñ—Ç—å –≤–∞—à–µ —ñ–º‚Äô—è:' : 'Enter your name:');
      if (name) {
        username = name.trim();
        localStorage.setItem('username', username);
        updateUserInfo();
        updateUI();
      }
    }

    /**
     * Update the greeting and stats displayed on the home screen. Calculates
     * the current level based on accumulated points and displays the current
     * streak. Uses the translation functions defined in the UI dictionary.
     */
    function updateUserInfo() {
      const greetElem = document.getElementById('greeting');
      const statsElem = document.getElementById('stats');
      const setNameText = document.getElementById('setNameText');
      if (!greetElem || !statsElem || !setNameText) return;
      if (username) {
        greetElem.textContent = ui[currentLang].greeting(username);
      } else {
        greetElem.textContent = '';
      }
      const level = Math.floor(totalPoints / levelPointsThreshold) + 1;
      statsElem.textContent = ui[currentLang].stats(totalPoints, level, streakCount);
      setNameText.textContent = ui[currentLang].setName;
    }

    /**
     * Toggle between light and dark themes. Applies or removes the 'dark'
     * class on the document body and persists the choice in localStorage.
     */
    function toggleTheme() {
      const body = document.body;
      const isDark = body.classList.toggle('dark');
      localStorage.setItem('theme', isDark ? 'dark' : 'light');
      // Update icon on the toggle button
      const themeBtn = document.getElementById('themeToggle');
      if (themeBtn) {
        themeBtn.textContent = isDark ? '‚òÄÔ∏è' : 'üåô';
      }
    }

    /**
     * Initialize the theme based on persisted setting. Called once on page
     * load to ensure the correct theme is applied before user interaction.
     */
    function initTheme() {
      const saved = localStorage.getItem('theme');
      const body = document.body;
      if (saved === 'dark') {
        body.classList.add('dark');
        const themeBtn = document.getElementById('themeToggle');
        if (themeBtn) themeBtn.textContent = '‚òÄÔ∏è';
      } else {
        body.classList.remove('dark');
        const themeBtn = document.getElementById('themeToggle');
        if (themeBtn) themeBtn.textContent = 'üåô';
      }
    }

    /**
     * Update the daily streak count. If the user practiced today, the streak
     * remains; if they practiced yesterday, increment the streak. Otherwise,
     * reset it to 1. Also updates the lastPracticeDate.
     */
    function updateStreak() {
  const today = new Date();
  const todayStr = today.toISOString().split('T')[0];
  const lastDateStr = (lastPracticeDate || '').toString().slice(0, 10);
  if (lastDateStr === todayStr) {
    // already practiced today, no change
    return;
  }
  const yesterday = new Date(today.getTime() - 86400000);
  const yesterdayStr = yesterday.toISOString().split('T')[0];
  if (lastDateStr === yesterdayStr) {
    streakCount++;
  } else {
    streakCount = 1;
  }
  // Store full ISO with time to avoid timezone confusion in UI
  lastPracticeDate = new Date().toISOString();
  localStorage.setItem('streakCount', streakCount.toString());
  localStorage.setItem('lastPracticeDate', lastPracticeDate);
}

    /**
     * Award points based on the number of correct answers. Each correct answer
     * grants ten points. Points are accumulated in totalPoints and saved in
     * localStorage.
     * @param {number} correctCount - the number of correctly answered questions
     */
    function awardPoints(correctCount) {
      const earned = correctCount * 10;
      totalPoints += earned;
      localStorage.setItem('totalPoints', totalPoints.toString());
    }

    /* ---------------- Listening Mode ---------------- */
    /**
     * Start the listening mode. Generates a set of questions where the user
     * listens to an English word and selects the correct Ukrainian translation.
     */
    function goListening() {
      currentMode = 'listening';
      // Use intermediate number of lives for listening mode
      totalLives = 6;
      remainingLives = totalLives;
      // Create question list from all words, excluding numeric variants (those
      // ending with a digit) so that the spoken word matches a natural form.
      const pool = beginnerWords
        .concat(intermediateWords, advancedWords)
        .filter(w => !/\d$/.test(w.en));
      const questionCount = Math.min(100, pool.length);
      questions = shuffleArray(pool).slice(0, questionCount).map(w => {
        return { word: w, type: 'listening', askEnglish: true };
      });
      currentQuestionIndex = 0;
      score = 0;
      // Set UI
      gameScreenElem.classList.remove('hidden');
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      levelTitleEl.textContent = currentLang === 'uk' ? ui.uk.listeningTitle : ui.en.listeningTitle;
      updateLivesDisplay();
      showQuestion();
      updateUI();
    }

    /* ---------------- Hangman Mode ---------------- */
    /**
     * Start a new hangman game. Selects a random word, resets guessed letters
     * and wrong letters, sets the number of lives, and updates the display.
     */
    function startHangman() {
      currentMode = 'hangman';
      // Choose a random word from the entire vocabulary
      const pool = beginnerWords.concat(intermediateWords, advancedWords);
      // Exclude numeric variants so gameplay and hints match pronunciation
      const poolFiltered = pool.filter(w => !/\d$/.test(w.en));
      const randomPair = poolFiltered[Math.floor(Math.random() * poolFiltered.length)];
      hangmanWord = stripDigits(randomPair.en).toLowerCase();
      hangmanGuessed = [];
      hangmanWrong = [];
      hangmanLivesCount = 6;
      // Update UI to show hangman screen
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.remove('hidden');
      // Ensure other mini‚Äëgames are hidden
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      // Set texts
      document.getElementById('hangmanTitle').textContent = ui[currentLang].hangmanTitle;
      document.getElementById('hangmanDesc').textContent = ui[currentLang].hangmanDesc;
      document.getElementById('hangmanSubmitBtn').textContent = ui[currentLang].hangmanSubmit;
      document.getElementById('hangmanRestartBtn').textContent = ui[currentLang].hangmanRestart;
      document.getElementById('hangmanBackBtn').textContent = ui[currentLang].hangmanBack;
      document.getElementById('hangmanInput').value = '';
      document.getElementById('hangmanInput').placeholder = ui[currentLang].hangmanInputPlaceholder;
      // Show hint (Ukrainian translation)
      document.getElementById('hangmanHint').textContent = randomPair.uk;
      updateHangmanDisplay();
    }

    /**
     * Update the hangman display: show guessed letters and underscores for
     * unguessed letters, display wrong letters and remaining lives as hearts.
     */
    function updateHangmanDisplay() {
      const displayElem = document.getElementById('hangmanDisplay');
      const wrongElem = document.getElementById('hangmanWrongLetters');
      const livesElem = document.getElementById('hangmanLives');
      // Build display string
      let disp = '';
      for (let ch of hangmanWord) {
        if (hangmanGuessed.includes(ch)) {
          disp += ch.toUpperCase() + ' ';
        } else {
          disp += '_ ';
        }
      }
      displayElem.textContent = disp.trim();
      wrongElem.textContent = hangmanWrong.length > 0 ? hangmanWrong.join(', ').toUpperCase() : '';
      // Build hearts for remaining lives
      let hearts = '';
      for (let i = 0; i < hangmanLivesCount; i++) hearts += '‚ù§';
      livesElem.textContent = hearts;
    }

    // Register a service worker for offline support
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('service-worker.js').catch(err => {
          console.log('SW registration failed:', err);
        });
      });
    }

    /**
     * Clear all persisted data and reload the game. This will remove
     * stored points, mistakes, username and streaks. A confirmation
     * dialog is shown to prevent accidental resets.
     */
    function resetData() {
      const msg = ui[currentLang].resetConfirm || 'Reset all data?';
      if (confirm(msg)) {
        try {
          localStorage.clear();
        } catch (e) {
          console.warn('Failed to clear local storage', e);
        }
        totalPoints = 0;
        streakCount = 0;
        currentLevel = '';
        currentMode = 'game';
        mistakes = [];
        username = '';
        location.reload();
      }
    }

    /**
     * Handle a letter guess in hangman. Reads the input field, checks the
     * letter against the word, updates guessed or wrong arrays, and updates
     * the display. Detects win or lose conditions and shows messages.
     */
    function guessHangmanLetter() {
      const input = document.getElementById('hangmanInput');
      const letter = input.value.trim().toLowerCase();
      if (!letter || letter.length !== 1 || !/^[a-z]$/.test(letter)) {
        input.value = '';
        return;
      }
      input.value = '';
      if (hangmanGuessed.includes(letter) || hangmanWrong.includes(letter)) {
        return;
      }
      if (hangmanWord.includes(letter)) {
        hangmanGuessed.push(letter);
      } else {
        hangmanWrong.push(letter);
        hangmanLivesCount--;
      }
      updateHangmanDisplay();
      // Check win
      const allGuessed = hangmanWord.split('').every(ch => hangmanGuessed.includes(ch));
      if (allGuessed) {
        alert(ui[currentLang].hangmanWin);
        // Award small bonus points for winning hangman
        awardPoints(5);
        updateUserInfo();
        // Return to home
        backToHome();
        return;
      }
      // Check lose
      if (hangmanLivesCount <= 0) {
        alert(ui[currentLang].hangmanLose(hangmanWord));
        backToHome();
      }
    }

    /* ---------------- True/False mini‚Äëgame ---------------- */
    // Variables to hold True/False questions, current index and score.
    let tfQuestions = [];
    let tfCurrentIndex = 0;
    let tfScore = 0;

    /**
     * Launch the True/False game. Builds a list of random questions using the
     * entire vocabulary. For each question we choose whether to display the
     * correct Ukrainian translation or a random incorrect one. Then it
     * hides all other screens and shows the True/False screen.
     */
    function goTrueFalse() {
      currentMode = 'truefalse';
      // Build the pool of all words. Exclude numeric variants (those ending with a digit)
      const pool = beginnerWords
        .concat(intermediateWords, advancedWords)
        .filter(w => !/\d$/.test(w.en));
        const poolFiltered = pool;
const questionCount = Math.min(20, pool.length);
      const selected = shuffleArray(pool).slice(0, questionCount);
      tfQuestions = [];
      selected.forEach(w => {
        const correctUk = w.uk;
        let showUk;
        let isCorrect;
        if (Math.random() < 0.5) {
          // Present the correct translation
          showUk = correctUk;
          isCorrect = true;
        } else {
          // Present a random incorrect translation
          let wrong;
          do {
            const rand = poolFiltered[Math.floor(Math.random() * poolFiltered.length)].uk;
            wrong = rand;
          } while (wrong === correctUk);
          showUk = wrong;
          isCorrect = false;
        }
        tfQuestions.push({ en: w.en, uk: correctUk, showUk, isCorrect });
      });
      tfCurrentIndex = 0;
      tfScore = 0;
      // Hide other screens and show TF screen
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.remove('hidden');
      showTFQuestion();
      updateUI();
    }

    /**
     * Display the current True/False question or finish the game when
     * questions are exhausted. Updates the question text and progress.
     */
    function showTFQuestion() {
      const tfQuestionDiv = document.getElementById('tfQuestion');
      const tfProgress = document.getElementById('tfProgress');
      const tfFinishBtn = document.getElementById('tfFinishBtn');
      const tfOptionsDiv = document.getElementById('tfOptions');
      // Hide finish button while we still have questions
      tfFinishBtn.classList.add('hidden');
      // Ensure answer buttons are visible
      tfOptionsDiv.style.display = 'flex';
      // Ensure back button is visible for each question
      const tfBackBtn = document.getElementById('tfBackBtn');
      if (tfBackBtn) tfBackBtn.classList.remove('hidden');
      if (tfCurrentIndex >= tfQuestions.length) {
        finishTrueFalseGame();
        return;
      }
      const q = tfQuestions[tfCurrentIndex];
      // Remove numeric suffix from English word when displaying True/False questions
      const baseEn = stripDigits(q.en);
      tfQuestionDiv.textContent = currentLang === 'uk'
        ? `–ü–µ—Ä–µ–∫–ª–∞–¥ —Å–ª–æ–≤–∞ "${baseEn}" ‚Äî "${q.showUk}"?`
        : `Is the translation of "${baseEn}" equal to "${q.showUk}"?`;
      tfProgress.textContent = `${tfCurrentIndex + 1} / ${tfQuestions.length}`;
    }

    /**
     * Handle the player's response for a True/False question. Increments
     * the score if the response matches the actual correctness, then
     * advances to the next question.
     * @param {boolean} ans - the player's answer (true if they think the translation is correct)
     */
    function answerTF(ans) {
      const q = tfQuestions[tfCurrentIndex];
      if (q && ans === q.isCorrect) {
        tfScore++;
      }
      else if (q) { addMistake({ en: q.en, uk: q.uk }); }
      tfCurrentIndex++;
      showTFQuestion();
    }

    /**
     * Finish the True/False game. Shows the result to the user, hides the
     * answer buttons and awards points based on the number of correct
     * answers. Also updates the streak and user info.
     */
    function finishTrueFalseGame() {
      // Grab DOM elements locally
      const tfOptionsDiv = document.getElementById('tfOptions');
      const tfProgress = document.getElementById('tfProgress');
      const tfQuestionDiv = document.getElementById('tfQuestion');
      const tfBack = document.getElementById('tfBackBtn');
      const tfFinishBtn = document.getElementById('tfFinishBtn');

      // Hide options and progress
      // Hide the answer buttons completely
      tfOptionsDiv.style.display = 'none';
      tfProgress.textContent = '';
      // Show result message
      tfQuestionDiv.textContent = ui[currentLang].tfScoreText(tfScore, tfQuestions.length);
      // Hide the always-visible back button to avoid duplicates
      if (tfBack) tfBack.classList.add('hidden');
      // Configure and show finish/back button for the end of the game
      tfFinishBtn.textContent = ui[currentLang].back;
      tfFinishBtn.classList.remove('hidden');
      // Award points equal to correct answers (each counts as 10 in awardPoints)
      awardPoints(tfScore);
      updateStreak();
      updateUserInfo();
      updateUI();

      // After showing the score, automatically display the mistakes list for this session
      // by navigating to the Mistakes screen.
      const tfScreen = document.getElementById('tfScreen');
      if (tfScreen) tfScreen.classList.add('hidden');
      mistakesScreenElem.classList.remove('hidden');
      renderMistakes();
}

    /* ---------------- Anagram mini‚Äëgame ---------------- */
    // Variables to hold Anagram questions, current index and score
    let anagramQuestions = [];
    let anagramCurrentIndex = 0;
    let anagramScore = 0;

    /**
     * Launch the Anagram game. Builds a list of random words (excluding numeric
     * variants) and scrambles their letters. Shows the Ukrainian translation
     * as a hint. Hides all other screens and shows the anagram screen.
     */
    function goAnagram() {
      currentMode = 'anagram';
      // Build pool of words excluding numeric variants
      const pool = beginnerWords
        .concat(intermediateWords, advancedWords)
        .filter(w => !/\d$/.test(w.en));
      const questionCount = Math.min(20, pool.length);
      const selected = shuffleArray(pool).slice(0, questionCount);
      anagramQuestions = selected.map(w => {
        // scramble letters of the English word
        const chars = w.en.split('');
        let scrambled = '';
        do {
          scrambled = shuffleArray(chars).join('');
        } while (scrambled.toLowerCase() === w.en.toLowerCase());
        return { en: w.en, uk: w.uk, scrambled };
      });
      anagramCurrentIndex = 0;
      anagramScore = 0;
      // hide other screens
      homeScreenElem.classList.add('hidden');
      learnScreenElem.classList.add('hidden');
      mistakesScreenElem.classList.add('hidden');
      gameScreenElem.classList.add('hidden');
      resultScreenElem.classList.add('hidden');
      memoryScreenElem.classList.add('hidden');
      document.getElementById('hangmanScreen').classList.add('hidden');
      document.getElementById('tfScreen').classList.add('hidden');
      document.getElementById('irregularScreen').classList.add('hidden');
      document.getElementById('anagramScreen').classList.remove('hidden');
      // Ensure back button is visible at the start of the anagram game
      const anagramBack = document.getElementById('anagramBackBtn');
      if (anagramBack) anagramBack.classList.remove('hidden');
      showAnagramQuestion();
      updateUI();
    }

    /**
     * Display the current anagram question or finish the game if no more
     * questions. Updates the scrambled text, hint, progress and button
     * visibility.
     */
    function showAnagramQuestion() {
      const questionDiv = document.getElementById('anagramQuestion');
      const progressDiv = document.getElementById('anagramProgress');
      const finishBtn = document.getElementById('anagramFinishBtn');
      const submitBtnElem = document.getElementById('anagramSubmitBtn');
      const inputElem = document.getElementById('anagramInput');
      if (anagramCurrentIndex >= anagramQuestions.length) {
        finishAnagramGame();
        return;
      }
      const q = anagramQuestions[anagramCurrentIndex];
      // Show scrambled letters and Ukrainian translation hint
      questionDiv.textContent = currentLang === 'uk'
        ? `–†–æ–∑—à–∏—Ñ—Ä—É–π—Ç–µ —Å–ª–æ–≤–æ: ${q.scrambled} (${q.uk})`
        : `Unscramble: ${q.scrambled} (${q.uk})`;
      // Clear input
      if (inputElem) inputElem.value = '';
      // Update progress
      progressDiv.textContent = `${anagramCurrentIndex + 1} / ${anagramQuestions.length}`;
      // ensure finish button hidden and submit visible
      finishBtn.classList.add('hidden');
      submitBtnElem.classList.remove('hidden');
      inputElem.classList.remove('hidden');
    }

    /**
     * Handle the player's input for an anagram question. If the input
     * matches the correct English word (case‚Äëinsensitive), increment
     * score. Advances to the next question.
     */
    function submitAnagram() {
      const inputElem = document.getElementById('anagramInput');
      const userInput = (inputElem ? inputElem.value.trim().toLowerCase() : '');
      const q = anagramQuestions[anagramCurrentIndex];
      if (q && userInput === q.en.toLowerCase()) {
        anagramScore++;
      }
      anagramCurrentIndex++;
      showAnagramQuestion();
    }

    /**
     * Finish the anagram game. Display the result, hide input and submit
     * button, show finish button. Award points and update streak & user.
     */
    function finishAnagramGame() {
      const questionDiv = document.getElementById('anagramQuestion');
      const progressDiv = document.getElementById('anagramProgress');
      const finishBtn = document.getElementById('anagramFinishBtn');
      const submitBtnElem = document.getElementById('anagramSubmitBtn');
      const inputElem = document.getElementById('anagramInput');
      // Hide input and submit button
      if (submitBtnElem) submitBtnElem.classList.add('hidden');
      if (inputElem) inputElem.classList.add('hidden');
      // Clear progress
      progressDiv.textContent = '';
      // Show result
      questionDiv.textContent = ui[currentLang].anagramScoreText(anagramScore, anagramQuestions.length);
      // Hide the always-visible back button to avoid duplicates
      const anagramBack = document.getElementById('anagramBackBtn');
      if (anagramBack) anagramBack.classList.add('hidden');
      // Show finish button and set its text
      finishBtn.textContent = ui[currentLang].back;
      finishBtn.classList.remove('hidden');
      // Award points and update streak & user info
      awardPoints(anagramScore);
      updateStreak();
      updateUserInfo();
      updateUI();
    }

    // Initialize theme and user info before rendering UI
    initTheme();
    updateUserInfo();
    updateUI();
    updateMistakesButton();
  
    initVoiceControls();

    /* ---------------- Profile (Stats) Modal ---------------- */
    function tOrDefault(key, ukFallback, enFallback) {
      try {
        if (ui && ui[currentLang] && ui[currentLang][key]) return ui[currentLang][key];
      } catch(e) {}
      return currentLang === 'uk' ? (ukFallback || '') : (enFallback || '');
    }

    function openProfile() {
      try { buildProfile(); } catch(e) {}
      const modal = document.getElementById('profileModal');
      if (modal) modal.classList.remove('hidden');
    }
    function closeProfile() {
      const modal = document.getElementById('profileModal');
      if (modal) modal.classList.add('hidden');
    }

    function formatPercent(val) {
      if (!isFinite(val)) return '-';
      return Math.round(val * 100) + '%';
    }
    function formatDateLocal(iso) {
  try {
    const locale = (currentLang === 'uk' ? 'uk-UA' : 'en-GB');
    if (typeof iso === 'string' && /^\d{4}-\d{2}-\d{2}$/.test(iso)) {
      // Date-only string stored in older versions -> show date without time, in local tz
      const [y,m,d] = iso.split('-').map(Number);
      const dt = new Date(y, m-1, d);
      return dt.toLocaleDateString(locale);
    }
    const d = new Date(iso);
    return d.toLocaleString(locale);
  } catch(e) { return iso; }
}

    function groupBy(arr, keyFn) {
      const m = new Map();
      for (const it of arr) {
        const k = keyFn(it);
        m.set(k, (m.get(k) || []).concat([it]));
      }
      return m;
    }

    function buildLevelStats(history) {
      const levels = ['beginner','intermediate','advanced','mistakes','custom'];
      const rows = [];
      levels.forEach(lvl => {
        const items = history.filter(h => h.level === lvl);
        if (items.length === 0) return;
        const attempts = items.length;
        const best = Math.max(...items.map(h => h.score / h.total));
        const avg = items.reduce((a,h)=>a + (h.score/h.total),0) / items.length;
        rows.push({ lvl, attempts, best, avg });
      });
      return rows;
    }

    function buildModeStats(history) {
      // mode can be 'game', 'listening', 'hangman', 'truefalse', 'anagram', etc.
      const byMode = groupBy(history, h => h.mode || 'game');
      const rows = [];
      for (const [mode, items] of byMode.entries()) {
        const attempts = items.length;
        const best = Math.max(...items.map(h => h.score / h.total));
        const avg = items.reduce((a,h)=>a + (h.score/h.total),0) / items.length;
        rows.push({ mode, attempts, best, avg });
      }
      return rows;
    }

    function buildProfile() {
      // Titles and buttons
      const profileTitle = document.getElementById('profileTitle');
      if (profileTitle) profileTitle.textContent = tOrDefault('profileTitle', '–ü—Ä–æ—Ñ—ñ–ª—å', 'Profile');
      const exportBtn = document.getElementById('profileExportBtn');
      if (exportBtn) exportBtn.textContent = tOrDefault('profileExport', '–ï–∫—Å–ø–æ—Ä—Ç CSV', 'Export CSV');
      const clearBtn = document.getElementById('profileClearBtn');
      if (clearBtn) clearBtn.textContent = tOrDefault('profileClear', '–û—á–∏—Å—Ç–∏—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é', 'Clear history');
      const closeBtn = document.getElementById('profileCloseBtn');
      if (closeBtn && closeBtn.tagName === 'BUTTON') closeBtn.textContent = tOrDefault('close', '–ó–∞–∫—Ä–∏—Ç–∏', 'Close');

      const hist = JSON.parse(localStorage.getItem('history') || '[]');
      const totalPts = parseInt(localStorage.getItem('totalPoints') || '0');
      const streak = parseInt(localStorage.getItem('streakCount') || '0');
      const lastDate = localStorage.getItem('lastPracticeDate') || '';
      const mistakesArr = JSON.parse(localStorage.getItem('mistakes') || '[]');

      // Summary
      const levelPointsThresholdLocal = (typeof levelPointsThreshold !== 'undefined') ? levelPointsThreshold : 200;
      const levelNum = Math.floor(totalPts / levelPointsThresholdLocal) + 1;
      let avg = 0;
      if (hist.length) {
        avg = hist.reduce((acc, h) => acc + (h.score / h.total), 0) / hist.length;
      }
      const sumEl = document.getElementById('profileSummary');
      if (sumEl) {
        sumEl.innerHTML = `
          <div class="stat-grid">
            <div class="stat"><div>${tOrDefault('points','–û—á–∫–∏','Points')}</div><div style="font-size:1.3rem;font-weight:700">${totalPts}</div></div>
            <div class="stat"><div>${tOrDefault('level','–†—ñ–≤–µ–Ω—å','Level')}</div><div style="font-size:1.3rem;font-weight:700">${levelNum}</div></div>
            <div class="stat"><div>${tOrDefault('streak','–°–µ—Ä—ñ—è','Streak')}</div><div style="font-size:1.3rem;font-weight:700">${streak}</div></div>
            <div class="stat"><div>${tOrDefault('avgScore','–°–µ—Ä–µ–¥–Ω—ñ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç','Average score')}</div><div style="font-size:1.3rem;font-weight:700">${formatPercent(avg)}</div></div>
            <div class="stat"><div>${tOrDefault('mistakesCount','–ö-—Å—Ç—å –ø–æ–º–∏–ª–æ–∫','Mistakes count')}</div><div style="font-size:1.3rem;font-weight:700">${mistakesArr.length}</div></div>
            <div class="stat"><div>${tOrDefault('lastPractice','–û—Å—Ç–∞–Ω–Ω—è –ø—Ä–∞–∫—Ç–∏–∫–∞','Last practice')}</div><div style="font-size:1.0rem;font-weight:600">${lastDate ? formatDateLocal(lastDate) : '‚Äî'}</div></div>
          </div>
        `;
      }

      const lvlTitle = document.getElementById('profileByLevelTitle');
      if (lvlTitle) lvlTitle.textContent = tOrDefault('byLevel','–ó–∞ —Ä—ñ–≤–Ω—è–º–∏','By levels');
      const lvlEl = document.getElementById('profileByLevel');
      if (lvlEl) {
        const rows = buildLevelStats(hist);
        if (!rows.length) {
          lvlEl.textContent = tOrDefault('noData','–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö','No data yet');
        } else {
          let html = `<table class="table"><thead><tr>
            <th>${tOrDefault('level','–†—ñ–≤–µ–Ω—å','Level')}</th>
            <th>${tOrDefault('attempts','–°–ø—Ä–æ–±–∏','Attempts')}</th>
            <th>${tOrDefault('best','–ù–∞–π–∫—Ä–∞—â–∏–π','Best')}</th>
            <th>${tOrDefault('average','–°–µ—Ä–µ–¥–Ω—ñ–π','Average')}</th>
          </tr></thead><tbody>`;
          rows.forEach(r => {
            const levelName = (ui[currentLang] && ui[currentLang].levelTitles && ui[currentLang].levelTitles[r.lvl]) ? ui[currentLang].levelTitles[r.lvl] : r.lvl;
            html += `<tr>
              <td>${levelName}</td>
              <td>${r.attempts}</td>
              <td>${formatPercent(r.best)}</td>
              <td>${formatPercent(r.avg)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          lvlEl.innerHTML = html;
        }
      }

      const modeTitle = document.getElementById('profileByModeTitle');
      if (modeTitle) modeTitle.textContent = tOrDefault('byMode','–ó–∞ —ñ–≥—Ä–∞–º–∏','By games');
      const modeEl = document.getElementById('profileByMode');
      if (modeEl) {
        const rows = buildModeStats(hist);
        if (!rows.length) {
          modeEl.textContent = tOrDefault('noData','–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö','No data yet');
        } else {
          const labels = {
            game: tOrDefault('modeClassic','–ö–ª–∞—Å–∏—á–Ω–∞ –≤—ñ–∫—Ç–æ—Ä–∏–Ω–∞','Classic quiz'),
            listening: tOrDefault('listeningBtn','–ê—É–¥—ñ—é–≤–∞–Ω–Ω—è','Listening'),
            hangman: tOrDefault('hangmanTitle','–í–∏—Å–µ–ª–∏—Ü—ñ','Hangman'),
            truefalse: tOrDefault('tfTitle','–ì—Ä–∞ –ü—Ä–∞–≤–¥–∞/–ù–µ–ø—Ä–∞–≤–¥–∞','True/False Game'),
            anagram: tOrDefault('anagramTitle','–ê–Ω–∞–≥—Ä–∞–º–∞','Anagram'),
            memory: tOrDefault('memoryTitle',"–ì—Ä–∞ –ø–∞–º'—è—Ç—å",'Memory')
          };
          let html = `<table class="table"><thead><tr>
            <th>${tOrDefault('mode','–†–µ–∂–∏–º','Mode')}</th>
            <th>${tOrDefault('attempts','–°–ø—Ä–æ–±–∏','Attempts')}</th>
            <th>${tOrDefault('best','–ù–∞–π–∫—Ä–∞—â–∏–π','Best')}</th>
            <th>${tOrDefault('average','–°–µ—Ä–µ–¥–Ω—ñ–π','Average')}</th>
          </tr></thead><tbody>`;
          rows.forEach(r => {
            const name = labels[r.mode] || r.mode;
            html += `<tr>
              <td>${name}</td>
              <td>${r.attempts}</td>
              <td>${formatPercent(r.best)}</td>
              <td>${formatPercent(r.avg)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          modeEl.innerHTML = html;
        }
      }

      const recentTitle = document.getElementById('profileRecentTitle');
      if (recentTitle) recentTitle.textContent = tOrDefault('recent','–û—Å—Ç–∞–Ω–Ω—ñ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∏','Recent results');
      const recEl = document.getElementById('profileRecent');
      if (recEl) {
        if (!hist.length) {
          recEl.textContent = tOrDefault('noData','–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö','No data yet');
        } else {
          const last = hist.slice(-10).reverse();
          let html = `<table class="table"><thead><tr>
            <th>${tOrDefault('date','–î–∞—Ç–∞','Date')}</th>
            <th>${tOrDefault('mode','–†–µ–∂–∏–º','Mode')}</th>
            <th>${tOrDefault('level','–†—ñ–≤–µ–Ω—å','Level')}</th>
            <th>${tOrDefault('score','–†–∞—Ö—É–Ω–æ–∫','Score')}</th>
            <th>%</th>
          </tr></thead><tbody>`;
          last.forEach(h => {
            const pct = h.total ? (h.score / h.total) : 0;
            const mode = h.mode || 'game';
            const levelName = (ui[currentLang] && ui[currentLang].levelTitles && ui[currentLang].levelTitles[h.level]) ? ui[currentLang].levelTitles[h.level] : (h.level || '');
            html += `<tr>
              <td>${formatDateLocal(h.date)}</td>
              <td>${mode}</td>
              <td>${levelName}</td>
              <td>${h.score}/${h.total}</td>
              <td>${formatPercent(pct)}</td>
            </tr>`;
          });
          html += `</tbody></table>`;
          recEl.innerHTML = html;
        }
      }

      const sumTitle = document.getElementById('profileSummaryTitle');
      if (sumTitle) sumTitle.textContent = tOrDefault('summary','–ó–≤–µ–¥–µ–Ω–Ω—è','Summary');
    }

    function exportHistoryCSV() {
      const hist = JSON.parse(localStorage.getItem('history') || '[]');
      if (!hist.length) { alert(tOrDefault('noData','–ù–µ–º–∞—î –¥–∞–Ω–∏—Ö','No data yet')); return; }
      const headers = ['date','mode','level','score','total'];
      const rows = [headers.join(',')]
        .concat(hist.map(h => [h.date, h.mode || 'game', h.level || '', h.score, h.total].join(',')));
      const csv = rows.join('\n');
      const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'lexiverse-history.csv';
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }

    function clearHistoryData() {
      if (!confirm(tOrDefault('confirmClear','–û—á–∏—Å—Ç–∏—Ç–∏ —ñ—Å—Ç–æ—Ä—ñ—é —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ñ–≤?','Clear results history?'))) return;
      localStorage.removeItem('history');
      buildProfile();
    }

</script>

<script>
document.addEventListener('DOMContentLoaded', () => {
  const header = document.querySelector('header');
  if (!header) return;

  // Collect candidate controls
  const controls = [];
  ['#resetBtn', '#profileBtnTop', '#importTopBtn'].forEach(sel => {
    const el = header.querySelector(sel);
    if (el) controls.push(el);
  });
  // language toggle(s)
  header.querySelectorAll('.language-toggle').forEach(el => controls.push(el));

  // Create actions wrapper
  let actions = header.querySelector('.header-actions');
  if (!actions) {
    actions = document.createElement('div');
    actions.className = 'header-actions';
    header.appendChild(actions);
  }

  // Move controls into wrapper (so we can collapse/expand on mobile)
  controls.forEach(el => actions.appendChild(el));

  // Create hamburger toggle
  let navToggle = document.getElementById('navToggle');
  if (!navToggle) {
    navToggle = document.createElement('button');
    navToggle.id = 'navToggle';
    navToggle.setAttribute('aria-label', 'Toggle menu');
    navToggle.innerHTML = '&#9776;'; // hamburger symbol
    // Insert after the title if exists, otherwise at start
    const h1 = header.querySelector('h1');
    if (h1 && h1.nextSibling) {
      h1.parentNode.insertBefore(navToggle, h1.nextSibling);
    } else if (h1) {
      h1.parentNode.appendChild(navToggle);
    } else {
      header.insertBefore(navToggle, header.firstChild);
    }
  }

  navToggle.addEventListener('click', () => {
    header.classList.toggle('open');
  });

  // Close when clicking outside (mobile)
  document.addEventListener('click', (e) => {
    if (!header.contains(e.target) && header.classList.contains('open')) {
      header.classList.remove('open');
    }
  });
});
</script>

</body>
</html>
